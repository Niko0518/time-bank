# 重新设计分类展开/收起动画系统

## 问题分析

当前展开动画存在的问题：
1. 第1个任务卡片动画正常，但第2、3、4个卡片几乎同时闪现出现
2. 卡片没有呈现波浪式依次入场的效果
3. 展开标签的动画处理不完善

## 解决方案

### 核心思路
- 使用 **Web Animations API** 替代传统的 CSS transition + setTimeout 方案
- 采用 **75% 动画重叠** 的波浪式时序（263ms 延迟）
- 确保动画启动时机正确，避免浏览器渲染优化导致的延迟失效
- 完善展开标签的动画处理

### 技术实现

#### 1. 展开动画实现

**关键步骤**：
1. **准备阶段**：
   - 从 collapsedCategories 中移除当前分类
   - 移除 header 的 collapsed 类
   - 为卡片设置初始隐藏状态（opacity: 0, transform: translateY(10px) scale(0.97)）
   - 移除 listEl 的 collapsed 类，显示容器

2. **动画启动**：
   - 使用 requestAnimationFrame 确保容器布局完成后启动动画
   - 为每个卡片创建独立的动画，设置 75% 重叠的延迟
   - 同时处理展开标签的动画

3. **动画结束清理**：
   - 计算总动画时间
   - 动画结束后移除内联样式
   - 取消动画实例
   - 移除 category-animating 类

#### 2. 保持现有收起动画

- 收起动画工作正常，保持原逻辑不变
- 从末尾到开头依次退场，使用 transitionDelay

#### 3. 展开标签动画

- 随最后一个卡片一起动画出现
- 设置与卡片相同的动画参数

## 代码实现

### 替换 toggleCategory 函数的 else 分支

```javascript
} else {
    // 展开：Web Animations API 实现波浪式交错入场
    collapsedCategories.delete(category);
    headerEl?.classList.remove('collapsed');
    
    const ANIM_DURATION = 350;
    const ANIM_STAGGER = 263; // 75% of duration，波浪式重叠
    
    // 1. 设置初始隐藏状态
    cards.forEach(card => {
        card.style.opacity = '0';
        card.style.transform = 'translateY(10px) scale(0.97)';
        card.style.willChange = 'transform, opacity'; // GPU 加速
    });
    
    // 2. 移除 collapsed 类，显示容器
    listEl.classList.remove('collapsed');
    
    // 3. 下一帧启动动画（确保布局完成）
    requestAnimationFrame(() => {
        const animations = [];
        
        // 卡片动画
        cards.forEach((card, i) => {
            const anim = card.animate([
                { opacity: 0, transform: 'translateY(10px) scale(0.97)' },
                { opacity: 1, transform: 'translateY(0) scale(1)' }
            ], {
                duration: ANIM_DURATION,
                easing: 'ease',
                delay: i * ANIM_STAGGER,
                fill: 'forwards'
            });
            animations.push(anim);
        });
        
        // 展开标签动画
        const expandTag = listEl.querySelector('.task-expand-tag');
        if (expandTag) {
            expandTag.style.opacity = '0';
            const tagAnim = expandTag.animate([
                { opacity: 0 },
                { opacity: 1 }
            ], {
                duration: ANIM_DURATION,
                easing: 'ease',
                delay: cards.length * ANIM_STAGGER,
                fill: 'forwards'
            });
            animations.push(tagAnim);
        }
        
        // 4. 动画结束后清理
        const totalTime = cards.length > 0
            ? (cards.length) * ANIM_STAGGER + ANIM_DURATION + 50
            : 0;
        
        setTimeout(() => {
            // 移除内联样式
            cards.forEach(card => {
                card.style.opacity = '';
                card.style.transform = '';
                card.style.willChange = '';
            });
            
            if (expandTag) {
                expandTag.style.opacity = '';
            }
            
            // 取消动画
            animations.forEach(anim => {
                try {
                    anim.cancel();
                } catch (e) {}
            });
            
            // 移除动画类
            listEl.classList.remove('category-animating');
        }, totalTime);
    });
}
```

### CSS 调整

确保以下 CSS 样式存在：

```css
/* 隐藏状态 - 动画起点 */
.category-tasks-grid .task-card.card-hidden {
    opacity: 0;
    transform: translateY(10px) scale(0.97);
}

/* 动画期间启用过渡 */
.category-tasks-list.category-animating .task-card {
    transition: opacity 0.35s ease, transform 0.35s ease;
    will-change: transform, opacity;
}

/* 展开/收起标签样式 */
.task-expand-tag {
    position: absolute;
    right: 0;
    bottom: 0;
    background: var(--color-primary);
    color: white;
    font-size: 0.7rem;
    font-weight: 600;
    padding: 3px 8px 3px 10px;
    border-radius: 12px 0 12px 0;
}
```

## 预期效果

1. **动画时序**：
   - 第1个卡片开始动画
   - 第1个卡片动画播放到 75% 时，第2个卡片开始动画
   - 以此类推，形成波浪式效果

2. **视觉效果**：
   - 每个卡片都有完整的 350ms 入场动画
   - 卡片呈现自然的波浪式依次入场效果
   - 展开标签随最后一个卡片一起动画出现

3. **性能优化**：
   - 使用 will-change 提示浏览器进行 GPU 加速
   - Web Animations API 在合成线程执行，避免主线程阻塞

## 兼容性

Web Animations API 在现代浏览器中得到广泛支持，对于旧浏览器会优雅降级到基本的显示效果。