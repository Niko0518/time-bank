<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <!-- 
      [AI VERSION RULE] 
      Do NOT update the version number in <title> or any other place.
      The user designates the version number at the START of an update cycle.
    -->
    <title>时间银行 - Time Bank v6.5.0</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="时间银行">
    <link rel="apple-touch-icon" href="icon-192.png">
    <!-- [v6.6.0] 腾讯云 CloudBase SDK v1.7.1 - 使用本地文件 -->
    <script>
        // SDK 加载状态标记
        window.cloudbaseSDKLoaded = false;
        window.cloudbaseSDKError = null;
    </script>
    <script src="cloudbase.v2.bundle.js" 
            onload="window.cloudbaseSDKLoaded = true; console.log('[CloudBase] SDK v2 loaded successfully');"
            onerror="window.cloudbaseSDKError = 'Local SDK v2 load failed'; console.error('[CloudBase] Local SDK v2 load failed!');"></script>
    <style>
        /* --- [v3.7.7] Fixed Layout Implementation --- */
        :root {
            /* [v4.8.2] 修复安卓原生下拉框暗色模式背景问题 */
            color-scheme: light;
            
            /* 1.3.2. Spacing Tokens */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 12px;
            --space-lg: 16px;
            --space-xl: 24px;
            --space-xxl: 32px;

            /* Other variables */
            --bg-gradient: var(--bg-gradient-themed, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-shadow: rgba(0, 0, 0, 0.1);
            --text-color: #333;
            --text-color-light: #666;
            --border-color: #ddd;
            --input-bg: #fff;
            --header-text: white;
            --section-title-color: white;
            --btn-secondary-bg: #f5f5f5;
            --btn-secondary-text: #666;
            --btn-secondary-border: #ddd;
            --habit-border-width: 2px; /* [v3.12.6] Reduced from 4px */
            --dropdown-bg: #ffffff;
            --dropdown-shadow: rgba(0, 0, 0, 0.15);
            --color-primary: #2196F3;
            --color-primary-rgb: 33, 150, 243; /* [v6.1.0] 用于透明度调节 */
            --color-positive: #4CAF50;
            --color-negative: #f44336;
            --color-warning: #FF9800;
            --color-neutral: #607D8B;
            --color-other: #BDBDBD; /* [v3.10.4] Lighter Gray */
            /* [v6.4.x] 全局通透强度（1=默认） */
            --glass-strength: 1;
            --glass-opacity-scale: 1;
            --glass-blur-scale: 1;
            
            /* [v6.0.0] 主题色渐变方案 - 使用中间色避免渐变脏污 */
            --accent-gradient: linear-gradient(135deg, #2196F3 0%, #5c6bc0 50%, #7c4dff 100%);
            --accent-start: #2196F3;
            --accent-mid: #5c6bc0;
            --accent-end: #7c4dff;
            /* [v6.0.0] 主题背景色 */
            --bg-gradient-themed: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            
            /* [v4.5.0] Task Calendar Colors (Green) */
            --color-task-green-1: #9be9a8;
            --color-task-green-2: #40c463;
            --color-task-green-3: #216e39;
            /* [v4.5.0] Task Calendar Colors (Red) */
            --color-task-red-1: #ffcdd2;
            --color-task-red-2: #e57373;
            --color-task-red-3: #f44336;
        }

        [data-theme="dark"] {
            /* [v4.8.2] 修复安卓原生下拉框暗色模式背景问题 */
            color-scheme: dark;
            
            /* [v6.0.0] 暗色模式主题背景 */
            --bg-gradient-themed: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --bg-gradient: var(--bg-gradient-themed);
            --card-bg: rgba(42, 42, 42, 0.95);
            --card-shadow: rgba(0, 0, 0, 0.3);
            --text-color: #e0e0e0;
            --text-color-light: #aaa;
            --border-color: #444;
            --input-bg: #2a2a2a;
            --header-text: #e0e0e0;
            --section-title-color: #e0e0e0;
            --btn-secondary-bg: #3a3a3a;
            --btn-secondary-text: #e0e0e0;
            --btn-secondary-border: #555;
            --dropdown-bg: #3a3a3a;
            --dropdown-shadow: rgba(0, 0, 0, 0.5);
            --color-other: #616161; /* [v3.10.4] Lighter Gray for Dark Mode */
            
            /* [v4.5.2] FIX: Removed 6 incorrect dark mode color variables for calendars */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            -webkit-tap-highlight-color: transparent; /* [v5.9.0] 全局禁用点击蓝色高亮 */
        }

        /* [v5.0.0] 彻底修复移动端过度滚动拉伸问题 */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-gradient);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }

        /* 主滚动容器 */
        .app-scroll-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 80px;
            /* 防止触摸穿透和弹性滚动 */
            touch-action: pan-y;
        }

        .header {
            text-align: center;
            padding: var(--space-xl);
            padding-bottom: 0;
            color: var(--header-text);
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: var(--space-sm);
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .main-container {
            padding: 0 var(--space-lg);
        }
        @media (min-width: 480px) {
            .main-container { padding: 0 var(--space-xl); }
        }

        .balance-card {
            margin-top: var(--space-lg);
            margin-bottom: var(--space-lg);
            background: var(--card-bg);
            border-radius: 15px;
            padding: var(--space-lg);
            text-align: center;
            box-shadow: 0 8px 32px var(--card-shadow);
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            cursor: pointer; /* [v4.1.0] Added */
        }

        .balance-card.negative { background: rgba(255, 235, 238, 0.95); border-color: var(--color-negative); }
        [data-theme="dark"] .balance-card.negative { background: rgba(40, 20, 20, 0.95); }
        
        /* [v6.0.0] 时间余额卡片通透模式 */
        .balance-card.glass {
            background: linear-gradient(135deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.04) 100%);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-top: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }
        .balance-card.glass .balance-title {
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .balance-card.glass .balance-amount {
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        .balance-card.glass .daily-change {
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .balance-card.glass .daily-change .positive { color: #90EE90; }
        .balance-card.glass .daily-change .negative { color: #FFB6C1; }
        
        /* 暗色模式下的通透样式 */
        [data-theme="dark"] .balance-card.glass {
            background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.02) 100%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-top: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        /* 余额为负时的通透模式 */
        .balance-card.glass.negative {
            background: linear-gradient(135deg, rgba(255,100,100,0.15) 0%, rgba(255,80,80,0.08) 100%);
            border-color: rgba(255, 150, 150, 0.4);
        }
        [data-theme="dark"] .balance-card.glass.negative {
            background: linear-gradient(135deg, rgba(255,80,80,0.12) 0%, rgba(255,60,60,0.05) 100%);
            border-color: rgba(255, 120, 120, 0.3);
        }
        
        .balance-title { font-size: 0.9rem; color: var(--text-color-light); margin-bottom: var(--space-sm); }
        .balance-amount { font-size: 2.2rem; font-weight: bold; margin-bottom: var(--space-lg); color: var(--color-primary); }
        .daily-changes { display: flex; justify-content: space-between; font-size: 0.8rem; }
        .daily-change { color: var(--text-color-light); }

        /* [v5.10.0] 卡片堆叠系统 */
        .card-stack {
            margin-top: var(--space-lg);
            margin-bottom: var(--space-lg);
            position: relative;
            touch-action: pan-x pinch-zoom;
        }
        .card-stack .balance-card {
            position: relative;
            z-index: 2; /* 确保在堆叠容器上方 */
            margin-top: 0;
            margin-bottom: 0;
            /* 圆角保持默认，不做修改 */
        }
        /* 堆叠卡片容器 */
        .stacked-cards-container {
            position: relative;
            z-index: 1; /* 在余额卡片下方，负margin时被遮挡 */
            overflow: hidden;
            transition: margin-top 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: margin-top; /* 优化动画性能 */
        }
        .card-stack.collapsed .stacked-cards-container {
            margin-top: -12px; /* 向上移动，但被余额卡片遮挡形成堆叠效果 */
        }
        .card-stack.expanded .stacked-cards-container {
            margin-top: var(--space-lg); /* 正常间距，独立卡片 */
        }
        
        /* [v5.10.0] 统一屏幕时间卡片wrapper */
        .screen-time-wrapper {
            background: linear-gradient(135deg, #27ae60 0%, #1abc9c 100%); /* 默认绿色，由JS动态更新 */
            border-radius: 0 0 15px 15px;
            color: white;
            cursor: pointer;
            /* 统一所有动画参数：0.35s + cubic-bezier(0.4, 0, 0.2, 1) */
            transition: background 0.35s cubic-bezier(0.4, 0, 0.2, 1), 
                        border-radius 0.35s cubic-bezier(0.4, 0, 0.2, 1), 
                        box-shadow 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.25);
            overflow: hidden;
        }
        .card-stack.expanded .screen-time-wrapper {
            border-radius: 15px; /* 展开时完整圆角 */
            box-shadow: 0 4px 16px rgba(74, 144, 226, 0.3);
        }
        [data-theme="dark"] .screen-time-wrapper.classic {
            filter: brightness(0.75);
        }
        
        /* [v5.10.0] 通透模式样式 - iOS透明玻璃质感 */
        .screen-time-wrapper.glass {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.08 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.02 * var(--glass-opacity-scale))) 100%);
            border: 1px solid rgba(255, 255, 255, calc(0.3 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.5 * var(--glass-opacity-scale)));
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
            backdrop-filter: blur(calc(20px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(20px * var(--glass-blur-scale)));
        }
        [data-theme="dark"] .screen-time-wrapper.glass {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.06 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.01 * var(--glass-opacity-scale))) 100%);
            border: 1px solid rgba(255, 255, 255, calc(0.12 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.2 * var(--glass-opacity-scale)));
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
        }
        .card-stack.expanded .screen-time-wrapper.glass {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.18);
        }
        [data-theme="dark"] .card-stack.expanded .screen-time-wrapper.glass {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
        }
        /* 通透模式进度条背景 */
        .screen-time-wrapper.glass .st-progress {
            background: rgba(255, 255, 255, calc(0.2 * var(--glass-opacity-scale))) !important;
        }
        [data-theme="dark"] .screen-time-wrapper.glass .st-progress {
            background: rgba(255, 255, 255, calc(0.12 * var(--glass-opacity-scale))) !important;
        }
        /* 屏幕时间进度条通透模式 - 背景毛玻璃，保留原有进度条颜色 */
        body.glass-mode .st-progress {
            background: rgba(255, 255, 255, calc(0.15 * var(--glass-opacity-scale))) !important;
            backdrop-filter: blur(calc(8px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(8px * var(--glass-blur-scale)));
            border: 1px solid rgba(255, 255, 255, calc(0.2 * var(--glass-opacity-scale)));
        }
        /* 进度条保留原有颜色，仅添加光晕效果 */
        body.glass-mode .st-progress-bar {
            box-shadow: 0 0 8px currentColor;
        }
        /* 通透模式文字和分隔线 */
        .screen-time-wrapper.glass .st-footer {
            border-top-color: rgba(255, 255, 255, 0.15);
        }
        [data-theme="dark"] .screen-time-wrapper.glass .st-footer {
            border-top-color: rgba(255, 255, 255, 0.1);
        }
        
        /* 共享header - 始终显示 */
        .screen-time-shared-header {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            transition: padding 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-stack.collapsed .screen-time-shared-header {
            padding: 22px 16px 12px 16px; /* 顶部补偿负margin */
        }
        .screen-time-shared-header .st-icon { font-size: 1.1rem; margin-right: 8px; }
        .screen-time-shared-header .st-title { font-weight: 600; font-size: 0.95rem; flex: 1; }
        .screen-time-shared-header .st-percent { font-size: 1rem; font-weight: 700; margin-right: 8px; }
        .screen-time-shared-header .st-arrow {
            font-size: 0.8rem;
            opacity: 0.8;
            /* 统一动画参数 */
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-stack.expanded .screen-time-shared-header .st-arrow {
            transform: rotate(180deg);
            opacity: 0; /* 展开时箭头淡出 */
        }
        
        /* 可展开的body - 使用max-height动画 */
        .screen-time-expandable-body {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            padding: 0 16px;
            /* 统一所有动画参数，包括padding */
            transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                        padding 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card-stack.expanded .screen-time-expandable-body {
            max-height: 150px; /* 足够容纳内容 */
            opacity: 1;
            padding: 0 16px 16px 16px;
        }
        
        /* body内部元素样式 */
        .screen-time-expandable-body .st-progress {
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        .screen-time-expandable-body .st-progress-bar {
            height: 100%;
            background: white;
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .screen-time-expandable-body .st-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            opacity: 0.95;
            margin-bottom: 8px;
        }
        .screen-time-expandable-body .st-footer {
            font-size: 0.85rem;
            opacity: 0.9;
            text-align: center;
            padding-top: 4px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        /* [v5.2.0] 屏幕时间管理卡片 */
        .screen-time-card {
            background: linear-gradient(135deg, var(--color-primary) 0%, #5a8dee 100%);
            border-radius: 15px;
            padding: 16px;
            margin-bottom: var(--space-lg);
            color: white;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-radius 0.3s ease;
            box-shadow: 0 4px 16px rgba(74, 144, 226, 0.3);
        }
        /* [v5.10.0] 堆叠时的样式调整 */
        .card-stack .screen-time-card {
            margin-bottom: 0;
            border-radius: 0 0 15px 15px;
        }
        .screen-time-card:active { transform: scale(0.98); }
        [data-theme="dark"] .screen-time-card {
            filter: brightness(0.70);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
        }
        .screen-time-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        .screen-time-icon { font-size: 1.2rem; margin-right: 8px; }
        .screen-time-title { font-weight: 600; flex: 1; font-size: 1rem; }
        .screen-time-percent { font-size: 1.1rem; font-weight: 700; opacity: 0.95; }
        .screen-time-body { margin-bottom: 8px; }
        .screen-time-progress {
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        .screen-time-progress-bar {
            height: 100%;
            background: white;
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .screen-time-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            opacity: 0.95;
        }
        .screen-time-footer {
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.85rem;
            text-align: center;
            opacity: 0.9;
        }
        .screen-time-card.over-limit {
            box-shadow: 0 4px 16px rgba(231, 76, 60, 0.3);
        }
        .screen-time-card.over-limit .screen-time-footer { color: rgba(255, 200, 200, 0.9); }

        /* 白名单弹窗样式 */
        #whitelistModal .modal-content { display: flex; flex-direction: column; max-height: 70vh; }
        #whitelistModal .modal-body { flex: 1; overflow: hidden; display: flex; flex-direction: column; }
        #whitelistModal .modal-footer { display: flex; gap: 12px; justify-content: flex-end; }
        .whitelist-modal-content { flex: 1; max-height: 40vh; overflow-y: auto; }
        .whitelist-search {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 0.95rem;
            background: var(--bg-color);
            color: var(--text-color);
        }
        .whitelist-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.15s ease;
        }
        .whitelist-item:last-child { border-bottom: none; }
        .whitelist-item:active { background: var(--hover-bg); }
        .whitelist-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            accent-color: var(--color-primary);
        }
        .whitelist-item-name { flex: 1; font-size: 0.95rem; }
        .whitelist-item-pkg { font-size: 0.75rem; color: var(--text-color-light); margin-top: 2px; }

        /* [v5.2.0] 应用选择下拉列表 */
        .app-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--card-shadow);
            z-index: 100;
            margin-top: 4px;
        }
        .app-dropdown.hidden { display: none; }
        .app-dropdown-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.15s ease;
        }
        .app-dropdown-item:last-child { border-bottom: none; }
        .app-dropdown-item:hover, .app-dropdown-item:active { background: var(--hover-bg); }
        .app-dropdown-item-name { font-size: 0.95rem; color: var(--text-color); }
        .app-dropdown-item-pkg { font-size: 0.75rem; color: var(--text-color-light); margin-top: 2px; }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin: var(--space-xl) 0 var(--space-lg) 0;
            color: var(--section-title-color);
        }

        /* [v4.4.0] 布局 section 标题和新按钮 */
        .section-title-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: var(--space-xl) 0 var(--space-lg) 0; /* 复制原 section-title 的 margin */
        }
        .section-title-container .section-title {
            margin: 0; /* 移除 section-title 的默认 margin */
        }
        .btn-highlight-habits-v2 {
            background: none;
            border: 1px solid var(--section-title-color);
            color: var(--section-title-color);
            opacity: 0.8;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            flex-shrink: 0;
            white-space: nowrap;
        }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .btn-highlight-habits-v2:hover {
                opacity: 1;
                background: rgba(255,255,255,0.1);
            }
            [data-theme="light"] .btn-highlight-habits-v2:hover {
                background: rgba(0,0,0,0.05);
            }
        }
        .btn-highlight-habits-v2:active { opacity: 1; background: rgba(255,255,255,0.1); }
        [data-theme="light"] .btn-highlight-habits-v2 {
            border-color: #fff;
            color: #fff;
        }
        [data-theme="light"] .btn-highlight-habits-v2:active { background: rgba(0,0,0,0.05); }

        .recent-tasks-grid, .category-tasks-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }
        @media (min-width: 480px) {
            .recent-tasks-grid, .category-tasks-grid {
                gap: var(--space-lg);
            }
        }
        
        .task-card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: var(--space-md);
            box-shadow: 0 4px 16px var(--card-shadow);
            backdrop-filter: blur(10px);
            position: relative; /* Needed for ::before */
            overflow: visible;
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
            min-width: 0; 
        }

        /* [v3.12.6] Add default border to all cards for visual consistency */
        .task-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
            box-shadow: inset 0 0 0 var(--habit-border-width) var(--border-color); /* Default border */
            border-radius: 12px;
            pointer-events: none;
        }

        /* [v3.12.5] Changed to full inset border shadow */
        /* [v3.12.6] Simplified to only override the color */
        .task-card.is-habit::before {
            /* All other properties are inherited from .task-card::before */
            box-shadow: inset 0 0 0 var(--habit-border-width) var(--habit-color, #ccc); /* Habit color override */
        }
        
        /* [v4.4.0] 高亮未完成习惯的样式 (高优先级) */
        .task-card.is-habit.highlight-incomplete::before {
            box-shadow: inset 0 0 0 var(--habit-border-width) var(--color-negative) !important; /* 强制红色边框 */
        }
        
        /* [v4.12.0] 任务卡片拖动排序样式 */
        .category-tasks-grid {
            -webkit-touch-callout: none;
            position: relative;
        }
        .task-card {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation; /* 默认允许滚动 */
            will-change: transform; /* 提示GPU合成 */
        }
        .task-card.task-dragging {
            opacity: 0.95;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.3);
            z-index: 100;
            position: relative;
            touch-action: none; /* 拖动时阻断所有默认触摸 */
            transition: none !important; /* 强制移除过渡 */
            transform: translate3d(0, 0, 0); /* 初始GPU层 */
        }
        .task-card.task-dragging::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            box-shadow: inset 0 0 0 3px var(--color-primary);
            pointer-events: none;
        }
        /* 占位符样式：防止布局塌缩 */
        .task-card-placeholder {
            visibility: hidden;
            pointer-events: none;
        }
        /* [v5.0.0] 被挤压移动的卡片 - 使用CSS transition，0.4s丝滑动画 */
        .task-card.task-shifting {
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: transform;
        }
        /* 禁用transition的状态 */
        .task-card.task-shift-instant {
            transition: none !important;
        }
        
        /* [v6.0.0] 任务卡片通透模式 - 参照屏幕时间卡片 */
        .task-card.glass {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.08 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.02 * var(--glass-opacity-scale))) 100%);
            border: 1px solid rgba(255, 255, 255, calc(0.3 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.5 * var(--glass-opacity-scale)));
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
            backdrop-filter: blur(calc(16px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(16px * var(--glass-blur-scale)));
        }
        .task-card.glass::before {
            display: none !important; /* 完全隐藏边框伪元素，包括习惯任务 */
        }
        [data-theme="dark"] .task-card.glass {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.06 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.01 * var(--glass-opacity-scale))) 100%);
            border: 1px solid rgba(255, 255, 255, calc(0.12 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.2 * var(--glass-opacity-scale)));
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(calc(16px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(16px * var(--glass-blur-scale)));
        }
        /* 通透模式文字 - 任务名称 */
        .task-card.glass .task-name {
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        /* 通透模式文字 - 第二行时间/状态 */
        .task-card.glass .task-time,
        .task-card.glass .task-description {
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        /* 通透模式文字 - 第三行参数/详情（增强可读性） */
        .task-card.glass .task-parameters {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
            font-weight: 500;
        }
        .task-card.glass .more-btn {
            color: rgba(255, 255, 255, 0.7);
            /* [v6.2.4-Cleanup] 标签改为 div 后，无需复杂的重置代码 */
            background: transparent;
            border-radius: 4px;
            
            /* 确保层级正确 */
            position: relative;
            z-index: 2;
        }

        /* 恢复点击/悬停时的高亮反馈 */
        .task-card.glass .more-btn:hover,
        .task-card.glass .more-btn:focus-visible {
            background-color: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.95);
        }
        .task-card.glass .more-btn:active {
            background-color: rgba(255, 255, 255, 0.25);
            color: white;
            transition: background-color 0.1s ease;
        }
        /* 通透模式按钮基础样式 */
        .task-card.glass .task-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.25);
        }
        .task-card.glass .task-btn.primary {
            background: rgba(var(--color-primary-rgb), 0.6);
        }
        .task-card.glass .task-btn.success {
            background: rgba(76, 175, 80, 0.6);
        }
        .task-card.glass .task-btn.warning {
            background: rgba(255, 152, 0, 0.6); /* 橙黄色暂停按钮 */
        }
        .task-card.glass .task-btn.danger {
            background: rgba(244, 67, 54, 0.6);
        }
        .task-card.glass .task-btn.secondary {
            background: rgba(120, 120, 120, 0.4); /* 灰色取消按钮，更淡 */
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        /* 拖动时隐藏边框效果 */
        .task-card.glass.task-dragging {
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.3);
        }
        .task-card.glass.task-dragging::after {
            display: none; /* 隐藏拖动时的蓝色边框 */
        }
        /* [v6.4.6] 全局浮动菜单通透模式 - 与弹窗modal-content样式一致，含最小值保障 */
        body.glass-mode .global-task-menu {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.12 * max(var(--glass-opacity-scale), 0.2))) 0%, rgba(255,255,255, calc(0.06 * max(var(--glass-opacity-scale), 0.2))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * max(var(--glass-opacity-scale), 0.2))) !important;
            border-top: 1px solid rgba(255, 255, 255, calc(0.5 * max(var(--glass-opacity-scale), 0.2))) !important;
            backdrop-filter: blur(calc(25px * max(var(--glass-blur-scale), 0.2))) !important;
            -webkit-backdrop-filter: blur(calc(25px * max(var(--glass-blur-scale), 0.2))) !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2) !important;
        }
        body.glass-mode .global-task-menu-item {
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode .global-task-menu-item:hover,
        body.glass-mode .global-task-menu-item:active {
            background: rgba(255, 255, 255, 0.15);
        }
        [data-theme="dark"] body.glass-mode .global-task-menu {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.08 * max(var(--glass-opacity-scale), 0.2))) 0%, rgba(255,255,255, calc(0.03 * max(var(--glass-opacity-scale), 0.2))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.15 * max(var(--glass-opacity-scale), 0.2))) !important;
            border-top: 1px solid rgba(255, 255, 255, calc(0.25 * max(var(--glass-opacity-scale), 0.2))) !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4) !important;
        }
        [data-theme="dark"] body.glass-mode .global-task-menu-item:hover,
        [data-theme="dark"] body.glass-mode .global-task-menu-item:active {
            background: rgba(255, 255, 255, 0.1);
        }
        /* 非通透模式菜单项hover */
        @media (hover: hover) and (pointer: fine) {
            .global-task-menu-item:hover { background: rgba(0,0,0,0.05); }
            [data-theme="dark"] .global-task-menu-item:hover { background: rgba(255,255,255,0.1); }
        }
        .global-task-menu-item:active { background: rgba(0,0,0,0.05); }
        [data-theme="dark"] .global-task-menu-item:active { background: rgba(255,255,255,0.1); }
        
        .task-row { display: flex; align-items: center; min-width: 0; }
        .task-row.title-row { justify-content: space-between; gap: var(--space-sm); margin-bottom: var(--space-xs); }
        
        /* [v3.17.1] UI Change: Limit task name width and prevent wrap */
        .task-name { 
            font-size: 0.9rem; 
            font-weight: 600; 
            flex: 1; 
            /* word-wrap: break-word; */ /* [v3.17.1] Removed */
            /* white-space: normal; */ /* [v3.17.1] Removed */
            white-space: nowrap; /* [v3.17.1] Added */
            overflow: hidden; /* [v3.17.1] Added */
            text-overflow: clip; /* [v3.17.1] Added */
            max-width: 7.5em; /* [v3.17.1] Added */
        }
        /* [v3.17.1] Removed @media rule for 1080px as requested */

        .task-details { font-size: 0.75rem; color: var(--text-color-light); display: flex; flex-wrap: wrap; align-items: center; gap: 6px; }
        /* [v5.1.0] 参数行单行显示，超出省略；[v5.9.0] 固定高度=徽章高度(21px)+padding(4px)，防止布局跳动 */
        .task-parameters { font-size: 0.85rem; color: var(--text-color-light); justify-content: flex-start; padding: 2px 0; display: flex; flex-wrap: nowrap; align-items: center; overflow: hidden; gap: 6px; min-height: 25px; }
        .task-parameters > span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 0; }
        /* [v5.1.0] 分类标签使用渐变（左深右浅） */
        .task-category { color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.7rem; font-weight: 500; background: var(--category-gradient, var(--color-primary)); }
        .task-completion-count { color: var(--color-positive); font-weight: 500; font-size: 0.7rem; }
        
        .task-actions { display: flex; gap: var(--space-xs); width: 100%; margin-top: var(--space-xs); }
        .task-btn { padding: 8px; border: none; border-radius: 8px; font-size: 0.85rem; font-weight: 600; cursor: pointer; white-space: nowrap; text-align: center; flex: 1; }
        .task-btn.wide { padding: 10px; }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .task-btn:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); }
        }
        .task-btn:active { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); }
        .task-btn.primary { background: var(--color-primary); color: white; } .task-btn.success { background: var(--color-positive); color: white; } .task-btn.warning { background: var(--color-warning); color: white; } .task-btn.danger { background: var(--color-negative); color: white; } .task-btn.secondary { background: #9E9E9E; color: white; }

        /* [v5.1.0] 运行中任务的悬浮徽章（内联胶囊，不撑高布局） */
        .task-timer-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 7px;
            border-radius: 999px;
            background: var(--accent-gradient);
            color: #fff;
            font-size: 0.78rem;
            font-weight: 700;
            line-height: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            pointer-events: none;
        }
        [data-theme="dark"] .task-timer-badge {
            background: var(--accent-gradient);
            color: #f8f8f8;
        }
        .task-timer-badge.with-progress {
            font-size: 0.74rem;
        }
        .task-parameters.has-timer-badge {
            justify-content: space-between;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .more-btn { 
            background: none; 
            border: none; 
            font-size: 1.2rem; 
            font-weight: bold; 
            cursor: pointer; 
            color: var(--text-color-light); 
            padding: 0 4px; 
            border-radius: 4px; 
            flex-shrink: 0; 
            line-height: 1; 
            -webkit-tap-highlight-color: transparent;
            
            /* [v6.2.4-Fix] 适配 div 标签：增加布局属性 */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
        }
        /* [v5.4.0] 仅桌面端启用 hover */
        @media (hover: hover) and (pointer: fine) {
            .more-btn:hover { background: var(--btn-secondary-bg); color: var(--text-color); }
        }
        .more-btn:active { background: var(--btn-secondary-bg); color: var(--text-color); }
        .more-btn:focus { outline: none; }
        .more-btn:focus-visible { outline: 2px solid var(--primary-color); outline-offset: 2px; border-radius: 6px; background: var(--btn-secondary-bg); color: var(--text-color); }
        /* [v6.4.6] 任务卡片内嵌菜单（隐藏，仅作为数据容器） */
        .task-card-menu { display: none !important; }
        
        /* [v6.4.6] 全局浮动菜单 - 独立于任务卡片，backdrop-filter可正常工作 */
        .global-task-menu { 
            display: none; 
            position: fixed; 
            background: var(--dropdown-bg); 
            border-radius: 8px; 
            box-shadow: 0 4px 12px var(--dropdown-shadow); 
            z-index: 1001; 
            overflow-y: auto; 
            border: 1px solid var(--border-color); 
        }
        .global-task-menu.show { display: flex; flex-direction: column; }
        /* [v6.4.6] 菜单项自适应高度 */
        .global-task-menu-item { padding: 8px 15px; font-size: 0.85rem; color: var(--text-color); cursor: pointer; white-space: nowrap; outline: none; -webkit-tap-highlight-color: transparent; display: flex; align-items: center; min-height: 36px; }
        @media (hover: hover) and (pointer: fine) {
            .global-task-menu-item:hover { background: rgba(0,0,0,0.05); }
            [data-theme="dark"] .global-task-menu-item:hover { background: rgba(255,255,255,0.1); }
        }
        .global-task-menu-item:active { background: rgba(0,0,0,0.05); }
        [data-theme="dark"] .global-task-menu-item:active { background: rgba(255,255,255,0.1); }
        .global-task-menu-item:focus-visible { background: rgba(0,0,0,0.06); }
        [data-theme="dark"] .global-task-menu-item:focus-visible { background: rgba(255,255,255,0.14); }
        
        /* [v6.4.0] 自定义下拉选择器 - 参考 task-card-menu 样式 */
        .custom-select-wrapper { position: relative; width: 100%; }
        .custom-select-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: var(--space-md);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-color);
            cursor: pointer;
            font-size: 1rem;
            -webkit-tap-highlight-color: transparent;
        }
        .custom-select-trigger::after {
            content: '▼';
            font-size: 0.6em;
            color: var(--text-color-light);
            margin-left: 8px;
        }
        .custom-select-trigger:focus { outline: none; border-color: var(--color-primary); }
        .dropdown-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: var(--dropdown-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--dropdown-shadow);
            z-index: 100;
            overflow: hidden;
            border: 1px solid var(--border-color);
            display: none;
        }
        .dropdown-menu.show { display: block; }
        .dropdown-menu-item {
            padding: 10px 15px;
            font-size: 0.9rem;
            color: var(--text-color);
            cursor: pointer;
            white-space: nowrap;
            -webkit-tap-highlight-color: transparent;
        }
        @media (hover: hover) and (pointer: fine) {
            .dropdown-menu-item:hover { background: rgba(0,0,0,0.05); }
            [data-theme="dark"] .dropdown-menu-item:hover { background: rgba(255,255,255,0.1); }
        }
        .dropdown-menu-item:active { background: rgba(0,0,0,0.05); }
        [data-theme="dark"] .dropdown-menu-item:active { background: rgba(255,255,255,0.1); }
        .dropdown-menu-item.selected { 
            background: rgba(var(--color-primary-rgb), 0.1);
            color: var(--color-primary);
            font-weight: 500;
        }
        /* [v6.4.0] 通透模式下拉菜单 - 自定义下拉选择器专用样式 */
        /* 触发器样式 - 与普通输入框一致 */
        body.glass-mode .custom-select-trigger,
        body.glass-mode .custom-select-wrapper .custom-select-trigger {
            background: rgba(255, 255, 255, 0.08) !important;
            border: 1px solid rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        body.glass-mode .custom-select-trigger::after,
        body.glass-mode .custom-select-wrapper .custom-select-trigger::after { 
            color: rgba(255,255,255,0.7); 
        }
        /* 下拉菜单样式 - 参考任务卡片本身的毛玻璃效果 */
        body.glass-mode .custom-select-wrapper .dropdown-menu {
            background: linear-gradient(
                135deg,
                rgba(87, 87, 87, calc(0.8 * max(var(--glass-opacity-scale), 0.2))) 0%,
                rgba(88, 88, 88, calc(0.8 * max(var(--glass-opacity-scale), 0.2))) 100%
            ) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.25 * max(var(--glass-opacity-scale), 0.2))) !important;
            backdrop-filter: blur(calc(25px * max(var(--glass-blur-scale), 0.2))) !important;
            -webkit-backdrop-filter: blur(calc(25px * max(var(--glass-blur-scale), 0.2))) !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4) !important;
        }
        body.glass-mode .custom-select-wrapper .dropdown-menu-item { 
            color: white !important; 
            padding: 12px 16px;
            background: transparent !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .custom-select-wrapper .dropdown-menu-item:hover,
        body.glass-mode .custom-select-wrapper .dropdown-menu-item:active { 
            background: rgba(255,255,255,0.12) !important; 
        }
        body.glass-mode .custom-select-wrapper .dropdown-menu-item.selected { 
            background: rgba(var(--color-primary-rgb), 0.4) !important;
            color: white !important;
            font-weight: 500;
        }
        
        /* [v6.4.0] 任务类型选择弹窗样式 */
        #taskTypeModal { z-index: 2100 !important; }
        .task-type-section { margin-bottom: var(--space-lg); }
        .task-type-group-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-color-light);
            margin-bottom: var(--space-sm);
            padding-left: 4px;
        }
        .task-type-option {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            padding: var(--space-md);
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: var(--space-sm);
            background: var(--btn-secondary-bg);
            border: 2px solid transparent;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .task-type-option:last-child { margin-bottom: 0; }
        @media (hover: hover) and (pointer: fine) {
            .task-type-option:hover { 
                border-color: var(--color-primary);
                background: rgba(var(--color-primary-rgb), 0.08);
            }
        }
        .task-type-option:active { 
            border-color: var(--color-primary);
            background: rgba(var(--color-primary-rgb), 0.08);
        }
        .task-type-option.selected {
            border-color: var(--color-primary);
            background: rgba(var(--color-primary-rgb), 0.12);
        }
        .task-type-option-icon { font-size: 1.5rem; width: 40px; text-align: center; }
        .task-type-option-info { flex: 1; }
        .task-type-option-name { font-weight: 600; font-size: 0.95rem; margin-bottom: 2px; }
        .task-type-option-desc { font-size: 0.8rem; color: var(--text-color-light); }
        /* 通透模式 */
        body.glass-mode .task-type-option {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.15);
        }
        body.glass-mode .task-type-option:hover,
        body.glass-mode .task-type-option:active {
            border-color: rgba(var(--color-primary-rgb), 0.7) !important;
            background: rgba(var(--color-primary-rgb), 0.2) !important;
        }
        body.glass-mode .task-type-option.selected {
            border-color: var(--color-primary) !important;
            background: rgba(var(--color-primary-rgb), 0.25) !important;
        }
        body.glass-mode .task-type-group-label { color: rgba(255,255,255,0.7); }
        body.glass-mode .task-type-option-name { color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.35); }
        body.glass-mode .task-type-option-desc { color: rgba(255,255,255,0.78); }
        /* [v6.4.1] 戒除习惯奖励小字通透模式适配 */
        body.glass-mode .reward-desc-text { color: rgba(255,255,255,0.7); }
        
        /* [v6.4.0] 底部抽屉式弹窗样式 */
        .bottom-sheet-modal {
            align-items: flex-end !important;
        }
        .bottom-sheet-content {
            background: var(--card-bg);
            border-radius: 20px 20px 0 0;
            width: 100%;
            max-width: 480px;
            max-height: 60vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.25s ease-out;
        }
        .bottom-sheet-modal.show .bottom-sheet-content {
            transform: translateY(0);
        }
        .bottom-sheet-content.slide-close {
            transform: translateY(100%) !important;
            transition: transform 0.2s ease !important;
        }
        .bottom-sheet-header {
            padding: var(--space-md) var(--space-lg);
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            cursor: grab;
            user-select: none;
            touch-action: none;
        }
        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin: 0 auto var(--space-sm);
        }
        .bottom-sheet-title {
            font-weight: 600;
            font-size: 1rem;
        }
        .bottom-sheet-body {
            padding: var(--space-md) var(--space-lg);
            overflow-y: auto;
            overscroll-behavior: contain;
        }
        .bottom-sheet-content.dragging {
            animation: none;
            transition: none !important;
        }
        .category-select-item {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            padding: var(--space-md);
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: var(--space-sm);
            background: var(--btn-secondary-bg);
            -webkit-tap-highlight-color: transparent;
        }
        .category-select-item:last-child { margin-bottom: 0; }
        @media (hover: hover) and (pointer: fine) {
            .category-select-item:hover { background: rgba(var(--color-primary-rgb), 0.1); }
        }
        .category-select-item:active { background: rgba(var(--color-primary-rgb), 0.1); }
        .category-select-item.selected {
            background: rgba(var(--color-primary-rgb), 0.15);
            border: 2px solid var(--color-primary);
        }
        .category-select-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .category-select-name { font-size: 0.95rem; }
        /* 通透模式 */
        body.glass-mode .bottom-sheet-modal {
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        body.glass-mode .bottom-sheet-content {
            background: linear-gradient(150deg, rgba(255,255,255, calc(0.16 * max(var(--glass-opacity-scale), 0.2))) 0%, rgba(255,255,255, calc(0.08 * max(var(--glass-opacity-scale), 0.2))) 55%, rgba(255,255,255, calc(0.05 * max(var(--glass-opacity-scale), 0.2))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.22 * max(var(--glass-opacity-scale), 0.2)));
            border-bottom: none;
            backdrop-filter: blur(calc(22px * max(var(--glass-blur-scale), 0.2)));
            -webkit-backdrop-filter: blur(calc(22px * max(var(--glass-blur-scale), 0.2)));
            box-shadow: 0 12px 36px rgba(0, 0, 0, 0.25);
        }
        body.glass-mode .bottom-sheet-header { border-bottom-color: rgba(255,255,255,0.12); }
        body.glass-mode .bottom-sheet-handle { background: rgba(255,255,255,0.35); }
        body.glass-mode .bottom-sheet-title { color: white; }
        body.glass-mode .category-select-item {
            background: rgba(255, 255, 255, calc(0.12 * max(var(--glass-opacity-scale), 0.2))) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.08 * max(var(--glass-opacity-scale), 0.2)));
        }
        body.glass-mode .category-select-item:hover,
        body.glass-mode .category-select-item:active {
            background: rgba(var(--color-primary-rgb), calc(0.22 * max(var(--glass-opacity-scale), 0.2))) !important;
        }
        body.glass-mode .category-select-item.selected {
            background: rgba(var(--color-primary-rgb), calc(0.28 * max(var(--glass-opacity-scale), 0.2))) !important;
            border-color: var(--color-primary);
        }
        body.glass-mode .category-select-name { color: white; }
        /* 分类选择触发器更紧凑 */
        .category-select-trigger {
            padding: 8px 12px;
            font-size: 0.9rem;
        }
        
        .category-tasks { margin-bottom: var(--space-xl); }
        .category-header { display: flex; justify-content: space-between; align-items: center; background: var(--card-bg); padding: var(--space-md) var(--space-lg); border-radius: 10px; margin-bottom: var(--space-md); cursor: pointer; }
        /* [v5.4.0] 仅桌面端启用 hover */
        @media (hover: hover) and (pointer: fine) {
            .category-header:hover { background: rgba(255, 255, 255, 1); }
        }
        .category-header:active { background: rgba(255, 255, 255, 1); }
        .category-info { display: flex; align-items: center; gap: var(--space-md); }
        .category-color { width: 12px; height: 12px; border-radius: 50%; }
        .category-name { font-weight: 600; font-size: 0.95rem; }
        .category-count { color: var(--text-color-light); font-size: 0.85rem; }
        .category-toggle { transition: transform 0.2s ease; font-size: 0.8rem; color: var(--text-color-light); }
        .category-header.collapsed .category-toggle { transform: rotate(-90deg); }
        .category-tasks-list { max-height: 1000px; overflow: hidden; transition: max-height 0.3s ease; }
        .category-tasks-list.collapsed { max-height: 0; }
        
        /* [v6.0.0] 分类折叠框通透模式 */
        body.glass-mode .category-header {
            background: linear-gradient(
                135deg,
                rgba(255,255,255, calc(0.12 * var(--glass-opacity-scale))) 0%,
                rgba(255,255,255, calc(0.06 * var(--glass-opacity-scale))) 100%
            ) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.45 * var(--glass-opacity-scale)));
            backdrop-filter: blur(calc(15px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(15px * var(--glass-blur-scale)));
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        body.glass-mode .category-header:hover,
        body.glass-mode .category-header:active {
            background: linear-gradient(
                135deg,
                rgba(255,255,255, calc(0.18 * var(--glass-opacity-scale))) 0%,
                rgba(255,255,255, calc(0.10 * var(--glass-opacity-scale))) 100%
            ) !important;
        }
        body.glass-mode .category-name {
            color: white !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .category-count {
            color: rgba(255, 255, 255, 0.75) !important;
        }
        body.glass-mode .category-toggle {
            color: rgba(255, 255, 255, 0.8) !important;
        }
        [data-theme="dark"] body.glass-mode .category-header {
            background: linear-gradient(135deg, rgba(255,255,255,0.10) 0%, rgba(255,255,255,0.04) 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-top: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .empty-message { text-align: center; color: rgba(255, 255, 255, 0.7); font-style: italic; padding: 40px 20px; }
        [data-theme="dark"] .empty-message { color: rgba(255, 255, 255, 0.5); }
        
        .fab { position: fixed; bottom: 100px; right: 20px; width: 56px; height: 56px; border-radius: 50%; background: var(--color-primary); color: white; border: none; font-size: 1.5rem; cursor: pointer; box-shadow: 0 4px 16px rgba(var(--color-primary-rgb), 0.4); z-index: 1000; }
        /* [v6.2.0] 星夜主题 - 非通透模式：使用星星背景图，简洁风格 */
        body[data-accent="the-starry-night"]:not(.glass-mode) .fab {
            background: url('themes/bottom_the-starry-night.png') center/cover, var(--color-primary) !important;
            box-shadow: 0 4px 16px rgba(21, 101, 192, 0.4) !important;
        }
        /* [v6.2.0] 星夜主题 - 通透模式：星星背景 + 毛玻璃 + 蓝色光晕 */
        body.glass-mode[data-accent="the-starry-night"] .fab {
            background: url('themes/bottom_the-starry-night.png') center/cover, radial-gradient(circle at center, rgba(21, 101, 192, 0.5), rgba(13, 27, 42, 0.7)) !important;
            backdrop-filter: blur(calc(10px * var(--glass-blur-scale))) !important;
            -webkit-backdrop-filter: blur(calc(10px * var(--glass-blur-scale))) !important;
            border: 1px solid rgba(21, 101, 192, 0.4) !important;
            box-shadow: 
                0 0 24px rgba(21, 101, 192, 0.8),
                0 0 40px rgba(21, 101, 192, 0.5),
                0 4px 20px rgba(13, 27, 42, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.1) !important;
        }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .fab:hover { transform: scale(1.1); box-shadow: 0 6px 20px rgba(var(--color-primary-rgb), 0.6); }
            body[data-accent="the-starry-night"]:not(.glass-mode) .fab:hover {
                box-shadow: 0 6px 20px rgba(21, 101, 192, 0.5) !important;
            }
            body.glass-mode[data-accent="the-starry-night"] .fab:hover {
                box-shadow: 
                    0 0 30px rgba(21, 101, 192, 1),
                    0 0 50px rgba(21, 101, 192, 0.7),
                    0 6px 24px rgba(13, 27, 42, 0.6),
                    inset 0 0 25px rgba(255, 255, 255, 0.15) !important;
            }
            body[data-accent="woman-with-a-parasol"]:not(.glass-mode) .fab:hover {
                    box-shadow: 0 6px 20px rgba(77, 182, 172, 0.5) !important;
            }
            body.glass-mode[data-accent="woman-with-a-parasol"] .fab:hover {
                box-shadow: 
                    0 0 30px rgba(77, 182, 172, 0.8),
                    0 0 50px rgba(77, 182, 172, 0.5),
                    0 6px 24px rgba(0, 0, 0, 0.15),
                    inset 0 0 25px rgba(255, 255, 255, 0.25) !important;
            }
            /* [v6.4.6] 杏花盛开主题 FAB hover */
            body[data-accent="almond-blossoms"]:not(.glass-mode) .fab:hover {
                box-shadow: 0 6px 20px rgba(70, 132, 153, 0.5) !important;
            }
            body.glass-mode[data-accent="almond-blossoms"] .fab:hover {
                box-shadow: 
                    0 0 30px rgba(70, 132, 153, 0.8),
                    0 0 50px rgba(70, 132, 153, 0.5),
                    0 6px 24px rgba(0, 0, 0, 0.15),
                    inset 0 0 25px rgba(255, 255, 255, 0.25) !important;
            }
        }

        /* [v6.3.0] 莫奈主题 - 非通透模式：使用撑阳伞背景图 */
        body[data-accent="woman-with-a-parasol"]:not(.glass-mode) .fab {
            background-image: url('themes/bottom_woman-with-a-parasol.png'), linear-gradient( var(--color-primary), var(--color-primary) ) !important;
            background-position: center !important;
            background-size: 100% 100% !important;
            background-repeat: no-repeat !important;
            box-shadow: 0 4px 16px rgba(77, 182, 172, 0.4) !important;
            border: none !important;
        }
        /* [v6.3.0] 莫奈主题 - 通透模式：撑阳伞背景 + 毛玻璃 + 青色光晕 */
        body.glass-mode[data-accent="woman-with-a-parasol"] .fab {
            background-image: url('themes/bottom_woman-with-a-parasol.png'), radial-gradient(circle at center, rgba(77, 182, 172, 0.5), rgba(129, 199, 132, 0.4)) !important;
            background-position: center !important;
            background-size: 100% 100% !important;
            background-repeat: no-repeat !important;
            backdrop-filter: blur(calc(10px * var(--glass-blur-scale))) !important;
            -webkit-backdrop-filter: blur(calc(10px * var(--glass-blur-scale))) !important;
            border: 1px solid rgba(77, 182, 172, 0.4) !important;
            box-shadow: 
                0 0 24px rgba(77, 182, 172, 0.6),
                0 0 40px rgba(77, 182, 172, 0.3),
                0 4px 20px rgba(0, 0, 0, 0.1),
                inset 0 0 20px rgba(255, 255, 255, 0.2) !important;
        }
        /* [v6.4.6] 杏花盛开主题 - 非通透模式 */
        body[data-accent="almond-blossoms"]:not(.glass-mode) .fab {
            background-image: url('themes/bottom_almond-blossoms.png'), linear-gradient(var(--color-primary), var(--color-primary)) !important;
            background-position: center !important;
            background-size: 100% 100% !important;
            background-repeat: no-repeat !important;
            box-shadow: 0 4px 16px rgba(70, 132, 153, 0.4) !important;
        }
        /* [v6.4.6] 杏花盛开主题 - 通透模式 */
        body.glass-mode[data-accent="almond-blossoms"] .fab {
            background-image: url('themes/bottom_almond-blossoms.png'), radial-gradient(circle at center, rgba(70, 132, 153, 0.5), rgba(90, 159, 176, 0.4)) !important;
            background-position: center !important;
            background-size: 100% 100% !important;
            background-repeat: no-repeat !important;
            backdrop-filter: blur(calc(10px * var(--glass-blur-scale))) !important;
            -webkit-backdrop-filter: blur(calc(10px * var(--glass-blur-scale))) !important;
            border: 1px solid rgba(70, 132, 153, 0.4) !important;
            box-shadow: 
                0 0 24px rgba(70, 132, 153, 0.6),
                0 0 40px rgba(70, 132, 153, 0.3),
                0 4px 20px rgba(0, 0, 0, 0.1),
                inset 0 0 20px rgba(255, 255, 255, 0.2) !important;
        }
        .fab:active { transform: scale(0.95); box-shadow: 0 2px 8px rgba(var(--color-primary-rgb), 0.4); }

        /* [v5.0.0] 底部导航栏固定定位，不受滚动影响 */
        .bottom-tabs { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(calc(10px * max(var(--glass-blur-scale), 0.2))); display: flex; border-top: 1px solid rgba(0, 0, 0, 0.1); z-index: 1000; transform: translateZ(0); }
        .tab-button { flex: 1; padding: 12px 8px; border: none; background: none; text-align: center; cursor: pointer; font-size: 0.75rem; color: var(--text-color-light); }
        .tab-button.active { color: var(--color-primary); background: rgba(var(--color-primary-rgb), 0.1); }
        .tab-icon { font-size: 1.2rem; margin-bottom: var(--space-xs); }
        [data-theme="dark"] .bottom-tabs { background: var(--card-bg); border-top-color: var(--border-color); }
        [data-theme="dark"] .tab-button.active { background: rgba(var(--color-primary-rgb), 0.2); }
        
        /* [v6.0.0] 底部导航栏通透模式 - 比任务卡片高10% */
        .bottom-tabs.glass {
            background: linear-gradient(180deg, rgba(255,255,255, calc(0.22 * max(var(--glass-opacity-scale), 0.2))) 0%, rgba(255,255,255, calc(0.16 * max(var(--glass-opacity-scale), 0.2))) 100%);
            border-top: 1px solid rgba(255, 255, 255, calc(0.3 * max(var(--glass-opacity-scale), 0.2)));
            backdrop-filter: blur(calc(20px * max(var(--glass-blur-scale), 0.2)));
            -webkit-backdrop-filter: blur(calc(20px * max(var(--glass-blur-scale), 0.2)));
        }
        .bottom-tabs.glass .tab-button {
            color: rgba(255, 255, 255, 0.8);
        }
        .bottom-tabs.glass .tab-button.active {
            color: white;
            background: rgba(255, 255, 255, 0.15);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        [data-theme="dark"] .bottom-tabs.glass {
            background: linear-gradient(180deg, rgba(255,255,255, calc(0.18 * max(var(--glass-opacity-scale), 0.2))) 0%, rgba(255,255,255, calc(0.12 * max(var(--glass-opacity-scale), 0.2))) 100%);
            border-top: 1px solid rgba(255, 255, 255, calc(0.15 * max(var(--glass-opacity-scale), 0.2)));
        }
        [data-theme="dark"] .bottom-tabs.glass .tab-button {
            color: rgba(255, 255, 255, 0.7);
        }
        [data-theme="dark"] .bottom-tabs.glass .tab-button.active {
            color: white;
            background: rgba(255, 255, 255, 0.12);
        }

        /* ============================================
           [v6.0.0] 全局通透模式 - Global Glass Mode
           透明度层次设计：
           - 最透: 任务卡片 8%→2% / 6%→1%
           - 较透: 设置卡片/图表容器 10%→4% / 8%→3%
           - 中等: 时间余额卡片 12%→4% / 8%→2%
           - 较实: 屏幕时间卡片 18%→12% / 16%→11%
           - 最实: 底部导航栏/弹窗 22%→16% / 18%→12%
           ============================================ */
        
        /* 弹窗/模态框通透模式 - 25%→18% (最实，确保可读性) */
        body.glass-mode .modal-content {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.12 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.06 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.5 * var(--glass-opacity-scale)));
            backdrop-filter: blur(calc(25px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(25px * var(--glass-blur-scale)));
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        [data-theme="dark"] body.glass-mode .modal-content {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.08 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.03 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.15 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.25 * var(--glass-opacity-scale)));
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode .modal-content .modal-title,
        body.glass-mode .modal-content h3 {
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .modal-content label,
        body.glass-mode .modal-content .setting-name,
        body.glass-mode .modal-content p {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode .modal-content .setting-desc,
        body.glass-mode .modal-content .text-muted {
            color: rgba(255, 255, 255, 0.75);
        }
        
        /* 设置页面卡片通透模式 - 10%→4% (较透) */
        body.glass-mode .settings-section {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.08 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.02 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.5 * var(--glass-opacity-scale)));
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
            backdrop-filter: blur(calc(20px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(20px * var(--glass-blur-scale)));
        }
        [data-theme="dark"] body.glass-mode .settings-section {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.06 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.01 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.12 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.2 * var(--glass-opacity-scale)));
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
        }
        body.glass-mode .settings-section .settings-title {
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .settings-section .setting-name {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode .settings-section .setting-desc {
            color: rgba(255, 255, 255, 0.7);
        }
        body.glass-mode .settings-section .setting-item {
            border-bottom-color: rgba(255, 255, 255, 0.15);
        }
        /* [v6.0.0] 设置页面表单元素通透模式 */
        body.glass-mode .settings-section .form-label {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        body.glass-mode .settings-section .form-input {
            background: rgba(255, 255, 255, 0.12) !important;
            border-color: rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        body.glass-mode .settings-section .form-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        body.glass-mode .settings-section .threshold-input {
            background: rgba(255, 255, 255, 0.12) !important;
            border-color: rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        /* 设置页面其他文字 */
        body.glass-mode .settings-section #authStatus {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        body.glass-mode .settings-section .setting-controls span {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        /* 设置页面内联标签文字（如"节省时间"“超出时间”） */
        body.glass-mode .settings-section label {
            color: rgba(255, 255, 255, 0.8) !important;
        }
        /* 设置页面 about-section 版本日志通透模式 */
        body.glass-mode .about-section summary {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode .about-section p {
            color: rgba(255, 255, 255, 0.75) !important;
        }
        body.glass-mode .about-section li {
            color: rgba(255, 255, 255, 0.85) !important;
        }
        body.glass-mode .about-section li strong {
            color: white !important;
        }
        body.glass-mode .about-section details {
            border-color: rgba(255, 255, 255, 0.2) !important;
        }
        body.glass-mode .about-section code {
            background: rgba(255, 255, 255, 0.15) !important;
            color: rgba(255, 255, 255, 0.9) !important;
        }

        /* [v6.3.0] 模态框输入框通透模式 (Modal Inputs Glass Mode) */
        body.glass-mode .modal-content .form-input,
        body.glass-mode .modal-content .form-select {
            background: rgba(255, 255, 255, 0.12) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: white !important;
        }
        body.glass-mode .modal-content .form-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        /* 确保下拉选项在通透模式下仍然可见 (使用深色背景) */
        body.glass-mode .modal-content .form-select option {
            background-color: #333;
            color: white;
        }
        
        /* 预设时间按钮通透模式 */
        body.glass-mode .modal-content .time-preset {
            background: rgba(255, 255, 255, 0.15) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: white !important;
        }
        body.glass-mode .modal-content .time-preset:hover {
            background: rgba(255, 255, 255, 0.25) !important;
        }
        
        /* 推荐标签通透模式 */
        body.glass-mode .recommendation-item {
            background: rgba(255, 255, 255, 0.15) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: white !important;
        }

        /* [v6.3.0] 习惯奖励卡片通透模式 (Habit Reward Card Glass Mode) */
        body.glass-mode .habit-reward-card {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.25) !important;
        }
        body.glass-mode .habit-reward-card .form-label-small {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        /* [v6.4.0] 滑块样式适配通透模式 */
        body.glass-mode .habit-reward-card .reward-type-switch button {
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: rgba(255, 255, 255, 0.9) !important;
            background: transparent !important;
        }
        body.glass-mode .habit-reward-card .reward-type-switch button.active {
            background: rgba(var(--color-primary-rgb), 0.7) !important;
            border-color: rgba(var(--color-primary-rgb), 0.7) !important;
            color: white !important;
        }
        /* 复合输入框处理 */
        body.glass-mode .habit-reward-card .input-with-suffix {
            background: rgba(255, 255, 255, 0.15) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
        }
        body.glass-mode .habit-reward-card .input-with-suffix .form-input {
            background: transparent !important; /* 避免双重背景 */
        }
        body.glass-mode .habit-reward-card .input-with-suffix .input-suffix-text {
            background: rgba(255, 255, 255, 0.1) !important;
            color: rgba(255, 255, 255, 0.9) !important;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
        }
        /* 覆盖内联样式的限制容器 */
        body.glass-mode .habit-reward-card .reward-limit-container {
            background: rgba(255, 255, 255, 0.08) !important;
            color: white !important;
        }

        
        /* 图表容器通透模式 - 无背景 */
        body.glass-mode .chart-container {
            background: none !important;
            border: 1px solid rgba(255, 255, 255, calc(0.2 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.3 * var(--glass-opacity-scale)));
            box-shadow: none;
        }
        [data-theme="dark"] body.glass-mode .chart-container {
            border: 1px solid rgba(255, 255, 255, calc(0.1 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.15 * var(--glass-opacity-scale)));
        }
        body.glass-mode .chart-container .chart-title {
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        
        /* 报告区域通透模式 - 15%→8% (略高于其他卡片) */
        body.glass-mode .report-section {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.08 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.02 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.5 * var(--glass-opacity-scale)));
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
            backdrop-filter: blur(calc(20px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(20px * var(--glass-blur-scale)));
        }
        [data-theme="dark"] body.glass-mode .report-section {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.06 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.01 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.12 * var(--glass-opacity-scale)));
            border-top: 1px solid rgba(255, 255, 255, calc(0.2 * var(--glass-opacity-scale)));
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
        }
        /* [v6.2.1] 图表分析容器通透模式 - 移除额外背景层 */
        body.glass-mode #interactiveAnalysisWrapper {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        /* 报告区域文字通透模式 - 全面覆盖确保任意背景下可读性 */
        body.glass-mode .report-section .section-title,
        body.glass-mode .report-section .report-title,
        body.glass-mode .report-section h2,
        body.glass-mode .report-section h3 {
            color: white !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .report-section .section-subtitle,
        body.glass-mode .report-section .text-muted,
        body.glass-mode .report-section .heatmap-legend,
        body.glass-mode .report-section .heatmap-weekdays span {
            color: rgba(255, 255, 255, 0.75) !important;
        }
        /* 报告区域问号按钮通透模式 */
        body.glass-mode .report-section .info-button {
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: rgba(255, 255, 255, 0.8) !important;
        }
        /* 全局标题问号按钮通透模式提亮（任务标题、设置标题等） */
        body.glass-mode .section-title-group .info-button,
        body.glass-mode .settings-title .info-button,
        body.glass-mode .screen-time-shared-header .info-button {
            border-color: rgba(255, 255, 255, 0.35) !important;
            color: rgba(255, 255, 255, 0.9) !important;
            background: rgba(255, 255, 255, 0.08) !important;
        }
        /* 热力图单元格需要保持原色，不改变 */
        /* KPI 卡片文字 */
        body.glass-mode .kpi-grid .kpi-value,
        body.glass-mode .kpi-card .kpi-value {
            color: white !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .kpi-grid .kpi-label,
        body.glass-mode .kpi-card .kpi-label {
            color: rgba(255, 255, 255, 0.8) !important;
        }
        /* 图表区域文字 */
        body.glass-mode .chart-container .chart-title,
        body.glass-mode .report-section .chart-title {
            color: white !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        /* 排行榜/柱状图文字 */
        body.glass-mode .leaderboard-label {
            color: rgba(255, 255, 255, 0.85) !important;
        }
        /* 表格文字 */
        body.glass-mode .report-section table th,
        body.glass-mode .report-section table td {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        /* [v6.2.5] 通透模式下详细数据表格内的正负值强制白色，避免红绿在深色玻璃背景上突兀 */
        body.glass-mode .report-section table .text-positive,
        body.glass-mode .report-section table .text-negative {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        /* 任务详情弹窗中的文字 */
        body.glass-mode #dayDetailModal .modal-content,
        body.glass-mode #categoryDetailModal .modal-content {
            color: white;
        }
        /* [v6.0.0] 活动日历详情弹窗通透模式 */
        body.glass-mode #dayDetailModal .day-detail-summary {
            border-bottom-color: rgba(255, 255, 255, 0.2) !important;
        }
        body.glass-mode #dayDetailModal .day-detail-net {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode #dayDetailModal .day-detail-net.positive {
            color: #90EE90 !important;
        }
        body.glass-mode #dayDetailModal .day-detail-net.negative {
            color: #FFB6C1 !important;
        }
        body.glass-mode #dayDetailModal .day-detail-stats {
            color: rgba(255, 255, 255, 0.85) !important;
        }
        body.glass-mode #dayDetailModal .day-detail-stats .positive {
            color: #90EE90 !important;
        }
        body.glass-mode #dayDetailModal .day-detail-stats .negative {
            color: #FFB6C1 !important;
        }
        /* 活动日历详情弹窗 - 历史记录项 */
        body.glass-mode #dayDetailModal .history-item {
            border-bottom-color: rgba(255, 255, 255, 0.15) !important;
        }
        body.glass-mode #dayDetailModal .history-description {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode #dayDetailModal .history-description .desc-line-2 {
            color: rgba(255, 255, 255, 0.75) !important;
        }
        body.glass-mode #dayDetailModal .history-time {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        body.glass-mode #dayDetailModal .history-amount {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode #dayDetailModal .history-amount.positive {
            color: #90EE90 !important;
        }
        body.glass-mode #dayDetailModal .history-amount.negative {
            color: #FFB6C1 !important;
        }
        body.glass-mode #dayDetailModal .empty-message {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        /* [v6.0.0] 弹窗头部通透模式 - 移除白色背景 */
        body.glass-mode .modal-header {
            background: transparent !important;
            border-bottom-color: rgba(255, 255, 255, 0.2) !important;
        }
        body.glass-mode #dayDetailModal .modal-header {
            background: transparent !important;
            border-bottom-color: rgba(255, 255, 255, 0.2) !important;
        }
        /* 时间流图标题组通透模式 */
        body.glass-mode .flow-detail-title-group {
            background: transparent !important;
        }
        body.glass-mode .flow-detail-title-group .info-button {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: white !important;
        }
        /* 时间流图日期切换区域通透模式 */
        body.glass-mode .flow-detail-date {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        /* 弹窗关闭按钮通透模式 */
        body.glass-mode .close-btn {
            color: rgba(255, 255, 255, 0.8) !important;
        }
        body.glass-mode .close-btn:hover {
            color: white !important;
        }
        
        /* [v6.0.0] 时间流图通透模式 */
        body.glass-mode .schedule-grid,
        body.glass-mode .multi-day-flow-grid {
            background: rgba(255, 255, 255, 0.08) !important;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        [data-theme="dark"] body.glass-mode .schedule-grid,
        [data-theme="dark"] body.glass-mode .multi-day-flow-grid {
            background: rgba(255, 255, 255, 0.05) !important;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* 时间流图任务条块通透模式 */
        body.glass-mode .task-block {
            background: rgba(var(--cat-color-rgb, 100, 100, 100), 0.25) !important;
            backdrop-filter: blur(calc(8px * var(--glass-blur-scale)));
            -webkit-backdrop-filter: blur(calc(8px * var(--glass-blur-scale)));
            border-left: 4px solid var(--cat-color);
        }
        body.glass-mode .task-block-name {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .task-block-duration,
        body.glass-mode .task-block-time,
        body.glass-mode .task-block-time-top,
        body.glass-mode .task-block-time-bottom {
            color: rgba(255, 255, 255, 0.8) !important;
        }
        /* 时间流图小时刻度通透模式 */
        body.glass-mode .hour-line {
            border-bottom-color: rgba(255, 255, 255, 0.15) !important;
        }
        body.glass-mode .hour-line span {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        /* 时间流图头部通透模式 */
        body.glass-mode .flow-detail-title,
        body.glass-mode .flow-detail-date {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode .schedule-stats {
            color: rgba(255, 255, 255, 0.8) !important;
        }
        body.glass-mode .schedule-stats .earned {
            color: #90EE90 !important;
        }
        body.glass-mode .schedule-stats .spent {
            color: #FFB6C1 !important;
        }
        /* 时间流图导航按钮通透模式 */
        body.glass-mode .flow-date-nav button {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: white !important;
        }
        body.glass-mode .flow-date-nav button:disabled {
            opacity: 0.3;
        }
        body.glass-mode #flowDateLabel {
            color: white !important;
        }
        
        /* [v6.0.0] 任务历史弹窗通透模式 */
        body.glass-mode #historyModal .history-combined-container {
            background: transparent !important;
        }
        body.glass-mode #historyModal .history-list-header {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            border-bottom-color: rgba(255, 255, 255, 0.2) !important;
        }
        body.glass-mode #historyModal .history-item {
            border-bottom-color: rgba(255, 255, 255, 0.15) !important;
        }
        body.glass-mode #historyModal .history-description {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode #historyModal .history-description .desc-line-2 {
            color: rgba(255, 255, 255, 0.75) !important;
        }
        body.glass-mode #historyModal .history-time {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        body.glass-mode #historyModal .history-amount {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode #historyModal .history-amount.positive {
            color: #90EE90 !important;
        }
        body.glass-mode #historyModal .history-amount.negative {
            color: #FFB6C1 !important;
        }
        body.glass-mode #historyModal .undo-btn {
            background: rgba(255, 255, 255, 0.15) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: white !important;
        }
        /* 任务历史弹窗 - 活动日历通透模式 */
        body.glass-mode #historyModal .history-calendar-section .heatmap-grid {
            background: transparent !important;
        }
        body.glass-mode #historyModal .heatmap-weekdays span {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        body.glass-mode #historyModal .heatmap-day-content {
            border-color: rgba(255, 255, 255, 0.2) !important;
        }
        body.glass-mode #historyModal .heatmap-legend {
            color: rgba(255, 255, 255, 0.75) !important;
        }
        
        /* [v6.0.0] 活动日历弹窗/报告页通透模式 */
        body.glass-mode .heatmap-tooltip {
            background: rgba(30, 30, 30, 0.9) !important;
            backdrop-filter: blur(calc(15px * max(var(--glass-blur-scale), 0.2)));
            -webkit-backdrop-filter: blur(calc(15px * max(var(--glass-blur-scale), 0.2)));
            color: white !important;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        body.glass-mode .heatmap-day-content {
            border-color: rgba(255, 255, 255, 0.15) !important;
        }
        
        /* [v6.0.0] 屏幕时间弹窗通透模式 */
        body.glass-mode #whitelistModal .modal-content {
            background: linear-gradient(135deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.06) 100%) !important;
        }
        body.glass-mode #whitelistModal .whitelist-modal-content {
            background: transparent !important;
        }
        body.glass-mode #whitelistModal .app-item {
            background: rgba(255, 255, 255, 0.08) !important;
            border-color: rgba(255, 255, 255, 0.2) !important;
        }
        body.glass-mode #whitelistModal .app-item:hover {
            background: rgba(255, 255, 255, 0.12) !important;
        }
        body.glass-mode #whitelistModal .app-item.selected {
            background: rgba(var(--color-primary-rgb), 0.3) !important;
            border-color: rgba(var(--color-primary-rgb), 0.5) !important;
        }
        body.glass-mode #whitelistModal .app-name {
            color: white !important;
        }
        body.glass-mode #whitelistModal .app-package {
            color: rgba(255, 255, 255, 0.6) !important;
        }
        body.glass-mode #whitelistModal .search-input {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        body.glass-mode #whitelistModal .search-input::placeholder {
            color: rgba(255, 255, 255, 0.5) !important;
        }
        
        /* [v6.0.0] 屏幕时间说明弹窗通透模式 */
        body.glass-mode #screenTimeInfoModal .modal-content p,
        body.glass-mode #screenTimeInfoModal .modal-content div,
        body.glass-mode #screenTimeInfoModal .modal-content > div,
        body.glass-mode #screenTimeInfoModal .modal-content > div > div,
        body.glass-mode #screenTimeInfoModal .modal-content > div > p {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        body.glass-mode #screenTimeInfoModal .modal-content strong {
            color: white !important;
        }
        
        /* [v6.0.0] 活动日历说明弹窗通透模式 */
        body.glass-mode #activityHeatmapInfoModal .modal-content p,
        body.glass-mode #activityHeatmapInfoModal .modal-content div,
        body.glass-mode #activityHeatmapInfoModal .modal-content > div,
        body.glass-mode #activityHeatmapInfoModal .modal-content > div > div,
        body.glass-mode #activityHeatmapInfoModal .modal-content > div > p {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        body.glass-mode #activityHeatmapInfoModal .modal-content strong {
            color: white !important;
        }
        
        /* [v6.0.0] 时间仪表盘说明弹窗通透模式 */
        body.glass-mode #analysisDashboardInfoModal .modal-content p,
        body.glass-mode #analysisDashboardInfoModal .modal-content div,
        body.glass-mode #analysisDashboardInfoModal .modal-content > div,
        body.glass-mode #analysisDashboardInfoModal .modal-content > div > div {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        body.glass-mode #analysisDashboardInfoModal .modal-content strong {
            color: white !important;
        }
        
        /* [v6.0.0] 通用信息弹窗通透模式 */
        body.glass-mode #generalInfoModal .modal-content,
        body.glass-mode #generalInfoModal #generalInfoModalContent,
        body.glass-mode #generalInfoModal p,
        body.glass-mode #generalInfoModal div {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        body.glass-mode #generalInfoModal strong {
            color: white !important;
        }
        
        /* [v6.0.0] 确认弹窗通透模式 */
        body.glass-mode #confirmModal .modal-content,
        body.glass-mode #confirmModal #confirmModalContent {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        
        /* [v6.0.0] 所有弹窗内文字通透模式覆盖 - 更强的选择器 */
        body.glass-mode .modal.show .modal-content div[style],
        body.glass-mode .modal.show .modal-content p[style],
        body.glass-mode .modal.show .modal-content span[style] {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        
        /* 统计卡片通透模式 */
        body.glass-mode .stats-grid .stat-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.05) 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        [data-theme="dark"] body.glass-mode .stats-grid .stat-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }
        body.glass-mode .stats-grid .stat-value {
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .stats-grid .stat-label {
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* 输入框通透模式 - 8%→3% */
        body.glass-mode input[type="text"],
        body.glass-mode input[type="number"],
        body.glass-mode input[type="time"],
        body.glass-mode input[type="date"],
        body.glass-mode input[type="password"],
        body.glass-mode input[type="email"],
        body.glass-mode textarea,
        body.glass-mode select {
            background: rgba(255, 255, 255, 0.08) !important;
            border: 1px solid rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        body.glass-mode input::placeholder,
        body.glass-mode textarea::placeholder {
            color: rgba(255, 255, 255, 0.5) !important;
        }
        [data-theme="dark"] body.glass-mode input[type="text"],
        [data-theme="dark"] body.glass-mode input[type="number"],
        [data-theme="dark"] body.glass-mode input[type="time"],
        [data-theme="dark"] body.glass-mode input[type="date"],
        [data-theme="dark"] body.glass-mode input[type="password"],
        [data-theme="dark"] body.glass-mode input[type="email"],
        [data-theme="dark"] body.glass-mode textarea,
        [data-theme="dark"] body.glass-mode select {
            background: rgba(255, 255, 255, 0.05) !important;
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
        }
        
        /* 按钮通透模式 - 排除任务卡片按钮、FAB按钮、mode-switch按钮、同步诊断按钮、冲突对话框按钮 */
        body.glass-mode .btn:not(.task-btn):not(.fab):not(.sync-btn):not(.conflict-btn),
        body.glass-mode button:not(.tab-button):not(.style-btn):not(.theme-option):not(.accent-option):not(.bg-option):not(.task-btn):not(.fab):not(.close-btn):not(.more-btn):not(.info-button):not(.view-switch-btn):not(.mode-switch button):not(.reward-type-switch button):not(.sync-btn):not(.conflict-btn) { /* [v6.4.0] 添加 mode-switch 和 reward-type-switch 到排除列表 [v6.4.1] 添加 sync-btn 和 conflict-btn */
            background: rgba(255, 255, 255, 0.15) !important;
            border: 1px solid rgba(255, 255, 255, 0.25) !important;
            color: white !important;
        }
        body.glass-mode .btn:not(.task-btn):not(.fab):not(.sync-btn):not(.conflict-btn):hover,
        body.glass-mode button:not(.tab-button):not(.style-btn):not(.theme-option):not(.accent-option):not(.bg-option):not(.task-btn):not(.fab):not(.close-btn):not(.more-btn):not(.info-button):not(.view-switch-btn):not(.mode-switch button):not(.reward-type-switch button):not(.sync-btn):not(.conflict-btn):hover {
            background: rgba(255, 255, 255, 0.25) !important;
        }
        body.glass-mode .btn.primary:not(.task-btn):not(.fab),
        body.glass-mode button.primary:not(.task-btn):not(.fab) {
            background: rgba(var(--color-primary-rgb), 0.6) !important;
        }
        body.glass-mode .btn.success:not(.task-btn):not(.fab),
        body.glass-mode button.success:not(.task-btn):not(.fab) {
            background: rgba(76, 175, 80, 0.6) !important;
        }
        body.glass-mode .btn.danger:not(.task-btn):not(.fab),
        body.glass-mode button.danger:not(.task-btn):not(.fab) {
            background: rgba(244, 67, 54, 0.6) !important;
        }
        
        /* [v6.2.0] 主题/样式选择器通透模式 - 已移除，滑块样式统一在后面定义 */
        
        /* 热力图/日历通透模式 */
        body.glass-mode .heatmap-container {
            background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: var(--space-md);
        }
        body.glass-mode #heatmapMonthLabel,
        body.glass-mode .heatmap-day-label,
        body.glass-mode .heatmap-weekdays span {
            color: rgba(255, 255, 255, 0.75) !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        body.glass-mode .heatmap-legend {
            color: rgba(255, 255, 255, 0.75) !important;
        }
        /* 活动日历日期格子通透模式 - 无数据的空白格子更透明 */
        body.glass-mode .heatmap-day-content:not([class*="net-"]):not([class*="task-cal-"]) {
            background-color: rgba(255, 255, 255, 0.08) !important;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
        }
        /* 有数据的格子 - 统一80%不透明度 */
        body.glass-mode .heatmap-day-content.net-surplus-1 { background-color: rgba(155, 233, 168, 0.8) !important; }
        body.glass-mode .heatmap-day-content.net-surplus-2 { background-color: rgba(64, 196, 99, 0.8) !important; }
        body.glass-mode .heatmap-day-content.net-surplus-3 { background-color: rgba(33, 110, 57, 0.8) !important; color: white; }
        body.glass-mode .heatmap-day-content.net-deficit-1 { background-color: rgba(239, 154, 154, 0.8) !important; }
        body.glass-mode .heatmap-day-content.net-deficit-2 { background-color: rgba(239, 83, 80, 0.8) !important; }
        body.glass-mode .heatmap-day-content.net-deficit-3 { background-color: rgba(211, 47, 47, 0.8) !important; color: white; }
        body.glass-mode .heatmap-day-content.task-cal-green-1 { background-color: rgba(200, 230, 201, 0.8) !important; color: #333; }
        body.glass-mode .heatmap-day-content.task-cal-green-2 { background-color: rgba(102, 187, 106, 0.8) !important; color: white; }
        body.glass-mode .heatmap-day-content.task-cal-green-3 { background-color: rgba(56, 142, 60, 0.8) !important; color: white; }
        body.glass-mode .heatmap-day-content.task-cal-red-1 { background-color: rgba(239, 154, 154, 0.8) !important; color: #333; }
        body.glass-mode .heatmap-day-content.task-cal-red-2 { background-color: rgba(239, 83, 80, 0.8) !important; color: white; }
        body.glass-mode .heatmap-day-content.task-cal-red-3 { background-color: rgba(211, 47, 47, 0.8) !important; color: white; }
        /* 所有有数据的格子增加玻璃质感边框（无毛玻璃，避免性能问题） */
        body.glass-mode .heatmap-day-content[class*="net-"],
        body.glass-mode .heatmap-day-content[class*="task-cal-"] {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
        }
        /* 活动日历导航按钮和月份标签通透模式 */
        body.glass-mode .heatmap-nav button {
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.25) !important;
            color: rgba(255, 255, 255, 0.85) !important;
        }
        body.glass-mode #heatmapMonthLabel {
            color: white !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        /* 活动日历图例通透模式 */
        body.glass-mode .heatmap-legend .legend-box {
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        /* 趋势演变图通透模式 */
        body.glass-mode .trend-day {
            background: rgba(255, 255, 255, 0.15) !important;
        }
        /* 趋势图柱状条通透模式 - 增加玻璃质感 */
        body.glass-mode .trend-segment {
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            border-right: 1px solid rgba(255, 255, 255, 0.15);
        }
        body.glass-mode .trend-date-label {
            color: rgba(255, 255, 255, 0.75) !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        /* 图表图例通透模式 - 增加玻璃质感 */
        body.glass-mode .chart-legend,
        body.glass-mode .chart-legend .legend-label {
            color: rgba(255, 255, 255, 0.85) !important;
        }
        body.glass-mode .chart-legend .legend-color-box {
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        body.glass-mode .pie-legend-item {
            color: rgba(255, 255, 255, 0.85) !important;
        }
        body.glass-mode .pie-legend-color-box {
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        /* 饼图通透模式 - 重新设计 */
        /* 隐藏底层 conic-gradient，只用 SVG 层显示扇形，避免长按时出现双层轮廓 */
        body.glass-mode .pie-chart {
            background: transparent !important;
        }
        /* SVG 扇形层 - 增强玻璃质感 */
        body.glass-mode .pie-highlight-layer {
            filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.2));
        }
        body.glass-mode .pie-chart-container svg path.pie-highlight-slice {
            stroke: rgba(255, 255, 255, 0.35);
            stroke-width: 0.75;
            /* 扇形颜色会在 JS 中设置，这里添加透明度 */
            opacity: 0.88;
        }
        /* 饼图中心区域 - 白色半透明玻璃效果 */
        body.glass-mode .pie-chart::before {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.15) 100%) !important;
            backdrop-filter: blur(calc(12px * max(var(--glass-blur-scale), 0.2)));
            -webkit-backdrop-filter: blur(calc(12px * max(var(--glass-blur-scale), 0.2)));
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
        }
        body.glass-mode .pie-chart-center {
            background: transparent !important;
        }
        body.glass-mode .pie-center-title {
            color: rgba(255, 255, 255, 0.85) !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
        }
        body.glass-mode .pie-center-value {
            color: white !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        /* 饼图扇区标签通透模式 */
        body.glass-mode .pie-slice-label {
            color: white !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
        }
        body.glass-mode .pie-slice-label .time-value {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        
        /* 趋势提示框/饼图提示框通透模式 */
        body.glass-mode .trend-tooltip,
        body.glass-mode .pie-tooltip {
            background: linear-gradient(
                135deg,
                rgba(255,255,255, calc(0.22 * max(var(--glass-opacity-scale), 0.2))) 0%,
                rgba(255,255,255, calc(0.15 * max(var(--glass-opacity-scale), 0.2))) 100%
            ) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * max(var(--glass-opacity-scale), 0.2)));
            backdrop-filter: blur(calc(20px * max(var(--glass-blur-scale), 0.2)));
            -webkit-backdrop-filter: blur(calc(20px * max(var(--glass-blur-scale), 0.2)));
            color: white !important;
        }
        body.glass-mode .trend-tooltip *,
        body.glass-mode .pie-tooltip * {
            color: white !important;
        }
        
        /* 下拉菜单通透模式 - 仅应用于非自定义下拉选择器（如任务卡片菜单等） */
        /* [v6.4.6] 增强模糊效果：基础值从20px提升到30px，确保遮挡下方内容 */
        body.glass-mode .task-card-menu,
        body.glass-mode .context-menu {
            background: linear-gradient(
                135deg,
                rgba(255,255,255, calc(0.22 * max(var(--glass-opacity-scale), 0.2))) 0%,
                rgba(255,255,255, calc(0.15 * max(var(--glass-opacity-scale), 0.2))) 100%
            ) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * max(var(--glass-opacity-scale), 0.2)));
            backdrop-filter: blur(calc(30px * max(var(--glass-blur-scale), 0.3)));
            -webkit-backdrop-filter: blur(calc(30px * max(var(--glass-blur-scale), 0.3)));
        }
        body.glass-mode .dropdown-item,
        body.glass-mode .context-menu-item {
            color: white !important;
        }
        body.glass-mode .dropdown-item:hover,
        body.glass-mode .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* 工具提示通透模式 */
        body.glass-mode .tooltip,
        body.glass-mode .heatmap-tooltip {
            background: rgba(255, 255, 255, calc(0.2 * max(var(--glass-opacity-scale), 0.2))) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.3 * max(var(--glass-opacity-scale), 0.2)));
            backdrop-filter: blur(calc(15px * max(var(--glass-blur-scale), 0.2)));
            -webkit-backdrop-filter: blur(calc(15px * max(var(--glass-blur-scale), 0.2)));
            color: white !important;
        }
        
        /* 分割线和边框通透模式 */
        body.glass-mode hr,
        body.glass-mode .divider {
            border-color: rgba(255, 255, 255, 0.2) !important;
        }
        
        /* 开关/Toggle通透模式 */
        body.glass-mode .switch-track {
            background: rgba(255, 255, 255, 0.2) !important;
        }
        body.glass-mode .switch-track.active {
            background: rgba(var(--color-primary-rgb), 0.6) !important;
        }
        
        /* 徽章通透模式 */
        body.glass-mode .badge {
            background: rgba(255, 255, 255, 0.2) !important;
            color: white !important;
        }
        
        /* 报告页面KPI卡片通透模式 */
        body.glass-mode .kpi-card {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.12 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.05 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.25 * var(--glass-opacity-scale)));
        }
        [data-theme="dark"] body.glass-mode .kpi-card {
            background: linear-gradient(135deg, rgba(255,255,255, calc(0.08 * var(--glass-opacity-scale))) 0%, rgba(255,255,255, calc(0.03 * var(--glass-opacity-scale))) 100%) !important;
            border: 1px solid rgba(255, 255, 255, calc(0.12 * var(--glass-opacity-scale)));
        }
        body.glass-mode .kpi-card .kpi-value {
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        body.glass-mode .kpi-card .kpi-label {
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* 排行榜通透模式 */
        body.glass-mode .leaderboard-label {
            color: rgba(255, 255, 255, 0.85);
        }
        body.glass-mode .leaderboard-bar-wrapper {
            background: rgba(255, 255, 255, calc(0.15 * var(--glass-opacity-scale))) !important;
        }
        
        /* 表格通透模式 */
        body.glass-mode table {
            background: transparent !important;
        }
        body.glass-mode th {
            background: rgba(255, 255, 255, calc(0.1 * var(--glass-opacity-scale))) !important;
            color: white !important;
            border-color: rgba(255, 255, 255, calc(0.15 * var(--glass-opacity-scale))) !important;
        }
        body.glass-mode td {
            background: rgba(255, 255, 255, calc(0.05 * var(--glass-opacity-scale))) !important;
            color: rgba(255, 255, 255, 0.9) !important;
            border-color: rgba(255, 255, 255, calc(0.1 * var(--glass-opacity-scale))) !important;
        }
        body.glass-mode tr:hover td {
            background: rgba(255, 255, 255, calc(0.12 * var(--glass-opacity-scale))) !important;
        }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 2000; opacity: 0; transition: opacity 0.25s ease; }
        .modal.show { display: flex; align-items: center; justify-content: center; opacity: 1; }
        .modal-content { background: var(--input-bg); border-radius: 15px; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; padding: var(--space-xl); overscroll-behavior: contain; }
        
        /* [v5.10.0] 普通点击弹窗动画 - 无 opacity，避免亮度闪烁 */
        @keyframes modalPopIn {
            0% { transform: scale(0.92); }
            60% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        /* 排除长按展开弹窗（.from-tooltip / .from-pie 使用 modalExpandIn） */
        .modal.show:not(.from-tooltip):not(.from-pie) .modal-content {
            animation: modalPopIn 0.25s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        /* 从日历/饼图长按展开的弹窗动画 */
        @keyframes modalExpandIn {
            0% { opacity: 0; transform: scale(0.3); }
            100% { opacity: 1; transform: scale(1); }
        }
        #dayDetailModal.from-tooltip .modal-content {
            animation: modalExpandIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        #dayDetailModal .modal-content { 
            overflow: hidden;
            max-height: 72vh;
            display: flex;
            flex-direction: column;
        }
        #dayDetailModal .modal-header {
            flex-shrink: 0;
            position: sticky;
            top: 0;
            background: var(--input-bg);
            z-index: 10;
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--border-color);
        }
        /* [v6.3.3] 时间流图模式下消除头部间距，使图表紧贴分割线 */
        #dayDetailModal.flow-mode .modal-header {
            margin-bottom: 0;
            /* 保留固定头部边框，使其作为视觉分隔 */
            border-bottom: 1px solid var(--border-color);
        }
        #dayDetailModal.flow-mode .multi-day-flow-grid {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }
        #dayDetailModal .modal-title {
            flex: 1;
        }
        #dayDetailContent {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            overscroll-behavior: contain;
        }
        #generalInfoModal .modal-content {
            max-height: 72vh;
            overflow-y: auto;
        }
        
        /* [v4.5.1] 修复: 恢复历史弹窗的默认滚动条 (移除 v4.5.0 的错误覆盖) */
        /* #historyModal .modal-content {
            max-height: none;
            overflow-y: visible;
        }
        */

        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-xl); }
        .modal-title { font-size: 1.2rem; font-weight: 600; color: var(--text-color); }
        .close-btn { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-color-light); padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; }

        .form-group { margin-bottom: var(--space-lg); }
        .form-label { display: block; margin-bottom: var(--space-sm); font-weight: 500; color: var(--text-color); }
        .form-input, .form-select { width: 100%; padding: var(--space-md); border: 2px solid var(--border-color); border-radius: 8px; font-size: 1rem; background-color: var(--input-bg); color: var(--text-color); }
        .form-input:focus, .form-select:focus { outline: none; border-color: var(--color-primary); }
        .form-input.error, .form-select.error { border-color: var(--color-negative); }
        .error-message { color: var(--color-negative); font-size: 0.85rem; margin-top: var(--space-sm); display: none; }
        .error-message.show { display: block; }
        .hidden { display: none !important; }

        .time-presets { display: flex; gap: var(--space-sm); margin-top: var(--space-sm); flex-wrap: wrap; }
        .time-preset { padding: 6px 12px; background: var(--btn-secondary-bg); border: 1px solid var(--btn-secondary-border); border-radius: 6px; font-size: 0.8rem; cursor: pointer; }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .time-preset:hover { background: var(--color-primary); color: white; border-color: var(--color-primary); }
        }
        .time-preset:active { background: var(--color-primary); color: white; border-color: var(--color-primary); }
        .recommendations { display: flex; gap: var(--space-sm); margin-top: var(--space-sm); flex-wrap: wrap; }
        .recommendation-item { padding: 4px 8px; background: #e3f2fd; border: 1px solid var(--color-primary); border-radius: 12px; font-size: 0.8rem; cursor: pointer; color: var(--color-primary); }
        @media (hover: hover) and (pointer: fine) {
            .recommendation-item:hover { background: var(--color-primary); color: white; }
        }
        .recommendation-item:active { background: var(--color-primary); color: white; }
        [data-theme="dark"] .recommendation-item { background: rgba(var(--color-primary-rgb), 0.2); border-color: var(--color-primary); }

        .color-selector { display: grid; grid-template-columns: repeat(8, 1fr); gap: var(--space-sm); }
        .color-swatch { width: 100%; padding-bottom: 100%; border-radius: 50%; cursor: pointer; position: relative; border: 2px solid transparent; }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .color-swatch:hover { transform: scale(1.1); }
        }
        .color-swatch:active { transform: scale(0.95); }
        .color-swatch.selected { border-color: var(--color-primary); }
        .color-swatch.disabled { cursor: not-allowed; opacity: 0.3; }
        .color-swatch .checkmark { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1rem; }
        .color-swatch.selected .checkmark { display: block; }

        .form-buttons { display: flex; gap: var(--space-md); margin-top: var(--space-xxl); justify-content: flex-end; }
        .form-buttons .btn { flex: 0 0 auto; white-space: nowrap; }
        .form-buttons .btn-secondary:first-child { margin-right: auto; }
        .btn { padding: var(--space-md); border: none; border-radius: 8px; font-size: 1rem; font-weight: 500; cursor: pointer; }
        .btn-primary { background: var(--color-primary); color: white; } .btn-secondary { background: var(--btn-secondary-bg); color: var(--btn-secondary-text); } .btn-danger { background: var(--color-negative); color: white; }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .btn:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); }
        }
        .btn:active { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); }
        
        .habit-settings { border: 2px solid var(--color-primary); border-radius: 8px; padding: var(--space-lg); margin-top: var(--space-md); margin-bottom: var(--space-xl); background-color: rgba(var(--color-primary-rgb), 0.05); }
        [data-theme="dark"] .habit-settings { background-color: rgba(var(--color-primary-rgb), 0.1); }
        .habit-settings-title { font-size: 1rem; font-weight: 600; color: var(--color-primary); margin-bottom: var(--space-xl); }
        /* [v3.18.0] Increased grid columns to accommodate new input fields */
        .habit-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px var(--space-lg); margin-bottom: 24px; }
        /* [v4.8.3] 移除网格内表单项的默认下边距，防止间距叠加 */
        .habit-grid .form-group { margin-bottom: 0 !important; }
        .habit-reward-rule { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: var(--space-md); align-items: center; padding: var(--space-md); border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: var(--space-md); }
        .habit-reward-rule .form-input, .habit-reward-rule .form-select { padding: var(--space-sm); font-size: 0.9rem; }
        .remove-reward-btn { background: var(--color-negative); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-weight: bold; }

        .input-group { display: flex; gap: var(--space-sm); align-items: center; }
        .input-group input[type="number"] { width: 60px; text-align: right; }
        .input-group span { color: var(--text-color-light); font-size: 0.9rem; }

        .mode-switch { display: flex; justify-content: center; }
        .mode-switch button { flex: 1; padding: 8px; border: 1px solid var(--border-color); background: none; color: var(--text-color); cursor: pointer; font-size: 0.9rem; }
        .mode-switch button:first-child { border-radius: 6px 0 0 6px; border-right: none; }
        .mode-switch button:last-child { border-radius: 0 6px 6px 0; }
        .mode-switch button.active { background: var(--color-primary); color: white; border-color: var(--color-primary); }
        
        /* [v6.5.0] 习惯周期滑块样式 - 4按钮布局 */
        .habit-period-switch { display: flex; justify-content: center; gap: 0; }
        .habit-period-switch button { 
            flex: 1; 
            padding: 8px 12px; 
            border: 1px solid var(--border-color); 
            background: var(--card-bg); 
            color: var(--text-color); 
            cursor: pointer; 
            font-size: 0.85rem; 
            transition: all 0.2s ease;
            border-right: none;
        }
        .habit-period-switch button:first-child { border-radius: 6px 0 0 6px; }
        .habit-period-switch button:last-child { border-radius: 0 6px 6px 0; border-right: 1px solid var(--border-color); }
        .habit-period-switch button:not(:first-child):not(:last-child) { border-radius: 0; }
        .habit-period-switch button.active { 
            background: var(--color-primary); 
            color: white; 
            border-color: var(--color-primary); 
            box-shadow: 0 2px 8px rgba(var(--color-primary-rgb), 0.3);
        }
        .habit-period-switch button:hover:not(.active) { background: rgba(var(--color-primary-rgb), 0.1); }
        
        /* [v6.4.0] 通透模式下的 mode-switch 通用样式 - 使用双重body选择器增加特异性 */
        body.glass-mode body.glass-mode .mode-switch button,
        body.glass-mode .modal-content .mode-switch button,
        body.glass-mode .habit-reward-card .mode-switch button,
        body.glass-mode .habit-reward-card .reward-type-switch button,
        body.glass-mode .habit-period-switch button {
            border-color: rgba(255, 255, 255, 0.3) !important;
            color: rgba(255, 255, 255, 0.9) !important;
            background: transparent !important;
        }
        body.glass-mode body.glass-mode .mode-switch button.active,
        body.glass-mode .modal-content .mode-switch button.active,
        body.glass-mode .habit-reward-card .mode-switch button.active,
        body.glass-mode .habit-reward-card .reward-type-switch button.active,
        body.glass-mode .habit-period-switch button.active {
            background: var(--color-primary) !important;
            border-color: var(--color-primary) !important;
            color: white !important;
        }

        /* [v3.11.0] Backdate Modal Styles */
        #backdateModal .input-group { margin-bottom: var(--space-lg); }
        #backdateModal .mode-switch { margin-bottom: var(--space-lg); }
        
        /* [v5.5.0] 智能检测补录样式 */
        .smart-detect-section { background: var(--color-primary-light); border-radius: 8px; padding: 12px; margin-bottom: 16px; }
        .smart-detect-header { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-weight: 600; color: var(--color-primary); }
        .smart-detect-controls { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .smart-detect-controls select { padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-color); font-size: 0.9rem; }
        .smart-detect-controls .btn-detect { padding: 6px 12px; font-size: 0.85rem; }
        .detect-results { margin-top: 12px; max-height: 200px; overflow-y: auto; }
        .detect-result-item { display: flex; align-items: flex-start; gap: 8px; padding: 10px; background: var(--card-bg); border-radius: 6px; margin-bottom: 6px; font-size: 0.85rem; }
        .detect-result-item input[type="checkbox"] { margin-top: 3px; flex-shrink: 0; }
        .detect-result-item.no-diff { opacity: 0.6; }
        .detect-result-info { flex: 1; }
        .detect-result-date { font-weight: 600; margin-bottom: 2px; }
        .detect-result-detail { color: var(--text-color-light); font-size: 0.8rem; }
        .detect-result-diff { font-weight: 600; white-space: nowrap; }
        .detect-result-diff.positive { color: var(--color-positive); }
        .detect-result-diff.negative { color: #e74c3c; }
        .detect-summary { margin-top: 10px; padding: 10px; background: var(--card-bg); border-radius: 6px; display: flex; justify-content: flex-end; align-items: center; flex-wrap: wrap; gap: 8px; }
        .detect-summary-text { font-size: 0.9rem; margin-right: auto; }
        .detect-divider { text-align: center; color: var(--text-color-light); margin: 16px 0; font-size: 0.85rem; position: relative; }
        .detect-divider::before, .detect-divider::after { content: ''; position: absolute; top: 50%; width: 40%; height: 1px; background: var(--border-color); }
        .detect-divider::before { left: 0; }
        .detect-divider::after { right: 0; }

        .report-section { background: var(--card-bg); border-radius: 12px; padding: var(--space-lg); margin-bottom: 19px; box-shadow: 0 4px 16px var(--card-shadow); }
        @media(min-width: 1441px) { .report-section { padding: var(--space-xl); } }

        .report-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--space-md); margin-bottom: var(--space-lg); }
        .report-title { font-size: 1.1rem; font-weight: 600; color: var(--text-color); }
        .report-title-group { display: flex; align-items: center; gap: 4px; }
        .section-title-group { display: flex; align-items: center; gap: 6px; }
        .info-button { width: 20px; height: 20px; border-radius: 50%; border: 1px solid var(--border-color); background: transparent; color: var(--text-color); font-size: 0.75rem; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; padding: 0; }
        /* [v5.4.0] 仅桌面端启用 hover */
        @media (hover: hover) and (pointer: fine) {
            .info-button:hover { background: rgba(0,0,0,0.05); }
        }
        .info-button:active { background: rgba(0,0,0,0.05); }
        .report-filters, .filter-buttons { display: flex; gap: var(--space-sm); flex-wrap: wrap; }
        .report-filters button, .filter-buttons button, .analysis-controls button, .analysis-view-switcher button { padding: 4px 8px; font-size: 0.8rem; border: 1px solid var(--border-color); background-color: transparent; color: var(--text-color); border-radius: 6px; cursor: pointer; white-space: nowrap; }
        .report-filters button.active, .filter-buttons button.active, .analysis-controls button.active, .analysis-view-switcher button.active { background-color: var(--color-primary); color: white; border-color: var(--color-primary); }
        /* [v6.2.1] 通透模式按钮：移除所有背景和边框 */
        body.glass-mode .report-filters button,
        body.glass-mode .filter-buttons button,
        body.glass-mode .analysis-controls button,
        body.glass-mode .analysis-view-switcher button {
            background: transparent !important;
            border: none !important;
            color: rgba(255, 255, 255, 0.7) !important;
        }
        body.glass-mode .report-filters button.active,
        body.glass-mode .filter-buttons button.active,
        body.glass-mode .analysis-controls button.active,
        body.glass-mode .analysis-view-switcher button.active {
            background: transparent !important;
            border: none !important;
            color: white !important;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(var(--color-primary-rgb), 0.8);
        }
        /* [v6.2.0] 星夜主题按钮使用黄色光晕 */
        body.glass-mode[data-accent="the-starry-night"] .report-filters button.active,
        body.glass-mode[data-accent="the-starry-night"] .filter-buttons button.active,
        body.glass-mode[data-accent="the-starry-night"] .analysis-controls button.active,
        body.glass-mode[data-accent="the-starry-night"] .analysis-view-switcher button.active {
            text-shadow: 0 0 12px rgba(244, 211, 94, 0.9), 0 0 20px rgba(244, 211, 94, 0.6) !important;
        }
        /* [v6.4.6] 杏花盛开主题按钮使用青蓝色光晕 */
        body.glass-mode[data-accent="almond-blossoms"] .report-filters button.active,
        body.glass-mode[data-accent="almond-blossoms"] .filter-buttons button.active,
        body.glass-mode[data-accent="almond-blossoms"] .analysis-controls button.active,
        body.glass-mode[data-accent="almond-blossoms"] .analysis-view-switcher button.active {
            text-shadow: 0 0 12px rgba(70, 132, 153, 0.9), 0 0 20px rgba(90, 159, 176, 0.7) !important;
        }
        
        /* [v5.0.0] 自定义报告卡片管理器样式（支持拖动排序和显示控制） */
        /* 卡片管理器模态框 */
        #cardManagerModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 2000; display: flex; align-items: center; justify-content: center; opacity: 1; transition: opacity 0.25s ease; }
        #cardManagerModal.hidden { display: none; }
        #cardManagerModal .modal-content { background: var(--input-bg); border-radius: 15px; width: 90%; max-width: 400px; max-height: 80vh; overflow-y: auto; padding: var(--space-xl); overscroll-behavior: contain; }
        #cardManagerModal .modal-footer { margin-top: var(--space-lg); display: flex; gap: var(--space-md); justify-content: flex-end; }
        .card-manager-hint { font-size: 0.85rem; color: var(--text-color-light); text-align: center; margin-bottom: var(--space-lg); }
        .card-manager-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: var(--space-md); position: relative; -webkit-touch-callout: none; }
        .card-manager-item { display: flex; align-items: center; gap: 12px; padding: 12px 14px; background: var(--btn-secondary-bg); border-radius: 10px; cursor: grab; user-select: none; position: relative; z-index: 1; -webkit-touch-callout: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; transition: transform 0.3s cubic-bezier(0.34, 1.2, 0.64, 1), box-shadow 0.2s ease, background 0.2s ease, opacity 0.2s ease; }
        .card-manager-item:active { cursor: grabbing; }
        .card-manager-item.dragging { opacity: 0.95; box-shadow: 0 12px 32px rgba(0, 0, 0, 0.25); z-index: 100; background: var(--color-primary); color: white; transition: box-shadow 0.15s ease, background 0.15s ease; }
        .card-manager-item.dragging .card-manager-name { color: white; }
        .card-manager-item.dragging .card-manager-drag-handle { color: rgba(255,255,255,0.8); }
        .card-manager-item.shift-down { transform: translateY(54px); }
        .card-manager-item.shift-up { transform: translateY(-54px); }
        .card-manager-drag-handle { color: var(--text-color-light); font-size: 1.1rem; cursor: grab; transition: color 0.2s ease; }
        .card-manager-name { flex: 1; font-size: 0.95rem; color: var(--text-color); }
        .card-manager-toggle { position: relative; width: 44px; height: 24px; }
        .card-manager-toggle input { opacity: 0; width: 0; height: 0; }
        .card-manager-toggle .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border-color); border-radius: 24px; transition: 0.3s; }
        .card-manager-toggle .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: 0.3s; }
        .card-manager-toggle input:checked + .slider { background-color: var(--color-primary); }
        .card-manager-toggle input:checked + .slider:before { transform: translateX(20px); }
        /* [v6.2.1] 通透模式卡片管理器 */
        body.glass-mode .card-manager-item {
            background: rgba(255, 255, 255, 0.12) !important;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        body.glass-mode .card-manager-item.dragging {
            background: rgba(var(--color-primary-rgb), 0.7) !important;
        }
        body.glass-mode .card-manager-name {
            color: rgba(255, 255, 255, 0.9) !important;
        }
        body.glass-mode .card-manager-drag-handle {
            color: rgba(255, 255, 255, 0.6) !important;
        }
        body.glass-mode .card-manager-toggle .slider {
            background-color: rgba(255, 255, 255, 0.25) !important;
        }
        body.glass-mode .card-manager-toggle input:checked + .slider {
            background-color: rgba(var(--color-primary-rgb), 0.8) !important;
        }

        /* [v4.5.0] 历史弹窗中的视图切换器 */
        #historyModal .analysis-view-switcher {
            margin-bottom: var(--space-xl);
            /* 复用 .report-filters 样式, 但确保它在 modal 内部居中 */
            justify-content: center;
        }

        /* [v5.8.0] 时间流图日程视图重构 */
        .flow-chart-container { 
            display: flex; 
            flex-direction: column; 
            gap: var(--space-md);
        }
        .flow-date-nav { display: flex; align-items: center; gap: 4px; }
        .flow-date-nav button { background: none; border: 1px solid var(--border-color); color: var(--text-color); border-radius: 50%; width: 26px; height: 26px; cursor: pointer; font-size: 0.8rem; transition: transform 0.1s ease; }
        .flow-date-nav button:active:not(:disabled) { transform: scale(0.9); }
        .flow-date-nav button:disabled { opacity: 0.3; cursor: not-allowed; }
        
        /* 流图切换滑动动画 */
        .multi-day-flow-wrapper { transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s ease; }
        .multi-day-flow-wrapper.slide-left { transform: translateX(-30px); opacity: 0; }
        .multi-day-flow-wrapper.slide-right { transform: translateX(30px); opacity: 0; }
        
        #flowDateLabel { font-size: 0.9rem; font-weight: 600; min-width: 90px; text-align: center; }
        
        /* 日程视图头部 */
        .schedule-header { display: flex; justify-content: space-between; align-items: center; }
        .schedule-stats { font-size: 0.8rem; color: var(--text-color-light); }
        .schedule-stats span { margin: 0 4px; }
        .schedule-stats .earned { color: var(--color-earn); }
        .schedule-stats .spent { color: var(--color-spend); }
        
        /* 日程网格 */
        .schedule-grid { position: relative; background: var(--btn-secondary-bg); border-radius: 10px; overflow: hidden; }
        
        /* 小时刻度线 */
        .hour-lines { position: absolute; inset: 0; pointer-events: none; }
        .hour-line { position: absolute; left: 0; right: 0; top: var(--top-px); height: var(--height-px); border-bottom: 1px solid var(--border-color); }
        .hour-line:last-child { border-bottom: none; }
        .hour-line span { position: absolute; left: 6px; top: 2px; font-size: 0.7rem; color: var(--text-color-light); }
        
        /* 任务条块层 - 固定3列 */
        .task-blocks { position: absolute; top: 0; left: 50px; right: 8px; bottom: 0; }
        
        /* 任务条块 - 固定3列布局 */
        .task-block { 
            position: absolute; 
            left: calc(var(--col) * 33.33%); 
            width: calc(33.33% - 4px); 
            top: var(--top-px); 
            height: var(--height-px); 
            min-height: 28px;
            background: color-mix(in srgb, var(--cat-color) 20%, var(--card-bg)); 
            border-left: 4px solid var(--cat-color); 
            border-radius: 0 6px 6px 0; 
            padding: 2px 6px; 
            display: flex; 
            flex-direction: column; 
            justify-content: space-between; 
            overflow: hidden; 
            z-index: 2; 
        }
        .task-block-name { font-size: 0.75rem; font-weight: 500; color: var(--text-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.2; }
        .task-block-name.allow-wrap { white-space: normal; word-break: break-word; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; }
        .task-block-duration { font-size: 0.6rem; color: var(--text-color-light); margin-top: 2px; }
        .task-block-time { font-size: 0.6rem; color: var(--text-color-light); }
        .task-block-time-top { position: absolute; top: 1px; left: 6px; right: 2px; font-size: 0.6rem; color: var(--text-color-light); }
        .task-block-time-bottom { position: absolute; bottom: 1px; left: 6px; right: 2px; font-size: 0.6rem; color: var(--text-color-light); }
        .task-block-content { display: flex; flex-direction: column; justify-content: center; flex: 1; overflow: hidden; }
        .task-block.segment-first .task-block-content, 
        .task-block.segment-last .task-block-content { justify-content: center; }
        .task-block.segment-middle .task-block-content { justify-content: center; }
        
        /* 暂停虚线连接层 - 固定3列 */
        .pause-connections { position: absolute; top: 0; left: 50px; right: 8px; bottom: 0; pointer-events: none; z-index: 1; }
        .pause-line { 
            position: absolute; 
            left: calc((var(--col) + 0.5) * 33.33% - 1px); 
            width: 2px; 
            top: var(--top-px); 
            height: var(--height-px); 
            background: repeating-linear-gradient(to bottom, var(--line-color) 0px, var(--line-color) 4px, transparent 4px, transparent 8px); 
            opacity: 0.6; 
        }
        
        /* [v5.8.0] 多天时间流图样式 */
        .multi-day-flow-wrapper { position: relative; }
        .flow-detail-header { display: flex; align-items: center; justify-content: space-between; flex: 1; margin-right: 12px; }
        .flow-detail-title-group { display: flex; align-items: center; gap: 6px; }
        .flow-detail-title { font-size: 1rem; font-weight: 600; }
        
        /* [v6.3.3] 视图切换按钮 */
        .view-switch-btn {
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            margin-right: 0;
            color: var(--text-color-light);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            height: 30px;
            width: 30px;
        }
        .view-switch-btn:hover {
            background: var(--hover-bg);
            color: var(--color-primary);
        }
        .view-switch-btn:active {
            transform: scale(0.9);
        }
        
        /* [v6.3.3] FIX: Glass Mode 下提高可见性 (纯白+阴影) */
        body.glass-mode .view-switch-btn {
            color: white !important;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            opacity: 1; 
        }
        
        .flow-detail-date { font-size: 0.85rem; font-weight: 600; min-width: 50px; text-align: center; }
        .multi-day-flow-grid { position: relative; min-height: 200px; background: var(--btn-secondary-bg); border-radius: 10px; overflow: hidden; }
        .multi-day-flow-grid .hour-line.new-day { border-top: 1px solid var(--text-color); }
        .multi-day-flow-grid .hour-line.new-day span { color: var(--accent-color); font-weight: 600; }
        .current-time-indicator { position: absolute; left: 0; right: 0; top: var(--top-px); height: 0; z-index: 10; pointer-events: none; }
        .current-time-line { position: absolute; left: 0; right: 0; top: 0; height: 2px; background: #2196F3; }
        .current-time-ball { position: absolute; left: -1px; top: -4px; width: 0; height: 0; border-top: 5px solid transparent; border-bottom: 5px solid transparent; border-left: 8px solid #2196F3; }

        .heatmap-nav { display: flex; align-items: center; gap: var(--space-md); }
        .heatmap-nav button { background: none; border: 1px solid var(--border-color); color: var(--text-color); border-radius: 50%; width: 30px; height: 30px; cursor: pointer; }
        .heatmap-nav button:disabled { opacity: 0.3; cursor: not-allowed; }
        .heatmap-month-label { font-size: 0.9rem; font-weight: 600; width: 100px; text-align: center; }
        .heatmap-grid-wrapper { margin-top: var(--space-lg); }
        .heatmap-weekdays { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; font-size: 0.7rem; text-align: center; margin-bottom: 5px; color: var(--text-color-light); padding: 0 3px; }
        .heatmap-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; padding: 3px; margin: -3px; }
        .heatmap-day, .heatmap-spacer { width: 100%; padding-bottom: 100%; position: relative; }
        .heatmap-day { 
            cursor: pointer; 
            touch-action: pan-y; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        .heatmap-day *, .heatmap-day-content {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        /* [v5.0.0] 活动日历长按弹窗（支持滑动切换日期、3秒后跳转详情） */
        .heatmap-tooltip {
            position: fixed;
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: #1a1a1a;
            border-radius: 12px;
            padding: 10px 14px;
            font-size: 0.8rem;
            line-height: 1.6;
            pointer-events: none;
            max-width: 200px;
            min-width: 140px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.06);
            opacity: 0;
            transform: scale(0.95);
            transform-origin: center bottom;
            transition: opacity 0.12s ease-out, transform 0.12s ease-out;
            z-index: 1500;
            will-change: opacity;
            overflow: hidden; /* 让进度条被圆角裁剪 */
        }
        [data-theme="dark"] .heatmap-tooltip {
            background: rgba(0, 0, 0, 0.88);
            color: #fff;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.28), 0 2px 8px rgba(0, 0, 0, 0.12);
        }
        .heatmap-tooltip.show { 
            opacity: 1; 
            transform: scale(1);
        }
        .heatmap-tooltip-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--color-primary);
            border-radius: 0; /* 不需要圆角，由父容器overflow裁剪 */
            width: 0%;
            transition: width 2.75s linear;
        }
        .heatmap-tooltip.show .heatmap-tooltip-progress.animating {
            width: 100%;
        }
        /* [v5.8.0] 弹窗翻页动画：以底部为轴的3D翻转，连续滑动产生波浪效果 */
        .heatmap-tooltip {
            transform-origin: center bottom;
        }
        .heatmap-tooltip.flipping {
            animation: heatmapTooltipFlipIn 120ms cubic-bezier(0.22, 0.61, 0.36, 1) forwards;
        }
        @keyframes heatmapTooltipFlipIn {
            0% { 
                opacity: 0.4; 
                transform: perspective(400px) rotateX(-50deg) scale(0.92);
            }
            100% { 
                opacity: 1; 
                transform: perspective(400px) rotateX(0deg) scale(1);
            }
        }
        /* 翻页合上退出动画（影子元素使用，时长与日期格子缩小动画一致）1s */
        .heatmap-tooltip-shadow {
            pointer-events: none;
            z-index: 1499; /* 低于主 tooltip 的 1500，确保不遮挡当前弹窗 */
            animation: heatmapTooltipFlipOut 1s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }
        @keyframes heatmapTooltipFlipOut {
            0% { 
                opacity: 0.7; 
                transform: perspective(400px) rotateX(0deg) scale(1);
            }
            100% { 
                opacity: 0; 
                transform: perspective(400px) rotateX(70deg) scale(0.8);
            }
        }
        .heatmap-tooltip-date { font-weight: 700; margin-bottom: 6px; font-size: 0.85rem; }
        .heatmap-tooltip-net { font-size: 1.1rem; font-weight: 600; margin-bottom: 6px; }
        .heatmap-tooltip-net.positive { color: #16a34a; }
        .heatmap-tooltip-net.negative { color: #dc2626; }
        [data-theme="dark"] .heatmap-tooltip-net.positive { color: #4ade80; }
        [data-theme="dark"] .heatmap-tooltip-net.negative { color: #f87171; }
        .heatmap-tooltip-stats { font-size: 0.75rem; opacity: 0.85; }
        .heatmap-tooltip-hint { font-size: 0.7rem; opacity: 0.6; margin-top: 8px; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 6px; }
        [data-theme="dark"] .heatmap-tooltip-hint { border-top-color: rgba(255,255,255,0.15); }
        /* [v5.4.0] 添加放大/缩小过渡动画，退出时1秒柔和过渡 */
        .heatmap-day-content { position: absolute; top:0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; background-color: var(--btn-secondary-bg); border-radius: 4px; transition: transform 1s ease-out, box-shadow 1s ease-out; }
        /* 放大时快速响应（0.15s），缩小时柔和过渡（1s，由上面的默认值控制） */
        .heatmap-day.active .heatmap-day-content { transform: scale(1.15); box-shadow: 0 0 0 2px var(--color-primary), 0 4px 12px rgba(0,0,0,0.3); z-index: 10; transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; }
        /* [v5.4.0] 只在真正支持 hover 的设备上启用 :hover 效果，防止移动端触摸后 hover 状态粘滞 */
        @media (hover: hover) and (pointer: fine) {
            .heatmap-day:hover .heatmap-day-content { transform: scale(1.1); box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 2; transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; }
        }
        
        .heatmap-day-content.net-surplus-1 { background-color: #9be9a8; } .heatmap-day-content.net-surplus-2 { background-color: #40c463; } .heatmap-day-content.net-surplus-3 { background-color: #216e39; color: white; }
        .heatmap-day-content.net-deficit-1 { background-color: #ffcdd2; } .heatmap-day-content.net-deficit-2 { background-color: #e57373; } .heatmap-day-content.net-deficit-3 { background-color: #f44336; color: white; }
        /* [v4.5.2] FIX: Removed 6 incorrect dark mode rules for activity calendar */
        
        /* [v4.5.3] FIX: Dark mode 下活动日历浅色块的文字颜色 */
        [data-theme="dark"] .heatmap-day-content.net-surplus-1 { color: #333; }
        [data-theme="dark"] .heatmap-day-content.net-deficit-1 { color: #333; }
        
        /* [v4.5.0] 任务历史日历的 6 种专用颜色 */
        .heatmap-day-content.task-cal-green-1 { background-color: var(--color-task-green-1); color: #333; }
        .heatmap-day-content.task-cal-green-2 { background-color: var(--color-task-green-2); color: white; }
        .heatmap-day-content.task-cal-green-3 { background-color: var(--color-task-green-3); color: white; }
        .heatmap-day-content.task-cal-red-1 { background-color: var(--color-task-red-1); color: #333; }
        .heatmap-day-content.task-cal-red-2 { background-color: var(--color-task-red-2); color: white; }
        .heatmap-day-content.task-cal-red-3 { background-color: var(--color-task-red-3); color: white; }
        /* [v5.1.0] Selected day highlight for history calendar - use inset shadow to avoid clipping */
        .heatmap-day.selected .heatmap-day-content { 
            box-shadow: inset 0 0 0 2px var(--color-primary); 
            transform: scale(1.05);
            z-index: 5;
        }
        /* [v4.5.2] FIX: Removed incorrect dark mode rule for task calendar text color */

        .heatmap-legend { display: flex; justify-content: flex-end; align-items: center; gap: 5px; font-size: 0.75rem; color: var(--text-color-light); margin-top: var(--space-md); flex-wrap: wrap; }
        .legend-box { width: 12px; height: 12px; border-radius: 2px; }
        
        /* [v4.5.1] 修复: 任务日历图例的颜色块 */
        .legend-box.task-cal-green-1 { background-color: var(--color-task-green-1); }
        .legend-box.task-cal-green-2 { background-color: var(--color-task-green-2); }
        .legend-box.task-cal-green-3 { background-color: var(--color-task-green-3); }
        .legend-box.task-cal-red-1 { background-color: var(--color-task-red-1); }
        .legend-box.task-cal-red-2 { background-color: var(--color-task-red-2); }
        .legend-box.task-cal-red-3 { background-color: var(--color-task-red-3); }

        /* [v4.5.0] 任务历史日历的图例样式 */
        #historyModal .heatmap-legend {
            justify-content: center; /* 居中图例 */
            gap: var(--space-sm) var(--space-md); /* 增加项目间距 */
        }
        
        /* [v3.12.1] Fix table border overflow */
        .analysis-table-container { 
            overflow-x: auto; 
        }
        .analysis-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
        .analysis-table th, .analysis-table td { padding: 10px; text-align: left; border-bottom: 1px solid var(--border-color); }
        .analysis-table th { font-weight: 600; user-select: none; white-space: nowrap; }
        .analysis-table td:nth-child(2), .analysis-table td:nth-child(3) { white-space: nowrap; }
        /* 任务视图使用固定表格布局防止排序时列移动 */
        .analysis-table.task-view { table-layout: fixed; }
        .analysis-table.task-view th, .analysis-table.task-view td { padding: 8px; }
        .analysis-table.task-view th:nth-child(1), .analysis-table.task-view td:nth-child(1) { width: auto; }
        .analysis-table.task-view th:nth-child(2), .analysis-table.task-view td:nth-child(2) { width: 75px; }
        .analysis-table.task-view th:nth-child(3), .analysis-table.task-view td:nth-child(3) { width: 60px; }
        .analysis-table.task-view th:nth-child(4), .analysis-table.task-view td:nth-child(4) { width: 50px; white-space: nowrap; }
        .table-footer-row td {
            padding: var(--space-md);
            text-align: center;
            border-bottom: none;
        }
        .show-more-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color-light);
            padding: var(--space-sm) var(--space-lg);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        /* [v5.4.0] 仅桌面端启用 hover */
        @media (hover: hover) and (pointer: fine) {
            .show-more-btn:hover {
                background: var(--btn-secondary-bg);
            }
        }
        .show-more-btn:active { background: var(--btn-secondary-bg); }
        
        /* [v5.0.0] 分类任务展开/收起按钮 - 紧凑样式 */
        .category-expand-btn {
            background: var(--card-bg);
            border: none;
            color: var(--text-color-light);
            padding: 4px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.75rem;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            opacity: 0.85;
        }
        /* [v5.4.0] 仅桌面端启用 hover */
        @media (hover: hover) and (pointer: fine) {
            .category-expand-btn:hover {
                opacity: 1;
                color: var(--text-color);
            }
        }
        .category-expand-btn:active { opacity: 1; color: var(--text-color); }
        .category-expand-btn .expand-icon {
            font-size: 0.6rem;
            transition: transform 0.2s ease;
        }
        .category-expand-btn.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .text-positive { color: var(--color-positive); font-weight: 500; } .text-negative { color: var(--color-negative); font-weight: 500; } .text-neutral { color: var(--color-neutral); font-weight: 500; }

        .task-name-scrollable {
            display: block; 
            max-width: 80px;
            overflow-x: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: grab;
            scrollbar-width: none;
            -ms-overflow-style: none;
            outline: none;
        }
        .task-name-scrollable::-webkit-scrollbar {
            display: none;
        }
        .task-name-scrollable:focus { 
            overflow-x: auto;
            text-overflow: clip; 
            cursor: grabbing;
        }
        /* [v5.4.0] 仅桌面端启用 hover */
        @media (hover: hover) and (pointer: fine) {
            .task-name-scrollable:hover { 
                overflow-x: auto;
                text-overflow: clip; 
                cursor: grabbing;
            }
        }
        
        .stat-card { background: var(--card-bg); border-radius: 12px; padding: var(--space-lg); text-align: center; box-shadow: 0 4px 16px var(--card-shadow); min-width: 0; }
        .stat-value { font-size: 1.2rem; font-weight: bold; margin-bottom: var(--space-sm); white-space: nowrap; }
        #totalEarned.stat-value { color: var(--color-primary); } #totalSpent.stat-value { color: #E64A19; }
        .stat-label { font-size: 0.85rem; color: var(--text-color-light); }
        
        .settings-section { background: var(--card-bg); border-radius: 12px; padding: var(--space-xl); margin-bottom: 19px; box-shadow: 0 4px 16px var(--card-shadow); }
        /* [v3.12.3] Reduce title margin */
        .settings-title { font-size: 1.1rem; font-weight: 600; margin-bottom: var(--space-md); color: var(--text-color); }
        
        .setting-item { display: flex; justify-content: space-between; align-items: center; padding: var(--space-lg) 0; border-bottom: 1px solid var(--border-color); gap: var(--space-lg); }
        .setting-item:last-child { border-bottom: none; }
        .setting-info { flex: 1; min-width: 0; }
        .setting-name { font-weight: 500; margin-bottom: 2px; }
        .setting-desc { font-size: 0.85rem; color: var(--text-color-light); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .setting-controls { display: flex; align-items: center; gap: var(--space-md); }

        .theme-selector { display: flex; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
        .theme-option { flex: 1; padding: 6px 12px; text-align: center; background: none; border: none; cursor: pointer; font-size: 0.85rem; color: var(--text-color); border-left: 1px solid var(--border-color); transition: background 0.2s, color 0.2s; }
        .theme-option:first-child { border-left: none; }
        .theme-option.active { background: #2196F3; color: white; }
        
        /* [v6.2.0] 主题色选择器 - 含画作缩略图 */
        .accent-selector { display: flex; gap: 8px; flex-wrap: wrap; }
        /* [v6.4.6] 统一所有主题图标：移除边框间隙，使用overflow:hidden确保圆角裁切 */
        .accent-option { position: relative; width: 28px; height: 28px; border-radius: 6px; border: none; cursor: pointer; transition: box-shadow 0.2s; background-size: cover; background-position: center; flex-shrink: 0; outline: none; -webkit-tap-highlight-color: transparent; overflow: hidden; }
        .accent-option:hover { transform: none; }
        .accent-option:focus { outline: none; }
        .accent-option.active { box-shadow: 0 0 0 2px var(--card-bg), 0 0 0 4px #2196F3; transform: none; }
        .accent-option[data-accent="blue-purple"] { background: linear-gradient(135deg, #2196F3 0%, #5c6bc0 50%, #7c4dff 100%); }
        .accent-option[data-accent="pink-white"] { background: linear-gradient(135deg, #f48fb1 0%, #f8bbd9 50%, #fce4ec 100%); }
        /* [v6.2.0] 画作主题 - 使用画作缩略图，方形显示 */
        /* [v6.4.6] 使用正方形裁切的background_*图片，统一大小和圆角 */
        .accent-option[data-accent="the-starry-night"] { background: url('themes/background_the-starry-night.png') center/cover no-repeat !important; }
        .accent-option[data-accent="woman-with-a-parasol"] { background: url('themes/background_woman-with-a-parasol.png') center/cover no-repeat !important; }
        .accent-option[data-accent="almond-blossoms"] { background: url('themes/background_almond-blossoms.png') center/cover no-repeat !important; }
        
        /* [v6.2.0] 背景选择器 - 跟随主题/自定义 */
        .bg-selector { display: flex; gap: 8px; align-items: center; }
        .bg-option { padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: all 0.2s; background: var(--card-bg); display: flex; align-items: center; justify-content: center; font-size: 0.85rem; color: var(--text-color); white-space: nowrap; }
        .bg-option:hover { transform: scale(1.05); background: var(--btn-secondary-bg); }
        /* [v6.2.0] 经典模式+亮色主题下上传按钮使用中间灰色 */
        body:not(.glass-mode):not([data-theme="dark"]) .bg-option {
            background: #d8d8d8 !important;
        }
        body:not(.glass-mode):not([data-theme="dark"]) .bg-option:hover {
            background: #c0c0c0 !important;
        }
        /* [v6.2.0] 通透模式+亮色主题下上传按钮使用半透明白色 */
        body.glass-mode:not([data-theme="dark"]) .bg-option {
            background: rgba(255, 255, 255, 0.25) !important;
            border-color: rgba(255, 255, 255, 0.4) !important;
        }
        body.glass-mode:not([data-theme="dark"]) .bg-option:hover {
            background: rgba(255, 255, 255, 0.35) !important;
        }
        .bg-option .bg-label { pointer-events: none; }
        .bg-upload { position: relative; }
        .bg-clear-btn { padding: 4px 8px; border: none; background: rgba(244, 67, 54, 0.1); color: var(--color-negative); border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; }
        .bg-clear-btn:hover { background: rgba(244, 67, 54, 0.2); }
        
        /* 背景图片模式 */
        body.bg-image {
            background: var(--bg-image) !important;
            background-size: cover !important;
            background-position: center !important;
            background-attachment: fixed !important;
        }
        body.bg-image::before {
            content: '';
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            pointer-events: none;
            z-index: -1;
        }
        [data-theme="dark"] body.bg-image::before,
        body.bg-image[data-theme="dark"]::before {
            background: rgba(0, 0, 0, 0.5);
        }
        
        /* [v5.10.0] 卡片样式选择器 */
        .style-switcher { display: flex; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
        .style-btn { padding: 6px 12px; text-align: center; background: none; border: none; cursor: pointer; font-size: 0.85rem; color: var(--text-color); border-left: 1px solid var(--border-color); transition: background 0.2s, color 0.2s; }
        .style-btn:first-child { border-left: none; }
        .style-btn.active { background: var(--color-primary); color: white; }
        /* [v6.2.0] 修复暗色模式下圆角边框显示 */
        [data-theme="dark"] .style-switcher,
        [data-theme="dark"] .theme-selector {
            border-color: rgba(255, 255, 255, 0.2);
        }
        [data-theme="dark"] .style-btn,
        [data-theme="dark"] .theme-option {
            border-left-color: rgba(255, 255, 255, 0.2);
        }
        /* [v6.2.0] 通透模式下滑块样式 - 统一蓝色调 */
        body.glass-mode .style-switcher,
        body.glass-mode .theme-selector {
            border-color: rgba(255, 255, 255, 0.3) !important;
        }
        body.glass-mode .settings-section .style-btn,
        body.glass-mode .settings-section .theme-option,
        body.glass-mode .style-btn,
        body.glass-mode .theme-option {
            color: rgba(255, 255, 255, 0.9) !important;
            border-left-color: rgba(255, 255, 255, 0.2) !important;
            background: transparent !important;
        }
        body.glass-mode .settings-section .style-btn.active,
        body.glass-mode .settings-section .theme-option.active,
        body.glass-mode .style-switcher .style-btn.active,
        body.glass-mode .theme-selector .theme-option.active,
        body.glass-mode .style-btn.active,
        body.glass-mode .theme-option.active {
            background: rgba(var(--color-primary-rgb), 0.8) !important;
            color: white !important;
        }

        /* 主题跟随的滑杆色（含通透/模糊强度滑块等） */
        .settings-section input[type="range"] {
            accent-color: var(--color-primary);
        }
        body.glass-mode .settings-section input[type="range"] {
            accent-color: rgba(var(--color-primary-rgb), 0.9);
        }
        /* WebView 兼容：显式着色轨道与滑块拇指 */
        .settings-section input[type="range"]::-webkit-slider-thumb {
            background: var(--color-primary);
        }
        .settings-section input[type="range"]::-moz-range-thumb {
            background: var(--color-primary);
        }
        .settings-section input[type="range"]::-webkit-slider-runnable-track {
            background: transparent;
        }
        .settings-section input[type="range"]::-moz-range-track {
            background: transparent;
        }
        body.glass-mode .settings-section input[type="range"]::-webkit-slider-thumb {
            background: rgba(var(--color-primary-rgb), 0.9);
        }
        body.glass-mode .settings-section input[type="range"]::-moz-range-thumb {
            background: rgba(var(--color-primary-rgb), 0.9);
        }
        body.glass-mode .settings-section input[type="range"]::-webkit-slider-runnable-track {
            background: transparent;
        }
        body.glass-mode .settings-section input[type="range"]::-moz-range-track {
            background: transparent;
        }

        .switch { position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; }
        input:checked + .slider { background-color: var(--color-primary); }
        input:checked + .slider:before { transform: translateX(26px); }
        .threshold-input { width: 80px; padding: 4px 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.9rem; background-color: var(--input-bg); color: var(--text-color); }

        /* [v3.11.1] Ensure data buttons stay on one line */
        .data-buttons { display: flex; gap: var(--space-md); margin-top: var(--space-lg); justify-content: center; flex-wrap: nowrap; /* Prevent wrapping */ }
        .data-btn { flex: 1; /* Allow shrinking */ padding: var(--space-md); border: 2px solid var(--color-primary); border-radius: 8px; background: white; color: var(--color-primary); font-size: 0.9rem; font-weight: 500; cursor: pointer; text-align: center; white-space: nowrap; /* Prevent text wrapping inside button */ }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .data-btn:hover { background: var(--color-primary); color: white; }
            [data-theme="dark"] .data-btn:hover { background: var(--color-primary); color: white; }
        }
        .data-btn:active { background: var(--color-primary); color: white; }
        [data-theme="dark"] .data-btn { background: var(--card-bg); color: var(--color-primary); }
        [data-theme="dark"] .data-btn:active { background: var(--color-primary); color: white; }
        .file-input { display: none; }

        /* Demo CTA for empty state */
        .demo-cta { background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: var(--space-lg); margin-bottom: var(--space-lg); box-shadow: 0 6px 16px var(--card-shadow); }
        .demo-cta-body { display: flex; align-items: center; justify-content: space-between; gap: var(--space-md); flex-wrap: wrap; }
        .demo-cta-title { font-weight: 700; font-size: 1rem; margin-bottom: 6px; color: var(--text-color); }
        .demo-cta-text { color: var(--text-color-light); font-size: 0.9rem; }
        
        /* [v4.0.0] Styles for Auth UI */
        #authForm { display: grid; grid-template-columns: 1fr; gap: var(--space-md); }
        #authForm .form-group { margin-bottom: 0; }
        #authButtons { display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-md); margin-top: var(--space-lg); }
        #authStatus { 
            font-size: 0.9rem; 
            text-align: center; 
            margin-top: var(--space-lg);
            padding: var(--space-md);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        #authStatus.status-offline { background-color: rgba(108, 117, 125, 0.1); border-color: #6c757d; color: #6c757d; }
        #authStatus.status-online { background-color: rgba(76, 175, 80, 0.1); border-color: var(--color-positive); color: var(--color-positive); }
        #authStatus.status-error { background-color: rgba(244, 67, 54, 0.1); border-color: var(--color-negative); color: var(--color-negative); }
        #authStatus.status-syncing { background-color: rgba(var(--color-primary-rgb), 0.1); border-color: var(--color-primary); color: var(--color-primary); }
        /* [v4.3.7] Retain warning state */
        #authStatus.status-warning { background-color: rgba(255, 152, 0, 0.1); border-color: var(--color-warning); color: var(--color-warning); }
        [data-theme="dark"] #authStatus.status-offline { color: #aaa; }
        
        .about-section details { margin-top: var(--space-lg); border: 1px solid var(--border-color); border-radius: 8px; padding: var(--space-md) var(--space-lg); }
        .about-section summary { font-weight: 500; cursor: pointer; outline: none; }
        .about-section p { font-size: 0.9rem; line-height: 1.6; margin: var(--space-md) 0; color: var(--text-color-light); }
        .about-section ul { list-style-position: inside; padding-left: var(--space-md); }
        .about-section li { font-size: 0.9rem; margin-bottom: var(--space-sm); }
        .version-history-item > ul { list-style: none; padding-left: 0; }
        .version-history-item > ul > li { margin-bottom: var(--space-sm); }
        .version-history-container { 
            max-height: min(60vh, 450px); 
            overflow-y: auto; 
            padding-right: var(--space-md); 
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch; /* iOS 惯性滚动 */
            will-change: scroll-position;
            touch-action: pan-y;
        }
        
        /* [v3.13.2] Style for code snippets in version history to prevent overflow */
        .about-section code {
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.05);
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.85em;
            word-break: break-all; /* Critical for preventing overflow */
        }
        [data-theme="dark"] .about-section code {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .history-item { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: var(--space-md) 0; 
            border-bottom: 1px solid var(--border-color); 
            gap: var(--space-sm); 
        }
        .history-item:last-child { border-bottom: none; }
        .history-info { flex-grow: 1; min-width: 0; }
        .history-description { font-weight: 500; margin-bottom: 2px; }
        .history-description .desc-line-1,
        .history-description .desc-line-2 {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }
        .history-description .desc-line-2 {
            font-size: 0.8rem;
            color: var(--text-color-light);
        }
        .history-time { font-size: 0.8rem; color: var(--text-color-light); }
        .history-amount-wrapper { flex-shrink: 0; width: 80px; text-align: right; }
        .history-amount { font-weight: 600; font-size: 0.9rem; }
        .history-amount.positive { color: var(--color-positive); } 
        .history-amount.negative { color: var(--color-negative); }
        .undo-btn { background-color: var(--btn-secondary-bg); color: var(--btn-secondary-text); border: 1px solid var(--btn-secondary-border); padding: 4px 8px; font-size: 0.75rem; border-radius: 5px; cursor: pointer; flex-shrink: 0; }
        /* [v5.4.0] 仅桌面端启用 hover，移动端用 active */
        @media (hover: hover) and (pointer: fine) {
            .undo-btn:hover { opacity: 0.8; transform: translateY(-1px); }
        }
        .undo-btn:active { opacity: 0.8; transform: translateY(-1px); }
        
        /* [v5.1.0] History modal combined view (calendar + list) */
        .history-combined-container {
            height: 65vh;
            min-height: 65vh;
            max-height: 65vh;
            overflow-y: auto;
            overflow-x: hidden; /* [v5.9.0] 禁止水平滚动 */
        }
        .history-calendar-section {
            margin-bottom: var(--space-md);
        }
        .history-list-header {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-color);
            padding: var(--space-sm) 0;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            margin-bottom: var(--space-sm);
        }
        .history-list-section {
            padding-bottom: var(--space-md);
            transition: max-height 0.25s ease-out;
        }
        /* [v5.1.0] Smooth height transition for history modal */
        #historyModal .modal-content {
            transition: transform 0.3s ease, max-height 0.25s ease-out;
        }
        
        .day-detail-summary { margin-bottom: var(--space-lg); padding-bottom: var(--space-lg); border-bottom: 1px solid var(--border-color); text-align: center; }
        .day-detail-net { font-size: 1.2rem; font-weight: bold; margin-bottom: var(--space-sm); }
        .day-detail-stats { font-size: 0.9rem; color: var(--text-color-light); }

        #analysisDashboard { display: flex; flex-direction: column; gap: var(--space-xl); }
        
        .kpi-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr;
            gap: var(--space-lg); 
        }

        .kpi-card { background: var(--card-bg); border-radius: 12px; padding: var(--space-lg); text-align: center; }
        .kpi-label { font-size: 0.8rem; color: var(--text-color-light); margin-bottom: var(--space-sm); }
        .kpi-value { font-size: 1.1rem; font-weight: 600; word-wrap: break-word; }
        .kpi-value.positive { color: var(--color-positive); } .kpi-value.negative { color: var(--color-negative); }
        .kpi-value.kpi-time {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* [v6.0.0] KPI 切换淡入动画 */
        @keyframes kpiFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .kpi-card.kpi-fade-in {
            animation: kpiFadeIn 0.25s ease-out forwards;
        }
        
        .chart-container { background: var(--card-bg); border-radius: 12px; padding: var(--space-lg); }
        .chart-title { font-size: 0.95rem; font-weight: 600; text-align: center; margin-bottom: var(--space-lg); }

        .leaderboard-chart { display: flex; flex-direction: column; gap: var(--space-sm); }
        /* [v3.10.3] Leaderboard Layout Tweak for Category View */
        .leaderboard-chart.category-view .leaderboard-item { grid-template-columns: minmax(auto, 65px) 1fr; }
        .leaderboard-item { display: grid; grid-template-columns: minmax(auto, 80px) 1fr; align-items: center; gap: var(--space-sm); font-size: 0.8rem; min-width: 0; }
        .leaderboard-label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-color-light); text-align: right;}
        .leaderboard-bar-wrapper { width: 100%; background: var(--border-color); border-radius: 4px; position: relative; display: flex; align-items: center;}
        .leaderboard-bar { height: 18px; border-radius: 4px; }
        /* [v3.10.3] Leaderboard Label Style Update */
        .leaderboard-bar-value { 
            position: absolute; 
            font-size: 0.7rem; 
            font-weight: 500; 
            color: white; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            left: 5px; /* Always left-aligned */
            white-space: nowrap;
        }

        .swiper-container {
            overflow: hidden;
            position: relative;
            width: 100%;
        }
        .swiper-wrapper {
            display: flex;
            width: 200%; /* Default for 2 slides */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .swiper-slide {
            width: 50%; /* Default for 2 slides */
            flex-shrink: 0;
            padding: 0 5px;
        }
        /* [v3.14.1] Re-enabled for interactive charts */
        .swiper-pagination {
           position: relative; /* Not absolute, so it sits in the layout flow */
           bottom: auto;
           padding-top: var(--space-sm); /* Space from chart */
           height: 12px; /* Fixed height to prevent jump */
           display: flex;
           justify-content: center;
           align-items: center;
           gap: 6px;
        }
        .swiper-pagination-bullet {
            /* [v3.14.1] Re-enabled */
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-color);
            opacity: 0.7;
            cursor: pointer;
        }
        .swiper-pagination-bullet-active {
            background: var(--color-primary);
            opacity: 1;
        }

        .trend-chart-container { display: grid; grid-template-columns: 1fr; gap: var(--space-xl);}
        .trend-chart { 
            width: 100%; 
            display: flex; 
            justify-content: space-between; 
            gap: 2px; 
            /* [Fix] 必须使用 visible，且 padding 至少需要 24px 才能容纳底部文字 */
            /* 如果设为 8px，文字高度超出容器，会被外层的 Swiper 裁剪 */
            overflow: visible; 
            padding-bottom: 8px; 
        }
        .trend-day { flex: 1; display: flex; flex-direction: column; justify-content: flex-end; background: var(--border-color); border-radius: 4px; position: relative; cursor: pointer; touch-action: pan-y; }
        .trend-day.active { outline: 2px solid var(--color-primary); box-shadow: 0 0 0 3px rgba(var(--color-primary-rgb), 0.2); }
        .trend-segment { width: 100%; }
        .trend-date-label { 
            font-size: 0.6rem; 
            color: var(--text-color-light); 
            text-align: center; 
            margin-top: 2px; 
            white-space: nowrap; 
            /* [Fix] 关键修改：允许文字超出列宽显示，防止右侧被切断 */
            overflow: visible; 
            width: 100%; 
        }

        /* [v5.0.0] 趋势演变图长按弹窗（支持滑动切换日期查看详情） */
        .trend-tooltip {
            position: fixed;
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: #1a1a1a;
            border-radius: 12px;
            padding: 10px 12px;
            font-size: 0.78rem;
            line-height: 1.5;
            pointer-events: none;
            max-width: 240px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.06);
            opacity: 0;
            transform: scale(0.85) translateY(8px);
            transform-origin: center bottom;
            transition: opacity 0.15s ease-out, transform 0.15s ease-out;
            z-index: 1500;
            will-change: transform, opacity, left, top;
            overflow: hidden; /* 裁剪进度条 */
        }
        [data-theme="dark"] .trend-tooltip {
            background: rgba(0, 0, 0, 0.88);
            color: #fff;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.28), 0 2px 8px rgba(0, 0, 0, 0.12);
        }
        .trend-tooltip.show { 
            opacity: 1; 
            transform: scale(1) translateY(0); 
            animation: tooltipSpringIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        /* 快速滑动时：禁用弹性动画，使用更短的过渡时间 */
        .trend-tooltip.moving {
            animation: none !important;
            transition: left 0.12s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        top 0.12s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        opacity 0.08s ease-out,
                        transform 0.08s ease-out;
        }
        /* 内容更新时的淡入效果 */
        .trend-tooltip-content {
            transition: opacity 0.1s ease-out;
        }
        .trend-tooltip-content.updating {
            opacity: 0.7;
        }
        @keyframes tooltipSpringIn {
            0% { transform: scale(0.85) translateY(8px); opacity: 0; }
            50% { transform: scale(1.03) translateY(-2px); opacity: 1; }
            75% { transform: scale(0.98) translateY(1px); }
            100% { transform: scale(1) translateY(0); }
        }
        
        .trend-tooltip-title { font-weight: 700; margin-bottom: 4px; display: block; }
        .trend-tooltip-list { display: grid; gap: 4px; }
        .trend-tooltip-row { display: flex; justify-content: space-between; gap: 8px; white-space: nowrap; }
        .trend-tooltip-total { margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(0, 0, 0, 0.1); font-weight: 600; }
        [data-theme="dark"] .trend-tooltip-total { border-top-color: rgba(255, 255, 255, 0.2); }
        
        .analysis-filters { 
            display: flex; 
            flex-wrap: nowrap; 
            justify-content: space-between; 
            align-items: center; 
            gap: var(--space-md); 
            margin-bottom: var(--space-md); 
        }
        .analysis-filters > div:first-child { flex: 1 1 auto; min-width: 0; display: flex; flex-wrap: wrap; gap: var(--space-sm); align-items: center; } /* [v3.12.4] Reverted */
        .analysis-filters > div:last-child { flex: 0 0 auto; } /* [v3.12.4] Reverted */
        
        .analysis-view-switcher { display: flex; gap: var(--space-sm); }
        
        .chart-legend { display: flex; flex-wrap: wrap; justify-content: center; gap: var(--space-xs) var(--space-sm); margin-top: var(--space-xs); }
        .legend-item { display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 0.7rem; }
        .legend-color-box { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }
        .legend-label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100px; }
        
        #tableContainerWrapper { margin-top: var(--space-xl); }

        /* [v3.10.3] Pie Chart with Legend and Inner Labels */
        .pie-chart-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-md);
            overflow: visible; /* 高亮外扩不被裁切 */
        }
        .pie-chart-container {
            position: relative;
            width: 180px; /* Centered pie area */
            height: 180px;
            margin: 10px auto; /* [v5.4.0] 上下预留10px空间给扇形外扩 */
            touch-action: pan-y; /* [v5.1.1] 允许纵向滚动，长按跟手仍由 JS 阻断 */
            overflow: visible; /* 为扇形外扩预留空间，避免裁切 */
        }
        .pie-chart {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            background: conic-gradient( from 0deg, var(--color-other) 0% 100% );
        }
        .pie-chart::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 39%; /* [v5.1.0] Reduced from 45% */
            height: 39%;
            background: var(--card-bg);
            border-radius: 50%;
        }
        .pie-slice-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .pie-slice-label {
            position: absolute;
            font-size: 10px;
            font-weight: 500;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            transform: translate(-50%, -50%);
            line-height: 1.2;
            text-align: center;
        }
         .pie-slice-label .time-value {
            font-size: 9px;
            opacity: 0.9;
        }
        .pie-chart-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: calc(180px * 0.39); /* [v5.1.0] Reduced from 0.45 */
            height: calc(180px * 0.39);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-touch-callout: none;
            pointer-events: none;
            touch-action: none;
        }
        /* [v5.4.0] 饼图扇形外扩动画（CSS d 属性过渡） */
        .pie-chart { transition: none; }
        .pie-highlight-layer { position: absolute; inset: -10px; pointer-events: none; }
        .pie-highlight-slice { transition: d 0.8s ease-out; }
        .pie-highlight-slice.active { transition: d 0.15s ease-out; }
        .pie-center-title {
            font-size: 0.75rem;
            color: var(--text-color-light);
        }
        .pie-center-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-color);
            white-space: nowrap;
        }
        .pie-chart-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: var(--space-xs) var(--space-md);
            margin-top: var(--space-sm);
            padding: 0 var(--space-lg);
            width: 100%;
        }
        .pie-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--text-color-light);
        }
        .pie-legend-color-box {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .category-detail-chart-row { display: none; }
        .category-detail-legend { display: none; }
        .category-detail-summary { padding: 4px 4px 6px; border-bottom: 1px solid var(--border-color); margin-bottom: 6px; }
        .category-detail-list { margin-top: 0; }
        .category-detail-meta { font-size: 0.9rem; color: var(--text-color-light); }
        #categoryDetailModal .modal-header { margin-bottom: 8px; }
        /* 饼图长按进入详情的展开动画（类似活动日历） */
        #categoryDetailModal.from-pie .modal-content {
            animation: modalExpandIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* [v5.1.0] Pie tooltip overrides：取消弹簧动画，原地淡入显示 */
        .pie-tooltip {
            animation: none !important;
            transition: opacity 0.15s ease-out;
            transform: none !important;
            overflow: hidden; /* 显示底部进度条 */
            background: rgba(255, 255, 255, 0.65);
        }
        [data-theme="dark"] .pie-tooltip {
            background: rgba(0, 0, 0, 0.62);
        }
        .pie-tooltip.show {
            animation: none !important;
            transform: none !important;
        }
        /* [v5.1.0] 移动时启用位置过渡实现跟手效果 */
        .pie-tooltip.moving {
            transition: left 0.1s ease-out, top 0.1s ease-out, opacity 0.15s ease-out;
        }
        .pie-tooltip-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--color-primary);
            width: 0%;
            transition: width 2.75s linear;
        }
        .pie-tooltip.show .pie-tooltip-progress.animating { width: 100%; }
        
        /* [v3.14.1] Increased min-height for pagination dots */
        #pieChartContainerWrapper.task-view-active {
            min-height: 248px; /* 228 + 20px for pagination */
        }
        #pieChartContainerWrapper.category-view-active {
            min-height: 208px; /* 188 + 20px for pagination */
        }
        
        /* [v3.12.4] Specific override for dashboard filter alignment */
        #analysisDashboardFilters {
            margin-left: auto; /* Push to right side */
        }
        
        /* [v4.8.0] 习惯奖励卡片样式重构 */
        .habit-reward-card {
            background-color: var(--btn-secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            position: relative;
        }
        .form-label-small {
            display: block;
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-bottom: 4px;
        }
        .reward-grid-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 8px;
        }
        .input-with-suffix {
            display: flex;
            align-items: center;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }
        .input-with-suffix .form-input {
            border: none;
            margin: 0;
            padding: 6px 8px;
            flex: 1;
            height: auto;
            border-radius: 0;
        }
        .input-suffix-text {
            padding: 0 8px;
            font-size: 0.8rem;
            color: var(--text-color-light);
            background: rgba(0,0,0,0.02);
            border-left: 1px solid var(--border-color);
            height: 100%;
            display: flex;
            align-items: center;
        }
        .reward-card-footer {
            display: flex;
            justify-content: space-between; /* 左右分布 */
            align-items: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed var(--border-color); /* 增加分割线 */
        }
        .reward-desc-text {
            font-size: 0.75rem;
            color: var(--text-color-light);
            font-style: italic;
        }
        /* [v6.4.0] 奖励卡片内滑块样式 - 更紧凑 */
        .habit-reward-card .reward-type-switch {
            margin: 0;
        }
        .habit-reward-card .reward-type-switch button {
            padding: 6px 10px;
            font-size: 0.8rem;
        }
        .btn-text-danger {
            background: none;
            border: none;
            color: var(--color-negative);
            font-size: 0.8rem;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* [v4.8.2] 修复下拉框在暗色模式下的显示 */
        select, option {
            background-color: var(--input-bg) !important;
            color: var(--text-color) !important;
        }
        
    </style>
    <!-- [v5.10.0] 在DOM渲染前立即应用主题，避免亮→暗闪烁 -->
    <script>
    (function() {
        var theme = localStorage.getItem('themePreference') || 'system';
        var isDark = theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);
        document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
    })();
    </script>
</head>
<body>
    <!-- [v5.0.0] 主滚动容器，解决过度滚动拉伸问题 -->
    <div class="app-scroll-container" id="appScrollContainer">
        <div class="header">
            <h1>时间银行</h1>
            <p>Time Bank v6.5.0</p>
        </div>

        <div class="main-container">

        <!-- [v5.10.0] 卡片堆叠系统 -->
        <div class="card-stack expanded" id="cardStack">
            <!-- 主卡片：时间余额 -->
            <div class="balance-card" id="balanceCard" onclick="showTodayDetails()">
                <div class="balance-title">当前余额</div>
                <div class="balance-amount" id="balanceAmount">0秒</div>
                <div class="daily-changes">
                    <div class="daily-change">今日获得: <span id="dailyEarned">0秒</span></div>
                    <div class="daily-change">今日消费: <span id="dailySpent">0秒</span></div>
                </div>
            </div>

            <!-- 堆叠卡片区域 -->
            <div class="stacked-cards-container" id="stackedCardsContainer">
                <!-- [v5.10.0] 统一屏幕时间卡片 - 共享header设计 -->
                <div class="screen-time-wrapper classic" id="screenTimeWrapper" onclick="handleScreenTimeCardClick(event)">
                    <!-- 共享header - 始终显示，点击可展开/收起 -->
                    <div class="screen-time-shared-header" id="screenTimeHeader">
                        <span class="st-icon">📱</span>
                        <span class="st-title">屏幕时间</span>
                        <span class="st-percent" id="screenTimePercent">0%</span>
                        <span class="st-arrow">▼</span>
                    </div>
                    <!-- 可展开的body -->
                    <div class="screen-time-expandable-body" id="screenTimeBody">
                        <div class="st-progress">
                            <div class="st-progress-bar" id="screenTimeProgressBar"></div>
                        </div>
                        <div class="st-stats">
                            <span id="screenTimeUsed">0分钟</span>
                            <span id="screenTimeLimit">/ 2小时</span>
                        </div>
                        <div class="st-footer" id="screenTimeFooter">
                            预计奖励: +0 分钟
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="demoCTA" class="demo-cta hidden">
            <div class="demo-cta-body">
                <div>
                    <div class="demo-cta-title">一键导入示例数据</div>
                    <div class="demo-cta-text">推荐新用户快速体验任务、日历和报表。</div>
                </div>
                <button class="data-btn" style="flex:0 0 auto; min-width:160px;" onclick="handleDemoCTAImport()">立即导入</button>
            </div>
        </div>

        <div class="tab-content active" id="earnTab">
            <div class="recent-tasks">
                <div class="section-title">最近任务</div>
                <div id="recentEarnTasks" class="recent-tasks-grid"></div>
            </div>
            
            <div class="section-title-container">
                <div class="section-title-group"><div class="section-title">全部任务</div><button class="info-button" id="allTasksInfoButton" aria-label="全部任务说明" onclick="showAllTasksInfoModal()">?</button></div>
                <button id="highlightHabitsButton" class="btn-highlight-habits-v2" onclick="highlightIncompleteHabits()">显示未完成习惯</button>
            </div>
            <div id="categoryEarnTasks"></div>
        </div>

        <div class="tab-content" id="spendTab">
            <div class="recent-tasks">
                <div class="section-title">最近任务</div>
                <div id="recentSpendTasks" class="recent-tasks-grid"></div>
            </div>
            
            <div class="section-title-container">
                <div class="section-title-group"><div class="section-title">全部任务</div><button class="info-button" id="allTasksInfoButtonSpend" aria-label="全部任务说明" onclick="showAllTasksInfoModal()">?</button></div>
            </div>
            <div id="categorySpendTasks"></div>
        </div>

        <div class="tab-content" id="reportTab">
            
                <div class="report-section" data-card-id="activityHeatmap" data-card-name="活动日历">
                      <div class="report-header">
                          <div class="report-title-group"><h2 class="report-title">活动日历</h2><button class="info-button" id="activityHeatmapInfoButton" aria-label="活动日历说明" onclick="showActivityHeatmapInfoModal()">?</button></div>
                          <div class="heatmap-nav">
                        <button id="heatmapPrevMonth">&lt;</button>
                        <span id="heatmapMonthLabel"></span>
                        <button id="heatmapNextMonth">&gt;</button>
                    </div>
                </div>
                <div class="heatmap-grid-wrapper">
                    <div class="heatmap-weekdays">
                        <span>日</span><span>一</span><span>二</span><span>三</span><span>四</span><span>五</span><span>六</span>
                    </div>
                    <div id="heatmapGrid" class="heatmap-grid"></div>
                </div>
                <div class="heatmap-legend" id="heatmapLegend"></div>
            </div>

            <div class="report-section" data-card-id="analysisDashboard" data-card-name="时间仪表盘">
                <div class="report-header">
                    <div class="report-title-group"><h2 class="report-title">时间仪表盘</h2><button class="info-button" id="analysisDashboardInfoButton" aria-label="时间仪表盘说明" onclick="showAnalysisDashboardInfoModal()">?</button></div>
                    <div class="report-filters" id="analysisDashboardFilters"></div>
                </div>
                <div id="analysisDashboard">
                    <div class="kpi-grid" id="kpiGrid"></div>
                    
                    <div class="report-section" id="interactiveAnalysisWrapper" style="padding: 0; box-shadow: none; background: transparent;">
                        <div class="report-header">
                            <h2 class="report-title" style="color: var(--text-color);">图表分析</h2>
                            <div class="analysis-view-switcher report-filters" id="analysisViewSwitcher">
                                <button class="active" onclick="setAnalysisView('category')">分类</button>
                                <button onclick="setAnalysisView('task')">任务</button>
                            </div>
                        </div>
                        <div id="pieChartContainerWrapper"></div>
                    </div>

                </div>
            </div>

            <div class="report-section" id="tableWrapper" data-card-id="dataTable" data-card-name="详细数据">
                <div class="report-header">
                    <div class="report-title-group"><h2 class="report-title">详细数据</h2><button class="info-button" id="tableInfoButton" aria-label="详细数据说明" onclick="showTableInfoModal()">?</button></div>
                </div>
                <div id="tableContainerWrapper"></div>
            </div>

            <div class="report-section" id="trendChartWrapper" data-card-id="trendChart" data-card-name="趋势演变">
                <div class="report-header">
                    <div class="report-title-group"><h2 class="report-title">趋势演变</h2><button class="info-button" id="trendInfoButton" aria-label="趋势演变说明" onclick="showTrendInfoModal()">?</button></div>
                </div>
                <div id="trendChartContainerWrapper"></div>
            </div>

        </div>

        <!-- 卡片管理器模态框 -->
        <div class="hidden" id="cardManagerModal" onclick="if(event.target===this)closeCardManager()">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title">自定义报告卡片</h3>
                    <button class="close-btn" onclick="closeCardManager()">×</button>
                </div>
                <div class="modal-body">
                    <p class="card-manager-hint">拖动调整顺序，点击开关控制显示</p>
                    <div id="cardManagerList" class="card-manager-list"></div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="resetCardLayout()">恢复默认</button>
                    <button class="btn btn-primary" onclick="closeCardManager()">完成</button>
                </div>
            </div>
        </div>

        <div class="tab-content" id="settingsTab">
            <div class="settings-section" id="syncSection">
                <div class="settings-title">数据同步</div>
                
                <div id="authStatusContainer" class="hidden">
                    <div id="authStatus" class="status-offline">未连接</div>
                    <button class="btn btn-danger" id="logoutButton" onclick="handleLogout()" style="width: 100%; margin-top: var(--space-lg);">退出登录</button>
                </div>

                <!-- [v6.6.0] CloudBase 用户名密码登录 -->
                <div id="authFormContainer">
                    <!-- 用户名登录表单 -->
                    <div id="usernameLoginForm">
                        <div class="form-group">
                            <label for="authUsername" class="form-label">👤 用户名</label>
                            <input type="text" id="authUsername" class="form-input" placeholder="输入用户名（字母开头，3位以上）">
                        </div>
                        <div class="form-group">
                            <label for="authPassword" class="form-label">🔒 密码</label>
                            <input type="password" id="authPassword" class="form-input" placeholder="输入密码（至少6位）">
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 12px;">
                            <button type="button" class="btn btn-primary" id="usernameLoginBtn" onclick="handleUsernameLogin()" style="flex: 1;">
                                登录
                            </button>
                            <button type="button" class="btn btn-secondary" id="usernameRegisterBtn" onclick="handleUsernameRegister()" style="flex: 1;">
                                注册
                            </button>
                        </div>
                        <p style="font-size: 11px; color: var(--text-color-light); text-align: center; margin-top: 8px;">
                            用户名需字母开头，只能包含字母、数字和下划线
                        </p>
                    </div>
                    
                    <!-- 分隔线 -->
                    <div style="display: flex; align-items: center; margin: 20px 0; color: var(--text-color-light);">
                        <div style="flex: 1; height: 1px; background: var(--border-color);"></div>
                        <span style="padding: 0 12px; font-size: 12px;">或者</span>
                        <div style="flex: 1; height: 1px; background: var(--border-color);"></div>
                    </div>
                    
                    <!-- 快速开始（匿名登录） -->
                    <button type="button" class="btn btn-secondary" id="startSyncButton" onclick="handleAnonymousLogin()" style="width: 100%;">
                        🚀 快速开始（免注册）
                    </button>
                    <p style="font-size: 11px; color: var(--text-color-light); text-align: center; margin-top: 8px;">
                        快速开始将创建临时账号，数据仅保存在当前浏览器
                    </p>
                    
                    <div class="error-message" id="authError" style="text-align: center; margin-top: var(--space-lg);"></div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">外观设置</div>
                <!-- [v6.2.0] 主题色设置 - 含画作主题 -->
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">主题</div>
                    </div>
                    <div class="setting-controls">
                        <div class="accent-selector" id="accentSelector">
                            <button class="accent-option active" data-accent="blue-purple" onclick="setAccentTheme('blue-purple')" title="蓝紫渐变"></button>
                            <button class="accent-option" data-accent="pink-white" onclick="setAccentTheme('pink-white')" title="粉白渐变"></button>
                            <button class="accent-option" data-accent="the-starry-night" onclick="setAccentTheme('the-starry-night')" title="星月夜"></button>
                            <button class="accent-option" data-accent="woman-with-a-parasol" onclick="setAccentTheme('woman-with-a-parasol')" title="撑阳伞的女人"></button>
                            <button class="accent-option" data-accent="almond-blossoms" onclick="setAccentTheme('almond-blossoms')" title="杏花盛开"></button>
                        </div>
                    </div>
                </div>
                <!-- [v6.2.0] 自定义背景设置 -->
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">自定义背景</div>
                        <div class="setting-desc">上传图片作为应用背景</div>
                    </div>
                    <div class="setting-controls">
                        <div class="bg-selector" id="bgSelector">
                            <label class="bg-option bg-upload" data-bg="custom" title="上传图片" onclick="document.getElementById('customBgInput').click();">
                                <span class="bg-label">上传图片</span>
                            </label>
                            <input id="customBgInput" type="file" accept="image/*" onchange="handleCustomBgUpload(event)" style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;">
                        </div>
                        <button class="bg-clear-btn hidden" id="bgClearBtn" onclick="clearCustomBackground()" title="清除自定义背景">✕</button>
                    </div>
                </div>
                <!-- [v6.0.0] 卡片样式统一设置 -->
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">卡片样式</div>
                    </div>
                    <div class="setting-controls">
                        <div class="style-switcher" id="globalCardStyleSwitcher">
                            <button class="style-btn active" data-style="classic" onclick="setCardStyle('classic')">经典</button>
                            <button class="style-btn" data-style="glass" onclick="setCardStyle('glass')">通透</button>
                        </div>
                    </div>
                </div>
                <!-- [v6.4.x] 通透强度调节 -->
                <div class="setting-item" id="glassStrengthSetting" style="display: none; align-items: stretch;">
                    <div class="setting-info" style="flex: 1; gap: 8px; align-items: center;">
                        <div class="setting-name">通透强度</div>
                        <div class="setting-desc" style="white-space: nowrap;">当前 <span id="glassStrengthValue">100%</span></div>
                    </div>
                    <div class="setting-controls" style="flex: 1; align-items: center;">
                        <input type="range" id="glassStrengthSlider" min="0" max="120" step="1" oninput="onGlassStrengthChange(this.value)" style="width: 100%;">
                    </div>
                </div>
                <div class="setting-item" id="glassBlurSetting" style="display: none; align-items: stretch; margin-top: -8px;">
                    <div class="setting-info" style="flex: 1; gap: 8px; align-items: center;">
                        <div class="setting-name">模糊强度</div>
                        <div class="setting-desc" style="white-space: nowrap;">当前 <span id="glassBlurValue">100%</span></div>
                    </div>
                    <div class="setting-controls" style="flex: 1; align-items: center;">
                        <input type="range" id="glassBlurSlider" min="0" max="120" step="1" oninput="onGlassBlurChange(this.value)" style="width: 100%;">
                    </div>
                </div>
                <!-- [v6.2.0] 夜间模式开关 -->
                <div class="setting-item" id="darkModeSettingItem">
                    <div class="setting-info">
                        <div class="setting-name">夜间模式</div>
                        <div class="setting-desc">启用暗色主题</div>
                    </div>
                    <div class="setting-controls">
                        <label class="switch">
                            <input type="checkbox" id="darkModeSwitch" onchange="toggleDarkMode(this.checked)">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <!-- [v6.2.0] 夜间模式跟随系统开关 -->
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">跟随系统</div>
                        <div class="setting-desc">夜间模式跟随系统设置自动切换</div>
                    </div>
                    <div class="setting-controls">
                        <label class="switch">
                            <input type="checkbox" id="systemModeSwitch" onchange="toggleSystemMode(this.checked)">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <div class="setting-item" onclick="openCardManager()" style="cursor: pointer;">
                    <div class="setting-info">
                        <div class="setting-name">自定义报告卡片</div>
                        <div class="setting-desc">调整报告页卡片的顺序和显示</div>
                    </div>
                    <div class="setting-controls">
                        <span style="color: var(--text-color-light); font-size: 1.2rem;">›</span>
                    </div>
                </div>
            </div>
            <div class="settings-section">
                <div class="settings-title">通知设置</div>
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">悬浮窗计时器</div>
                        <div class="setting-desc">统一开关，请在任务中单独设置</div>
                    </div>
                    <div class="setting-controls">
                        <label class="switch">
                            <input type="checkbox" id="floatingTimerToggle" onchange="toggleFloatingTimer()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">成就通知</div>
                        <div class="setting-desc">完成任务或达成目标时显示通知</div>
                    </div>
                    <div class="setting-controls">
                        <label class="switch">
                            <input type="checkbox" id="achievementNotificationToggle" onchange="toggleAchievementNotifications()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">长时间运行提醒</div>
                    </div>
                    <div class="setting-controls">
                        <input type="number" id="longRunningThreshold" class="threshold-input" 
                               value="3600" min="300" step="300" onchange="updateLongRunningThreshold()" 
                               placeholder="秒">
                        <label class="switch">
                            <input type="checkbox" id="longRunningNotificationToggle" onchange="toggleLongRunningNotifications()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">余额不足提醒</div>
                    </div>
                    <div class="setting-controls">
                        <input type="number" id="lowBalanceThreshold" class="threshold-input" 
                               value="1800" min="0" step="300" onchange="updateLowBalanceThreshold()" 
                               placeholder="秒">
                        <label class="switch">
                            <input type="checkbox" id="lowBalanceNotificationToggle" onchange="toggleLowBalanceNotifications()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">每日习惯提醒</div>
                    </div>
                    <div class="setting-controls">
                        <input type="time" id="habitNudgeTime" class="threshold-input" style="width: 80px;" onchange="updateHabitNudgeTime()">
                        <label class="switch">
                            <input type="checkbox" id="habitNudgeToggle" onchange="toggleHabitNudge()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">通知诊断</div>
                    </div>
                    <div class="setting-controls">
                        <button class="btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;" onclick="sendTestNotification()">发送测试通知</button>
                    </div>
                </div>
            </div>

            <!-- [v5.2.0] 屏幕时间管理 -->
            <div class="settings-section" id="screenTimeSection">
                <div class="settings-title" style="display: flex; align-items: center; gap: 6px;">屏幕时间管理<button class="info-button" id="screenTimeInfoButton" onclick="event.stopPropagation();showScreenTimeInfoModal()" aria-label="屏幕时间说明">?</button></div>
                
                <!-- 主开关 -->
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-name">启用屏幕时间管理</div>
                        <div class="setting-desc" id="screenTimeStatus">未启用</div>
                    </div>
                    <div class="setting-controls">
                        <label class="switch">
                            <input type="checkbox" id="screenTimeToggle" onchange="toggleScreenTimeManagement()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                
                <!-- 配置项（启用后显示） -->
                <div id="screenTimeSettings" class="hidden">
                    <!-- 每日限额 -->
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">每日限额</div>
                        </div>
                        <div class="setting-controls">
                            <input type="number" id="screenTimeLimitHours" class="threshold-input" 
                                   value="2" min="0" max="24" style="width: 50px;" 
                                   onchange="updateScreenTimeLimit()">
                            <span style="margin: 0 4px; color: var(--text-color-light);">时</span>
                            <input type="number" id="screenTimeLimitMinutes" class="threshold-input" 
                                   value="0" min="0" max="59" style="width: 50px;" 
                                   onchange="updateScreenTimeLimit()">
                            <span style="margin-left: 4px; color: var(--text-color-light);">分</span>
                        </div>
                    </div>
                    
                    <!-- 首页卡片开关 -->
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">首页显示卡片</div>
                            <div class="setting-desc">在首页展示实时进度</div>
                        </div>
                        <div class="setting-controls">
                            <label class="switch">
                                <input type="checkbox" id="screenTimeCardToggle" checked onchange="toggleScreenTimeCard()">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- 白名单管理 -->
                    <div class="setting-item" onclick="openScreenTimeWhitelist()" style="cursor: pointer;">
                        <div class="setting-info">
                            <div class="setting-name">白名单应用</div>
                            <div class="setting-desc" id="whitelistCount">0 个应用不计入使用时间</div>
                        </div>
                        <div class="setting-controls">
                            <span style="color: var(--text-color-light); font-size: 1.2rem;">›</span>
                        </div>
                    </div>
                    
                    <!-- [v5.10.0] 分类标签设置 -->
                    <div class="setting-item" style="flex-direction: column; align-items: flex-start; gap: 12px;">
                        <div class="setting-info" style="width: 100%;">
                            <div class="setting-name">分类标签</div>
                            <div class="setting-desc">设置节省/超出时间归属的分类</div>
                        </div>
                        <div style="display: flex; gap: 12px; width: 100%;">
                            <div style="flex: 1;">
                                <label style="font-size: 0.8rem; color: var(--text-color-light); margin-bottom: 4px; display: block;">🟢 节省时间</label>
                                <div class="custom-select-trigger category-select-trigger" id="screenTimeEarnCategoryTrigger" onclick="showCategorySelectModal('earn')" tabindex="0">选择分类</div>
                                <input type="hidden" id="screenTimeEarnCategory" value="">
                            </div>
                            <div style="flex: 1;">
                                <label style="font-size: 0.8rem; color: var(--text-color-light); margin-bottom: 4px; display: block;">🔴 超出时间</label>
                                <div class="custom-select-trigger category-select-trigger" id="screenTimeSpendCategoryTrigger" onclick="showCategorySelectModal('spend')" tabindex="0">选择分类</div>
                                <input type="hidden" id="screenTimeSpendCategory" value="">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">数据管理</div>
                <div class="data-buttons" id="data-btn-container">
                    <button class="data-btn" onclick="exportData()">导出数据</button>
                    <button class="data-btn" onclick="document.getElementById('importFile').click()">导入数据</button>
                    <button class="data-btn" onclick="clearAllData()">清空数据</button>
                </div>
                <input type="file" id="importFile" class="file-input" accept=".json" onchange="importData(event)">
                
                <!-- [v6.2.1] 云端数据诊断工具 -->
                <div style="margin-top: 12px;">
                    <button class="data-btn" onclick="showCloudSyncDiagnostics()" style="width: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">🔍 云端同步诊断</button>
                </div>
                
                <!-- [v6.0.0] 多表架构状态（新用户自动使用新架构，无需升级按钮） -->
                <div id="multiTableStatusContainer" style="margin-top: 12px; display: none;">
                    <div style="padding: 10px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 8px; color: #4CAF50; font-size: 13px;">
                        ✅ 多表架构已启用
                    </div>
                </div>
            </div>
            
            <div class="settings-section about-section">
                <div class="settings-title">关于</div>
                
                <!-- 
                  [AI CHANGELOG RULES]
                  1. Version Number: Designated by the USER at the START of an update cycle. Do NOT increment automatically.
                  2. Timing: Update historial records ONLY when the user indicates the update cycle is complete.
                  3. Content: 
                     - Record ONLY incremental features or fixes for issues from PREVIOUS versions.
                     - Do NOT record fixes for bugs introduced and fixed during the current update cycle.
                -->
                <!-- 📌 版本归档提醒：发布新版本时，将上一版本移至下方 <details> 历史版本区域 -->
                <div class="version-history-item">
                    <p><strong>版本 v6.4.2 (2026-01-08)</strong></p>
                    <ul>
                        <li><strong>[Fix]</strong> ☁️ <b>云端同步诊断</b>：写入并回显云端设备标识与更新时间，诊断弹窗不再显示“云端数据暂无设备记录”。</li>
                        <li><strong>[Fix]</strong> 🏷️ <b>版本号显示</b>：版本常量与关于页同步为 v6.4.2，保证与应用实际一致。</li>
                    </ul>
                </div>

                <details>
                    <summary>历史版本更新</summary>
                    <div class="version-history-container">
                        <div class="version-history-item">
                            <p><strong>版本 v6.4.1 (2026-01-07)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 🛡️ <b>戒除习惯限额计算修复</b>：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>限额判断和<b>任务卡片显示</b>现在都使用<b>实际使用时间</b>，而非被任务倍率和负余额惩罚影响后的消费时间</li>
                                        <li>新消费记录增加 <code>rawSeconds</code> 字段存储原始使用秒数</li>
                                        <li>对已有记录自动从描述文本解析实际使用时长</li>
                                    </ul>
                                </li>
                                <li><strong>[Fix]</strong> 🔥 <b>戒除习惯连胜修复</b>：修复了戒除习惯的 streak（连胜）被 UI 刷新意外重置为 0 的严重问题，现在连胜能正确累计并发放奖励</li>
                                <li><strong>[UI]</strong> 🌊 <b>云端同步诊断重构</b>：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>全新<b>直观对比视图</b>：云端/本地数据并排对比，差异项高亮显示</li>
                                        <li>通透模式优化：毛玻璃背景、入场动画、深色适配</li>
                                        <li>显示设备标识，帮助识别数据来源</li>
                                    </ul>
                                </li>
                                <li><strong>[Feat]</strong> ⬆️ <b>云端同步功能增强</b>：新增"本地→云端"强制推送功能</li>
                                <li><strong>[Feat]</strong> 📱 <b>多端冲突检测</b>：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>自动检测云端数据来自不同设备的情况</li>
                                        <li>仅在本地有运行中任务时才弹出冲突处理对话框</li>
                                        <li>美观的冲突对话框，显示运行中任务详情</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v6.4.0 (2026-01-07)</strong></p>
                            <ul>
                                <li><strong>[UI]</strong> 🎨 <b>下拉选择器重构</b>：全面替换原生下拉框为自定义组件
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li><b>任务类型</b>：改为全屏弹窗选择，含图标和描述说明</li>
                                        <li><b>习惯周期/时长</b>：改为毛玻璃下拉菜单，布局优化为同行显示</li>
                                        <li><b>奖励模式</b>：改为滑块切换（固定/递增）</li>
                                        <li><b>屏幕时间分类</b>：改为底部抽屉式选择弹窗</li>
                                    </ul>
                                </li>
                                <li><strong>[UI]</strong> 🌊 <b>通透模式适配</b>：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>下拉菜单深色毛玻璃效果，提升可读性</li>
                                        <li>滑块按钮样式优化，active状态正确显示</li>
                                        <li>输入框透明度统一（0.08）</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v6.3.0 (2026-01-06)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 📈 <b>时间流视图优化</b>：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>新增列表/流图快速切换功能 (<b>⇄</b>)</li>
                                        <li>优化流状图标题栏布局，移除冗余信息按钮</li>
                                        <li>流状图与标题栏无缝衔接，视觉更统一</li>
                                    </ul>
                                </li>
                                <li><strong>[UI]</strong> 🎨 <b>通透模式完善</b>：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li><b>按钮优化</b>：优化切换按钮在通透模式下的显示透明度与阴影</li>
                                        <li><b>文字修复</b>：修复详情表格文字颜色在通透模式下的可见性问题</li>
                                    </ul>
                                </li>
                                <li><strong>[Fix]</strong> 🛠️ <b>功能修复</b>：夜间模式跟随系统时自动隐藏手动开关，避免逻辑冲突</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v6.2.1 (2026-01-05)</strong></p>
                            <ul>
                                <li><strong>[Tool]</strong> 🔍 <b>云端同步诊断</b>：新增诊断工具（设置→数据管理）
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>实时查看云端与本地数据状态对比</li>
                                        <li>显示云端运行中任务、最近交易记录</li>
                                        <li>自动检测数据不一致并提示</li>
                                        <li>一键强制同步云端数据</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v6.2.0 (2026-01-05)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 🎨 <b>画作主题系统</b>：将背景升级为完整主题
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li><b>星月夜</b>：梵高《星夜》普鲁士蓝/钴蓝/铬黄配色</li>
                                        <li><b>撑阳伞的女人</b>：莫奈印象派天蓝/草绿/暖黄配色</li>
                                        <li>画作主题自动应用对应背景图与配色方案</li>
                                    </ul>
                                </li>
                                <li><strong>[Feat]</strong> 📷 <b>自定义背景上传</b>：支持上传本地图片作为背景</li>
                                <li><strong>[UI]</strong> 🧹 <b>设置页面恢复</b>：外观设置恢复独立项布局</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v6.1.0 (2026-01-05)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 🎨 <b>主题色系统升级</b>：主题色影响更多UI元素</li>
                            </ul>
                        </div>
                    <summary>历史版本更新</summary>
                    <div class="version-history-container">
                        <div class="version-history-item">
                            <p><strong>版本 v6.0.1 (2026-01-05)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 🔄 <b>多端同步修复</b>：修复安卓端结束任务后网页端仍显示计时的问题</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v6.0.0 (2026-01-05)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 🎨 <b>主题色系统</b>：支持切换应用主色调（蓝紫/粉白/青翠渐变）</li>
                                <li><strong>[Feat]</strong> 🖼️ <b>背景图片系统</b>：渐变色、星月夜、莫奈画作</li>
                                <li><strong>[Feat]</strong> ✨ <b>卡片样式系统</b>：经典/通透模式统一切换</li>
                                <li><strong>[UI]</strong> 🔮 <b>通透模式全面覆盖</b>：所有卡片、弹窗、报告页面统一玻璃质感</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v5.12.0 (2026-01-04)</strong></p>
                            <ul>
                                <li><strong>[Arch]</strong> 🏗️ <b>多表数据架构</b>：彻底解决多端同步冲突问题
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li><b>细粒度存储</b>：任务、交易、配置独立存储，修改单条不锁全部</li>
                                        <li><b>增量同步</b>：只传输变化的记录，不再全量覆盖</li>
                                        <li><b>实时订阅</b>：每张表独立 LiveQuery，精准推送变更</li>
                                        <li><b>5张新表</b>：TB_UserProfile, TB_Task, TB_Transaction, TB_RunningTask, TB_DailyChange</li>
                                    </ul>
                                </li>
                                <li><strong>[Clean]</strong> 🧹 精简数据管理工具，移除旧版修复按钮</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v5.11.0 (2026-01-04)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 📱 Android 桌面小组件（时间余额、屏幕时间经典/通透模式）</li>
                                <li><strong>[Feat]</strong> ✨ 屏幕时间卡片样式选择器（经典/通透模式）</li>
                                <li><strong>[Remove]</strong> 🗑️ 移除「提前结算今日」设置项</li>
                                <li><strong>[Fix]</strong> 修复自动检测补录时的函数调用错误</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v5.10.0 (2026-01-03)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 🏗️ <b>卡片堆叠系统</b>：时间余额卡片与屏幕时间卡片堆叠显示
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>收起状态：屏幕时间显示为简洁的堆叠标签，紧贴余额卡片底部</li>
                                        <li>展开状态：平滑展开为完整的独立卡片</li>
                                        <li>手势支持：上滑收起、下滑展开，状态自动记忆</li>
                                        <li>平滑动画：共享header设计，图标/标题/百分比始终在位，只有详情区域展开收起</li>
                                    </ul>
                                </li>
                                <li><strong>[Feat]</strong> 📱 <b>屏幕时间分类自定义</b>：屏幕时间结算可归属自定义分类
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>节省时间奖励：可选择归属「健康」「学习」等分类（默认为系统）</li>
                                        <li>超出时间扣除：可选择归属「娱乐」「浮费」等分类（默认为系统）</li>
                                        <li>分类迁移工具：修改设置后可一键迁移历史记录</li>
                                    </ul>
                                </li>
                                <li><strong>[UX]</strong> ✨ <b>弹窗动画统一</b>：所有点击弹窗添加弹性缩放动画，长按弹窗保持展开动画</li>
                                <li><strong>[Fix]</strong> 🌙 <b>主题闪烁修复</b>：夜间模式下应用启动不再出现亮→暗闪烁</li>
                                <li><strong>[Fix]</strong> 修复饼图分类显示：屏幕时间结算现在正确显示在自定义分类下</li>
                                <li><strong>[Fix]</strong> 修复分类详情列表：系统任务现在正确分组到对应分类</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v5.9.0 (2026-01-03)</strong></p>
                            <ul>
                                <li><strong>[Arch]</strong> 🏗️ <b>Event Sourcing 架构</b>：升级多端同步机制，解决并发冲突问题
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li><b>读取层</b>：可从事件日志重建完整状态</li>
                                        <li><b>写入层</b>：核心操作支持事件驱动写入</li>
                                        <li><b>同步层</b>：离线队列、冲突检测、实时事件同步</li>
                                    </ul>
                                </li>
                                <li><strong>[Feat]</strong> 离线事件队列：网络故障时事件自动缓存，恢复后批量上传</li>
                                <li><strong>[Feat]</strong> 冲突检测机制：检测5分钟内多端并发修改同一任务</li>
                                <li><strong>[Feat]</strong> 实时事件同步：通过 LiveQuery 订阅事件表，实时接收其他设备的操作</li>
                                <li><strong>[Feat]</strong> 网络恢复自动同步：监听 online 事件，自动上传离线队列并拉取远端事件</li>
                                <li><strong>[Tool]</strong> 新增"🔍 验证事件日志"诊断工具（设置→数据管理），对比快照与事件计算结果</li>
                                <li><strong>[Note]</strong> 当前默认关闭事件驱动模式 (USE_EVENT_SOURCING=false)，待验证通过后启用</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v5.8.1 (2026-01-02)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 🔴 <b>紧急修复</b>：彻底解决数据同步灾难性问题
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>新增严格版本号系统：每次保存版本+1，本地版本必须与云端一致才能保存</li>
                                        <li>修复乐观锁漏洞：当 lastCloudUpdateTime=0 时直接阻止保存</li>
                                        <li>空数据保护：禁止用空任务列表覆盖有数据的云端</li>
                                        <li>立即清除本地缓存：登录用户加载时先清除 localStorage</li>
                                        <li>LiveQuery 版本验证：拒绝接收低版本推送</li>
                                    </ul>
                                </li>
                                <li><strong>[Fix]</strong> 🔴 修复撤回任务后数据自动恢复的问题：移除过度保护的交易数量检查</li>
                                <li><strong>[Fix]</strong> 🔴 修复补记习惯任务不发放习惯连续奖励的问题：rebuildHabitStreak 现在会正确计算并补发遗漏的习惯奖励</li>
                                <li><strong>[Feat]</strong> 自动云端快照：每10个版本自动备份至 UserTimeBankSnapshot 表，保留最近10份</li>
                                <li><strong>[Feat]</strong> 事件日志系统（Phase 1）：静默记录所有操作事件至云端，为未来 Event Sourcing 架构做准备</li>
                                <li><strong>[Feat]</strong> 悬浮窗暂停同步：暂停任务时悬浮窗同步暂停显示（⏸图标+半透明）</li>
                                <li><strong>[Feat]</strong> 悬浮窗位置记忆：横屏和竖屏分别记忆上次拖动位置</li>
                                <li><strong>[UX]</strong> 白名单应用模态框优化：保存按钮右对齐，显示已选应用数量和名称</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v5.8.0 (2025-12-27)</strong></p>
                            <ul>
                                <li><strong>[Refactor]</strong> 时间流图重构：移除报告页独立卡片，整合至时间余额卡片详情中。</li>
                                <li><strong>[Feat]</strong> 多日时间流图：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>支持连续查看多天活动记录，向上滚动自动加载更早日期</li>
                                        <li>日期导航按日切换，自动滚动到目标日期位置</li>
                                        <li>0-8点折叠为单行显示，减少空白区域</li>
                                        <li>当前时间蓝色指示线，三角箭头标记</li>
                                        <li>日期分隔线标识每日边界</li>
                                    </ul>
                                </li>
                                <li><strong>[Fix]</strong> 修复自动检测补录使用当前任务乘数计算历史记录：改为从交易描述中解析实际时间，避免任务乘数变更后产生错误补录。</li>
                                <li><strong>[UX]</strong> 白名单应用模态框优化：保存按钮右对齐，显示已选应用数量和名称</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v5.7.0 (2025-12-26)</strong></p>
                            <ul>
                                <li><strong>[UX]</strong> 任务历史记录格式升级：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>采用两行布局：任务名称+图标在上，详情说明在下</li>
                                        <li>自动过滤撤销记录，列表更清晰</li>
                                    </ul>
                                </li>
                                <li><strong>[UI]</strong> 详细数据表格移动端适配：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>修复表头文字换行问题，添加 nowrap 约束</li>
                                        <li>任务视图固定列宽，排序时不再抖动</li>
                                        <li>优化单元格内边距，紧凑但不拥挤</li>
                                    </ul>
                                </li>
                                <li><strong>[Fix]</strong> 仪表盘修正交易计算：自动修正记录现在正确减少"已消耗/已获得"而非错误计入对方。</li>
                                <li><strong>[Fix]</strong> 饼图系统任务支持：屏幕时间管理等系统任务现在可正确显示tooltip明细。</li>
                                <li><strong>[Fix]</strong> 饼图边界检测增强：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>修复12点钟位置扇形无法触发tooltip的问题</li>
                                        <li>优化中心空白区域与外圈边界容差</li>
                                        <li>支持快速滑动跨越多个扇形边界</li>
                                        <li>从空白区域返回扇形时正确恢复状态</li>
                                        <li>饼图滑动阈值调整：从12px提升至20px，减少误触。</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.6.0 (2025-12-25)</strong></p>
                            <ul>
                                <li><strong>[重构]</strong> 自动补录系统全面升级：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>追溯多天：自动检测从上次检查日期到昨天的所有数据</li>
                                        <li>首次启用时自动追溯最近7天</li>
                                        <li>多记录修正：检测到记录超出实际使用时，自动扣减修正</li>
                                    </ul>
                                </li>
                                <li><strong>[简化]</strong> 移除"智能检测"功能，统一由自动补录系统处理。</li>
                                <li><strong>[UX]</strong> 任务菜单根据自动补录状态显示不同入口：<br>
                                    🤖 <strong>自动检测</strong> - 开启自动补录时，手动触发检测（检查最近7天）<br>
                                    📆 <strong>补录</strong> - 未开启自动补录时，手动补录入口</li>
                                <li><strong>[Core]</strong> 完善惩罚机制，区分消耗/获得类任务：<br>
                                    <strong>漏记录:</strong> 消耗类×1.2消耗 | 获得类×0.8获得<br>
                                    <strong>多记录:</strong> 消耗类×0.8返还 | 获得类×1.2扣减</li>
                                <li><strong>[Fix]</strong> 修复屏幕时间重复结算Bug：版本升级后可能产生重复扣费记录。</li>
                                <li><strong>[Tool]</strong> 新增"🔧 修复重复记录"工具（设置→数据管理），可自动检测并清理重复的屏幕时间记录。</li>
                                <li><strong>[UX]</strong> 活动日历详情页记录格式全面优化：
                                    <ul style="margin-top: 4px; padding-left: 20px;">
                                        <li>分离标题行与详情行，信息展示更清晰</li>
                                        <li>🎯达标 🤖补录 🔧修正 📱屏幕 ⚠️超支 等图标直观标识</li>
                                        <li>习惯奖励、达标奖励、负余额惩罚等格式统一规范</li>
                                        <li>屏幕时间详情改为"限额 - 实际 = 差额"格式</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.5.2 (2025-12-25)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 严重：修复自动检测补录从未执行的问题。</li>
                                <li><strong>[Feat]</strong> 漏记惩罚：自动补录时长按1.2倍收取。</li>
                                <li><strong>[UX]</strong> 倍率输入添加预设按钮。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.5.1 (2025-12-24)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 严重：修复云同步时 LiveQuery 更新被丢弃导致旧数据覆盖云端的问题。</li>
                                <li><strong>[Fix]</strong> 修复补记习惯任务时不发放习惯连续奖励的问题。</li>
                                <li><strong>[Feat]</strong> 习惯奖励修复工具：扫描并修复历史补记中遗漏的习惯奖励。</li>
                                <li><strong>[UX]</strong> 自动检测补录权限引导。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.5.0 (2025-12-23)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 手动检测补录：在补录弹窗中支持检测过去1-7天的应用使用时长，一键补录漏记的时间。</li>
                                <li><strong>[Feat]</strong> 屏幕时间详情升级：点击屏幕时间卡片显示Top 5应用使用详情及占比。</li>
                                <li><strong>[Feat]</strong> 趋势图分类全显示：分类视图下取消“其他”聚合，显示全部分类标签。</li>
                                <li><strong>[Feat]</strong> Android导出数据支持：添加原生文件保存接口，导出文件保存到Download文件夹。</li>
                                <li><strong>[Fix]</strong> 修复云同步冲突导致任务复活：结束任务后同步不再错误恢复已结束的任务。</li>
                                <li><strong>[Fix]</strong> 修复自动检测补录未触发：确保loadData完成后再执行自动检测。</li>
                                <li><strong>[UX]</strong> 精简记录描述格式：屏幕时间、检测补录记录采用统一简洁格式。</li>
                                <li><strong>[UX]</strong> 饼图弹窗透明度优化：长按弹窗背景更透明，不遮挡图表内容。</li>
                                <li><strong>[Chore]</strong> 移除数据修复工具：删除已完成使命的修复工具按钮。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.4.0 (2025-12-23)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 饼图长按外扩动画：长按饼图扇形时，扇形半径动态扩大，进入0.15s、退出0.8s丝滑过渡。</li>
                                <li><strong>[Fix]</strong> 修复热力图日历长按粘滞：移动端触摸后格子不再保持放大状态。</li>
                                <li><strong>[Fix]</strong> 修复移动端 :hover 粘滞问题：全部16处交互元素改用 @media (hover: hover) 媒体查询，移动端使用 :active 替代。</li>
                                <li><strong>[Fix]</strong> 修复云同步下载后本地新增交易丢失：智能合并只恢复本地新增数据，不恢复云端已删除数据。</li>
                                <li><strong>[Fix]</strong> 修复云同步后运行中任务状态丢失：同步后正确恢复本地正在运行的任务。</li>
                                <li><strong>[UX]</strong> 增强云同步可靠性：添加定期检查机制，解决 LiveQuery 可能不触发的问题。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.3.0 (2025-12-22)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 多悬浮窗计时器：支持多个任务同时显示悬浮窗计时器，达标任务始终显示在最上层。</li>
                                <li><strong>[Feat]</strong> 悬浮窗堆叠交互：收起时堆叠显示，长按展开/收起，拖动时所有悬浮窗一起移动。</li>
                                <li><strong>[Feat]</strong> Q弹展开动画：悬浮窗展开/收起时带有丝滑的弹性动画效果，竖屏垂直排列、横屏水平排列。</li>
                                <li><strong>[Feat]</strong> 应用时间自动检测补录：关联应用的任务可开启"自动检测补录"，系统会检测实际应用使用时长，自动补录未记录的时间。</li>
                                <li><strong>[Feat]</strong> 智能差异处理：漏记超过5分钟自动补录；多记超过5分钟发出通知提醒用户核对。</li>
                                <li><strong>[Feat]</strong> 检测报告弹窗：补录完成后显示详细报告，包含任务名称、实际使用时长、已记录时长、补录/多记时间。</li>
                                <li><strong>[UX]</strong> 自动检测说明按钮：任务编辑页自动检测补录旁添加说明按钮，支持"不再显示"。</li>
                                <li><strong>[UX]</strong> 屏幕时间卡片实时刷新：应用从后台切回时自动刷新，前台使用时每60秒自动刷新。</li>
                                <li><strong>[UX]</strong> 关联应用权限提示：开启关联应用时自动申请"使用情况访问权限"。</li>
                                <li><strong>[Fix]</strong> 修复趋势图长按弹窗滑动误触发图表切换问题：添加cooldown机制防止touchend误触发。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.1.0 (2025-12-21)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 时间仪表盘饼图长按弹窗：支持长按查看详细占比，拖动切换扇区，Q弹跟手动画效果，3秒后自动进入分类/任务详情。</li>
                                <li><strong>[Feat]</strong> 时间流图长按弹窗：仅在7天周期内生效，支持长按查看分类占比，拖动切换区块，3秒后进入分类详情。</li>
                                <li><strong>[Feat]</strong> 任务历史弹窗升级：合并日历与列表为统一滚动视图，点击日期可筛选当日记录，选中日期高亮显示。</li>
                                <li><strong>[Feat]</strong> 分类详情弹窗：点击仪表盘饼图分类或时间流图区块可查看分类下任务明细。</li>
                                <li><strong>[UX]</strong> 防误触优化：长按期间立即阻断页面滚动，滑动超阈值时自动恢复正常滚动，彻底解决长按拖动时页面滚动的问题。</li>
                                <li><strong>[UX]</strong> 周期筛选记忆：时间仪表盘的周期选择（7天/30天/全部）现在会自动记忆，下次进入保持上次选择。</li>
                                <li><strong>[UI]</strong> 视觉微调：饼图中心白色区域缩小13%（45%→39%），信息按钮尺寸优化，周期筛选器右对齐布局。</li>
                                <li><strong>[UI]</strong> 仪表盘标题简化："时间洞察仪表盘"更名为"时间仪表盘"，分类/任务切换按钮移至图表标题位置。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v5.0.0 (2025-12-21)</strong></p>
                            <ul>
                                <li><strong>[Core]</strong> 彻底修复移动端过度滚动拉伸问题：重构页面滚动架构，采用独立滚动容器，底部导航栏不再被拖动影响。</li>
                                <li><strong>[Feat]</strong> 任务卡片长按拖动排序：支持在分类内自由拖动任务卡片调整顺序，0.4s 丝滑动画反馈。</li>
                                <li><strong>[Feat]</strong> 活动日历长按弹窗升级：支持滑动切换日期查看详情，3秒后自动跳转详情页。</li>
                                <li><strong>[Feat]</strong> 趋势演变图长按弹窗：支持滑动切换日期查看当日明细。</li>
                                <li><strong>[UX]</strong> 分类任务折叠：每个分类最多显示 6 个任务，超出部分折叠，点击紧凑的倒三角按钮展开。</li>
                                <li><strong>[UX]</strong> 活动日历交互优化：修复长按色块时上下滑动误触页面滚动的问题，同时允许在日历区域左右滑动切换页签。</li>
                                <li><strong>[UI]</strong> 自定义报告卡片管理器样式优化：支持拖动排序和显示控制。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.14.0 (2025-12-20)</strong></p>
                            <ul>
                                <li><strong>[UX]</strong> 报表说明按钮全覆盖：流程图、活跃日历、分析总览、详细数据、趋势均支持说明弹窗与“不再显示”记忆，首次使用更清晰。</li>
                                <li><strong>[UX]</strong> 详细数据表新增“收起”按钮，全部展开后可一键恢复默认行数，翻阅长表更可控。</li>
                        <li><strong>[Stability]</strong> 统一遮罩与 Esc 关闭行为覆盖新增说明弹窗，减少残留弹窗的概率。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.13.0 (2025-12-20)</strong></p>
                            <ul>
                                <li><strong>[UX]</strong> 新增左右滑动切换页签，并设定阈值与报表图表交互区的免打扰保护，滑动与图表操作互不干扰。</li>
                                <li><strong>[UI]</strong> “分类任务”更名为“全部任务”，“互动分析”更名为“图表分析”。</li>
                                <li><strong>[Data]</strong> 内置应用词典扩充至上百款热门应用，智能直达匹配更准确。</li>
                                <li><strong>[Offline]</strong> Service Worker 离线回退与缓存策略加固，弱网/离线时加载更稳。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.12.0 (2025-12-19)</strong></p>
                            <ul>
                                <li><strong>[Security]</strong> 任务名称/分类渲染增加 HTML 转义，防止潜在自存型 XSS。</li>
                                <li><strong>[Stability]</strong> 任务重命名确认不再提前修改内存数据；取消时不影响原任务。</li>
                                <li><strong>[Notifications]</strong> 成就通知严格遵循开关；每日习惯提醒使用独立类型并尊重对应开关。</li>
                                <li><strong>[UX]</strong> 获得/消耗倍率留空默认 1，避免因未填倍率无法保存任务。</li>
                                <li><strong>[Infra]</strong> 新任务 ID 改用 UUID/随机后缀，减少快速创建时的碰撞风险。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.11.0 (2025-12-18)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 全能悬浮窗 (Universal Floating Timer)：支持所有持续类任务。达标任务显示倒计时，普通/消费任务显示正计时（秒表）。</li>
                                <li><strong>[UX]</strong> 达标反馈升级：倒计时结束后悬浮窗将显示“已达标”并停留 15 秒，解决立即消失导致的状态确认困难。</li>
                                <li><strong>[UI]</strong> 独立控制：在任务编辑页新增“悬浮窗计时器”独立开关，支持对每个任务进行个性化配置。</li>
                                <li><strong>[Fix]</strong> 修复了任务菜单在云端数据同步时偶发性闪退关闭的 Bug。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.10.0 (2025-12-18)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 新增“智能应用直达” (Smart App Launcher)：在任务开始或兑换时，可自动拉起关联的手机应用（如王者荣耀、微信、B站等）。</li>
                                <li><strong>[UX]</strong> 内置应用词典：配置任务时，输入应用名称即可自动匹配包名，亦支持手动输入包名。</li>
                                <li><strong>[UI]</strong> 视觉微调：优化了设置页面的间距与呼吸感，强化了开关与设置区域的关联性。</li>
                                <li><strong>[Refactor]</strong> 移除了“完成后自动删除”功能，简化任务管理逻辑。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.9.0 (2025-12-13)</strong></p>
                            <ul>
                                <li><strong>[Core]</strong> 同步引擎重构：修复了 LiveQuery 推送未更新版本凭证导致的"假性冲突死循环"。</li>
                                <li><strong>[Core]</strong> 冲突自愈机制：修复了强制覆盖云端数据后，因版本号未推进而导致的二次报错。</li>
                                <li><strong>[UX]</strong> 智能补录：现在当你在忙碌时（如连续打字/点击），云端推送会被暂时挂起，并在5秒后自动补拉取，既不打断操作也不丢失数据。</li>
                                <li><strong>[Fix]</strong> 完美解决了多端（手机/电脑）混合使用时的状态同步问题。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.8.7 (2025-12-11)</strong></p>
                            <ul>
                                <li><strong>[Security]</strong> 终极数据保护：引入"启动同步锁"机制。App 启动后，在成功拉取云端最新数据之前，严禁执行任何云端保存操作，彻底杜绝多端数据覆盖问题。</li>
                                <li><strong>[Android]</strong> 原生闹钟唤醒：任务开始时现在会注册系统级闹钟 (AlarmManager)，确保即使 App 在后台运行或被系统冻结，倒计时结束时也能准时收到通知。</li>
                                <li><strong>[Fix]</strong> 核心逻辑修复：修正了"戒除任务"在额度耗尽时错误显示"已达标"的问题；修复了"每日习惯提醒"因变量读取错误导致误判未完成的 Bug。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.8.6 (2025-12-10)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 戒除任务统计修复：修复了“习惯戒除”任务卡片上的“已用额度”不更新的问题（之前系统错误地忽略了消费记录）。</li>
                                <li><strong>[Core]</strong> 戒除结算重构：彻底重写了习惯戒除的结算逻辑。现在当周期结束且消费量未超标时，系统能正确判定成功、增加连胜并按规则发放奖励。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.8.5 (2025-12-09)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 逻辑修复：修正了“达标任务”在未达标仅点击完成时，也会错误显示“已达标”并计入习惯次数的 Bug。</li>
                                <li><strong>[Fix]</strong> 功能修复：修复了习惯递增奖励设置了上限却不生效（奖励仍无限增加）的问题。</li>
                                <li><strong>[UX]</strong> 体验优化：针对“习惯戒除”模式深度优化了界面文案（如“周期目标额度”），并自动隐藏不必要的设置项，创建更专注。</li>
                                <li><strong>[UI]</strong> 状态显示升级：戒除任务进度现在显示为“已用额度”以消除歧义；每日习惯新增“昨日已中断”红色警示，且今日一旦开始行动即自动消除警示。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.8.4 (2025-12-08)</strong></p>
                            <ul>
                                <li><strong>[UI]</strong> 细节打磨：进一步优化了创建任务页面的表单间距，视觉更紧凑。</li>
                                <li><strong>[UX]</strong> 便捷操作：为所有时间输入框增加了"45分"的快捷选项，填补了30分与60分之间的空白。</li>
                                <li><strong>[Fix]</strong> 文案修正：修复了部分输入框标签仍显示单位为"(秒)"的静态文本错误，统一为"(分)"。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.8.3 (2025-12-08)</strong></p>
                            <ul>
                                <li><strong>[UI]</strong> 布局精修：大幅压缩习惯设置区域的行间距，解决显示拥挤问题。</li>
                                <li><strong>[UX]</strong> 文案优化：戒除类任务的进度卡片现在显示为"已用额度"，避免产生"鼓励消费"的歧义。</li>
                                <li><strong>[Fix]</strong> 修正了"计时消费"任务创建时单位显示为"秒"的错误（实际应为分）。</li>
                                <li><strong>[Fix]</strong> 修复滚动穿透：在创建/编辑任务页面滑到边缘时，不再导致主页面背景跟随滑动。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.8.0 (2025-12-07)</strong></p>
                            <ul>
                                <li><strong>[New]</strong> 推出"习惯戒除"系统：针对消费类任务（如玩游戏、吸烟），支持开启戒除挑战。周期内控制消费在限额内即视为达标，获得连胜奖励。</li>
                                <li><strong>[UI]</strong> 习惯设置界面重构：全新的卡片式奖励设置，适配移动端操作，解决了输入框拥挤和提示文字显示不全的问题。</li>
                                <li><strong>[Core]</strong> 引入"补结算"机制：每次启动应用时自动检查昨日/上周的戒除成果，智能发放奖励。</li>
                                <li><strong>[UX]</strong> 优化交互逻辑：开启习惯时自动隐藏互斥选项，界面更清爽。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.7.3 (2025-12-05)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复悬浮窗闪现：点击"固定奖励"或"即时兑换"任务时，不再错误触发悬浮窗服务。</li>
                                <li><strong>[System]</strong> 优化开机自启：开机后会发送通知提示服务已启动，点击通知可立即检查错过的提醒。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v4.7.2 (2025-12-05)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 智能改名系统：修改任务名称时，会自动同步所有历史数据。若取消同步，则中止保存，防止数据割裂。</li>
                                <li><strong>[System]</strong> 强化开机自启：手机重启后应用将自动运行，并立即检查是否有错过的提醒通知。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.7.1 (2025-12-05)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复严重 Bug：点击"开始"后任务偶尔会自动取消或按钮消失。</li>
                                <li><strong>[Core]</strong> 引入"本地保护机制"：在操作后的短时间内优先信任本地状态，防止云端旧数据覆盖。</li>
                                <li><strong>[Fix]</strong> 解决悬浮窗与应用内状态不同步的问题。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.7.0 (2025-12-05)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复提醒逻辑：达标任务完成后，重新进入应用不再重复弹窗，彻底解决打扰问题。</li>
                                <li><strong>[Feat]</strong> 新增防遗忘提醒：达标任务完成 10 分钟后若未结束，将自动发送一次提醒。</li>
                                <li><strong>[UI]</strong> 界面精简：达标任务进度在完成后只显示 (√)，不再显示 100%，节省空间。</li>
                                <li><strong>[Build]</strong> 采用正式签名打包，解决安卓/鸿蒙系统无法安装的问题。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.6.2 (2025-12-04)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 彻底重构了"趋势演变图"的布局逻辑，使用 CSS Grid 强制等宽，解决了 30 天视图下显示不全和条形图宽度不一的问题。</li>
                                <li><strong>[UI]</strong> 优化了趋势图的时间轴显示：在 30 天视图下采用"隔日显示"策略（如 2, 4, 6...），解决了窄屏下双位数日期重叠拥挤的问题。</li>
                                <li><strong>[交互]</strong> 精简了趋势图交互：现在点击"无数据"的空闲日期柱子不再弹出空白提示框，保持体验纯净。</li>
                                <li><strong>[Fix]</strong> 修复了在报告页切换标签时，偶发性跳回旧标签的 Bug。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.6.0 (2025-12-02)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> (Android) 新增"悬浮窗计时器"功能。</li>
                                <li><strong>[Feat]</strong> (Android) 引入前台服务保活机制。</li>
                                <li><strong>[Fix]</strong> 优化多端同步逻辑。</li>
                            </ul>
                        </div>

			            <div class="version-history-item">
                    	    <p><strong>版本 v4.5.6 (2025-11-13)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (PWA) 修复了 `sw.js` 中缓存路径 `'/'` 导致的 PWA 在子目录（如 GitHub Pages）部署时安装失败的致命 Bug。现已修正为 `'./'`，确保 SW 能正确安装并激活通知功能。</li>
                                <li><strong>[Fix]</strong> (PWA) 将 `sw.js` 中 `notificationclick` 事件的 `openWindow('/')` 修正为 `openWindow('./')`，以匹配缓存路径。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.5.5 (2025-11-13)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (严重) 修复了 PWA <code>sw.js</code> 因缓存列表包含无法访问的文件 (<code>manifest.json</code>) 导致安装失败的 Bug。此 Bug 导致 `navigator.serviceWorker.ready` 无法激活，进而使所有通知功能（包括测试通知）全部静默失效。</li>
                                <li><strong>[Fix]</strong> 修复了“详细数据”表格的分页设置对老用户无效的问题。现在启动时将强制重置分页为 10 条，确保新设置生效。</li>
                                <li><strong>[Fix]</strong> 优化了“显示未完成习惯”高亮逻辑：现在将排除那些“今日已达上限”的习惯，避免造成误导。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.5.4 (2025-11-12)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (严重) 修复 PWA 注册路径及缓存列表路径，从绝对路径 <code>/time-bank/</code> 修正为相对路径 <code>sw.js</code> 和 <code>/</code>，解决根目录部署失败的问题。</li>
                                <li><strong>[Fix]</strong> (严重) 修复了“报告”页图表因 <code>LiveQuery</code> 和 <code>rAF</code> 冲突导致的UI高频闪烁的Bug。</li>
                                <li><strong>[Fix]</strong> (v4.5.3 遗留) 修复 <code>sw.js</code> 因引用不存在的文件 (<code>app.js</code>, <code>styles.css</code>) 导致 PWA 缓存安装失败的Bug。（此修复本应在 v4.5.4 完成，现合并至此）</li>
                                <li><strong>[Fix]</strong> 修复了“达标奖励”型习惯在未达标时停止，UI 也会错误显示为“已达标”的Bug。</li>
                                <li><strong>[Fix]</strong> 修复了“补记”功能：当补记日期为“今天”时，时间戳使用当前真实时间而非 12:00。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.5.3 (2025-11-09)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了"设置-通知设置-每日习惯提醒"在刷新页面后，开关和时间选择器UI状态被重置的 Bug。</li>
                                <li><strong>[Fix]</strong> 修复了暗色模式 (Dark Mode) 下，“报告”页的“活动日历”中浅色方块 (L1 浅红/浅绿) 上的日期数字因颜色过浅导致看不清的 Bug。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.5.2 (2025-11-08)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (严重) 修复了"互动分析"饼图高频闪烁问题，采用 `requestAnimationFrame` 优化渲染性能。</li>
                                <li><strong>[Fix]</strong> 修复了活动日历和任务日历在暗色模式下颜色逻辑反转（L1 最暗, L3 最亮）的 CSS Bug。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.5.1 (2025-11-08)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (严重) 修复了 v4.5.0 中历史弹窗滚动条逻辑，确保列表视图可滚动而日历视图不滚动。</li>
                                <li><strong>[Fix]</strong> (严重) 修复了 v4.5.0 中任务日历图例 (Legend) 颜色块不显示的 CSS Bug。</li>
                                <li><strong>[Feat]</strong> (v4.5.0) 增强“任务历史”弹窗，新增“列表/日历”视图切换功能。</li>
                                <li><strong>[Feat]</strong> (v4.5.0) “日历”视图可显示该任务在当月的每日执行情况（强度/次数）。</li>
                                <li><strong>[Feat]</strong> (v4.5.0) 颜色逻辑：次数型 (1/2/3+次)；时长型 (<1h/1-3h/>3h)，并区分获得(绿)/消费(红)。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.4.0 (2025-11-07)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 在“获得时间”页“分类任务”标题栏右侧新增“显示未完成习惯”按钮。</li>
                                <li><strong>[Feat]</strong> 点击该按钮将高亮所有未完成的习惯任务（红色边框），状态持续 30 分钟。</li>
                                <li><strong>[Fix]</strong> 修复了“达标奖励”类任务运行时，计时器文本 (xx%) 因过长而换行的问题（缩小字号 20%）。</li>
                                <li><strong>[Fix]</strong> 修复了已达标习惯任务卡片上的提示文本，移除括号和空格以防止换行。</li>
                            </ul>
                        </div>

                        <div class="version-history-item">
                            <p><strong>版本 v4.3.9 (2025-11-07)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (严重) 在 LiveQuery `on('update')` 回调中添加 `isSaving` 守卫。</li>
                                <li><strong>[Fix]</strong> 此守卫可防止在本地 `saveData()` 异步保存期间，传入的陈旧 LiveQuery 数据覆盖本地内存，从而彻底修复导致UI闪烁的竞态条件。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.3.8 (2025-11-07)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (严重) 修复了“每日习惯提醒”开启后，在提醒时间到达时，因异步竞态条件导致 `saveData()` 和 `updateAllUI()` 被每秒触发的 Bug (表现为UI高频闪烁)。</li>
                                <li><strong>[Fix]</strong> (严重) 移除了 v4.3.6 遗留的“缓存破坏”查询参数 (`notEqualTo('force_refresh', ...)`)。该 Bug 导致 `loadData` 始终绕过 SDK 缓存，强制发起网络请求。</li>
                                <li><strong>[Refactor]</strong> 重构了 `saveData` 函数，使其返回一个 Promise，以支持异步锁。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.3.7 (2025-11-07)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> (严重) 修复 v4.3.6 引入的回归 Bug (`LiveQuery not supported`)。</li>
                                <li><strong>[Fix]</strong> 根本原因：应用加载了 LeanCloud 基础版 SDK (`av-min.js`)，而不是包含 LiveQuery 功能的完整版。</li>
                                <li><strong>[Fix]</strong> 现已在 HTML Head 中将 SDK 源更改为 `av-live-query-min.js`，以正确启用实时同步功能。</li>
                                <li><strong>[Fix]</strong> (v4.3.6) 保留 `loadData` 中的“缓存破坏”策略 (`notEqualTo('force_refresh', ...)`)，以解决 v4.3.2 的多端数据覆盖问题。</li>
                                <li><strong>[Admin]</strong> (v4.3.6) 已按要求移除 v4.3.3, v4.3.4, v4.3.5 的错误版本历史，并将修复意图整合至此。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.3.2 (2025-11-05)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了 LiveQuery (实时同步) 更新UI时，因 `isSyncing` 标志导致渲染被阻止的 Bug (UI 冻结)。</li>
                                <li><strong>[Fix]</strong> 修复了 LiveQuery 仅更新内存数据而未更新 `cloudDataObject` 引用，导致后台计时器使用旧引用覆盖云端数据的严重 Bug (数据丢失)。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.3.1 (2025-11-04)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了 `rebuildHabitStreak` 函数中因 `new Date("YYYY-MM-DD")` 解析歧义导致的时区 Bug。</li>
                                <li><strong>[Fix]</strong> 该 Bug 导致在特定时区下，连续日期的 `diffDays` 计算错误，使得补记（如补记昨天）后 streak 无法正确连续计算。</li>
                                <li><strong>[Fix]</strong> 现在强制使用 `new Date(y, m, d)` 构造函数创建本地日期，确保日期比较的绝对可靠性。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.3.0 (2025-11-03)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 彻底重构“习惯补记”逻辑，引入“Streak 重建”机制。</li>
                                <li><strong>[Feat]</strong> 补记或撤回习惯任务后，将自动基于所有历史交易重建连续状态，确保在任何操作顺序下（先补记后完成、或先完成后补记）都能正确延续 Streak。</li>
                                <li><strong>[Fix]</strong> 修复了 v4.2.0 补记功能在特定顺序下（先完成今天再补记昨天）会导致 Streak 重置的严重 Bug。</li>
                                <li><strong>[Fix]</strong> 修正了“关于”页面版本日志的布局，确保 v4.2.0 及更早版本被正确折叠。</li>
                                <li><strong>[Feat]</strong> 补充 v3.2.1 - v3.6.3 的历史版本更新日志。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.2.1 (2025-11-02)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 补充 v1.0 - v3.0 的历史版本更新日志。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.2.0 (2025-11-01)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 扩展补记功能：支持“固定奖励”(Reward) 类任务（包括习惯）按“次数”进行补记。</li>
                                <li><strong>[Feat]</strong> 补记功能可修复习惯：补记“固定奖励”类习惯任务时，会自动重新计算历史连续状态 (Streak)，以挽回因忘记打卡导致的中断。</li>
                                <li><strong>[Fix]</strong> 修复习惯卡片UI逻辑：“今日已完成 ✅”标记现在仅在达到“每日完成上限” (Daily Limit) 时才显示，避免在可多次完成时产生误导。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.1.0 (2025-11-01)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 增加便捷操作，点击主界面的“时间余额卡片”可直接查看“今日详情”。</li>
                                <li><strong>[Fix]</strong> 彻底修复了 v4.0.5 遗留的 Bug：对于 N>1 的习惯（无论每日/每周），在未达标但“今天有完成”（如 1/5）时，会正确显示 `已完成 1/5 次`，而不是 `今日已完成 ✅`。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.G.5 (2025-11-01)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了 "每日" 且 "目标次数 > 1" 的习惯卡片错误显示为 "已连续X天" 的 Bug，现在会正确显示 "已完成 X/N 次" 进度 (如 "标准俯卧撑" 任务)。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.0.4 (2025-10-31)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 重构习惯卡片UI逻辑，所有类型习惯在当天完成后统一显示“今日已完成 ✅”。</li>
                                <li><strong>[Fix]</strong> 修复了周/月习惯在未完成时错误显示“已连续X天”的Bug (现在显示“已完成X/N次”)。</li>
                                <li><strong>[Fix]</strong> (v4.0.3) 每日习惯在中断后，卡片将显示“昨日已中断”状态，直到下次打卡。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.0.3 (2025-10-31)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 重构了习惯卡片UI逻辑，修复了周/月习惯在未达标时错误显示“已连续X天”的Bug。</li>
                                <li><strong>[Fix]</strong> 修复了周/月习惯卡片现在能正确显示“已完成 X/N 次”的进度。</li>
                                <li><strong>[Feat]</strong> 每日习惯在中断后，卡片将显示“昨日已中断”状态，直到下次打卡。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.0.2 (2025-10-31)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了 `sendTestNotification`（发送测试通知）按钮因错误检查设置而静默失败的 Bug。</li>
                                <li><strong>[Fix]</strong> 修复了登录后“数据管理”（导出/导入）模块被错误隐藏的 Bug。</li>
                                <li><strong>[Fix]</strong> 缩短了任务模态框中“周期目标次数”标签的文本，以防止在移动端换行破坏布局。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v4.0.0 (2025-10-31)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 架构升级：集成 LeanCloud BaaS 服务，实现多端数据实时同步。</li>
                                <li><strong>[Feat]</strong> 新增“数据同步”模块：支持用户注册、登录、退出。</li>
                                <li><strong>[Feat]</strong> 实现“云端优先”数据流：登录后，数据从云端实时读写，并自动同步到所有设备。</li>
                                <li><strong>[Feat]</strong> 实现“本地模式”：未登录时，应用保持原有功能，所有数据读写本地 `localStorage`。</li>
                                <li><strong>[Feat]</strong> 首次登录自动迁移：本地老用户在首次登录/注册后，数据将自动上传至云端。</li>
                                <li><strong>[Refactor]</strong> 重构 `loadData` 和 `saveData` 函数，以支持本地/云端两种模式的无缝切换。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v3.18.0 (2025-10-28)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 习惯任务新增“周期内目标次数”功能：支持设置每周/每月需要完成的次数 (N) 才能达标和触发连续性奖励。</li>
                                <li><strong>[Feat]</strong> 任务卡片UI更新：对于设置了目标次数 (N>1) 的习惯任务，显示进度“已完成 X/N 次”。</li>
                                <li><strong>[Fix]</strong> 修复并统一了所有习惯逻辑中对“周”的边界判断，周期始终为周一至周日。</li>
                                <li><strong>[Refactor]</strong> 优化了习惯达标逻辑，确保习惯奖励仅在周期内首次达成目标次数时触发，超额完成仅获得基础奖励。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v3.17.3 (2025-10-27)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了“循环提醒”功能因时区解析歧义导致提醒时间漂移的严重 Bug（例如 23:10 变为次日 7:10）。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.17.2 (2025-10-27)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了“关于”页面布局问题，现在默认只直接显示最新版本的更新日志，旧版本收纳于折叠区域内。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.17.1 (2025-10-27)</strong></p>
                            <ul>
                                <li><strong>[Fix]</strong> 修复了“循环提醒”功能的严重 Bug。该 Bug 导致在计算下一次提醒时间时，错误地将本地时间（如 22:00）转换为 UTC 时间（如次日 05:00），导致提醒时间“漂移”到错误的时间点。</li>
                                <li><strong>[UI]</strong> 调整了任务卡片上任务名称的 CSS，强制其不换行并限制最大宽度，避免长名称破坏布局。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.17.0 (2025-10-26)</strong></p>
                            <ul>
                                <li><strong>[Refactor]</strong> 重构“关于”页面布局，默认只展开最新版本日志。</li>
                                <li><strong>[Fix]</strong> 修正“按时长补记”时间戳，使用补记操作时刻而非固定值。</li>
                                <li><strong>[Feat]</strong> 为补记条目添加 🗓️ 标记，并在历史记录中显示。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.16.0 (2025-10-26)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 将余额为负时的惩罚倍率从 1.1 倍提高到 1.2 倍，并更新了所有相关提示。</li>
                                <li><strong>[优化]</strong> 提醒系统优化：如果任务（包括单次和习惯）在提醒触发前已被完成，则自动跳过该次通知。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.15.1 (2025-10-25)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 修复了“设置-数据管理”中“导入数据”功能点击后无反应的严重 Bug。该问题由 v3.15.0 中 <code>FileReader</code> 的方法名拼写错误 (<code>readText</code> 应为 <code>readAsText</code>) 导致。</li>
                            </ul>
                        </div>
                         <div class="version-history-item">
                            <p><strong>版本 v3.15.0 (2025-10-25)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 新增“未完成习惯提醒”：可在“设置-通知设置”中开启，在每天指定时间检查并提醒当天未完成的习惯任务。</li>
                                <li><strong>[功能]</strong> 新增“循环提醒”：在编辑习惯任务时，若设置了“具体时间”提醒，可额外开启“循环提醒”开关。开启后，提醒触发时会自动按习惯周期计算并设置下一次提醒时间。</li>
                            </ul>
                        </div>
                         <div class="version-history-item">
                            <p><strong>版本 v3.14.1 (2025-10-23)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 修复了“时间洞察仪表盘”筛选器在手机端换行后，右侧按钮组（“7天内”等）无法正确靠右对齐的CSS布局问题。</li>
                                <li><strong>[修复]</strong> 修复了“补记”功能：在补记“持续消耗”类任务时，会正确检测补记当日的历史余额，并在余额为负时应用 1.1 倍惩罚。</li>
                                <li><strong>[修复]</strong> 修复了“时间流图”筛选器按钮高亮状态与实际加载数据不一致的问题。</li>
                                <li><strong>[优化]</strong> 恢复了“互动分析”图表（饼图/排行）下方的分页小圆点指示器，并确保其固定在图表下方，不会随图表滑动。</li>
                            </ul>
                        </div>
                         <div class="version-history-item">
                            <p><strong>版本 v3.14.0 (2025-10-23)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 新增“设置提醒”系统：可为任务设置一次性提醒，支持“具体时间”和“倒计时”两种模式。提醒仅发送通知，不自动执行任务。</li>
                                <li><strong>[功能]</strong> 新增“完成后自动删除”选项：适用于一次性任务，在完成后会自动从列表中移除。此选项与“习惯任务”互斥。</li>
                                <li><strong>[优化]</strong> 优化了习惯任务卡片的UI：当天完成一次后，状态会从“已连续X天”变为“今日已完成 ✅”，提供更清晰的即时反馈。</li>
                            </ul>
                        </div>
                         <div class="version-history-item">
                            <p><strong>版本 v3.13.2 (2025-10-22)</strong></p>
                            <ul>
                                 <li><strong>[修复]</strong> 引入了数据安全备份与恢复机制，防止因浏览器意外关闭等原因导致数据损坏后无法加载的问题。现在应用会自动从上一次的有效备份中恢复。</li>
                                 <li><strong>[修复]</strong> 修正了 PWA 通知功能的逻辑，解决了点击“发送测试通知”时无反应的问题，并能在失败时提供明确的错误提示。</li>
                                 <li><strong>[修复]</strong> 修复了设置页面中，因版本历史的长文本未换行导致的页面水平溢出、布局偏移和底部导航栏不稳定的问题。</li>
                            </ul>
                        </div>
        
                        <div class="version-history-item">
                            <p><strong>版本 v3.13.1 (2m025-10-22)</strong></p>
                            <ul>
                                 <li><strong>[修复]</strong> 修复了在已注册 Service Worker 的 PWA 环境下，调用 <code>new Notification()</code> 构造函数会失败的问题。现在所有通知都通过 <code>ServiceWorkerRegistration.showNotification()</code> 正确触发，解决了“发送测试通知”功能失效的 Bug。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v3.13.0 (2025-10-22)</strong></p>
                            <ul>
                                 <li><strong>[功能]</strong> 调整了消费逻辑：当时间余额为负时，仍可进行“即时兑换”和“持续消耗”类任务。</li>
                                 <li><strong>[功能]</strong> 新增惩罚机制：当余额为负时执行上述消费任务，其实际消耗时间将按 1.1 倍计算。</li>
                            </ul>
                        </div>
        
                        <div class="version-history-item">
                            <p><strong>版本 v3.12.6 (2025-10-20)</strong></p>
                            <ul>
                                 <li><strong>[优化]</strong> 为所有任务卡片添加了 <code>2px</code> 的浅灰色内嵌边框 (<code>var(--border-color)</code>)，以解决“习惯任务”的彩色边框导致的视觉大小不一致问题。</li>
                                 <li><strong>[优化]</strong> 将所有卡片边框（包括习惯任务）的宽度从 <code>4px</code> 统一减少到 <code>2px</code>，使界面更精致。</li>
                            </ul>
                        </div>
                        
                        <div class="version-history-item">
                            <p><strong>版本 v3.12.5 (2025-10-20)</strong></p>
                            <ul>
                                 <li><strong>[优化]</strong> 优化了“习惯任务”卡片的视觉样式，将原有的左侧彩色竖线改为环绕整个卡片的内嵌彩色边框，同时确保不影响卡片布局或交互（通过 <code>box-shadow: inset</code> 和 <code>pointer-events: none</code> 实现）。</li>
                            </ul>
                        </div>
                       <div class="version-history-item">
                            <p><strong>版本 v3.12.4 (2025-10-20)</strong></p>
                            <ul>
                                 <li><strong>[修复]</strong> 修复了 v3.12.3 引入的一个严重布局问题：对仪表盘过滤器（“7天内”等按钮）的右对齐修改错误地影响了“详细数据”和“趋势演变”选项卡的过滤器布局。现已通过高特异性 CSS 规则修复此问题，确保修改只应用在“时间洞察仪表盘”。</li>
                                 <li><strong>[修复]</strong> 修复了核心 <code>formatTime()</code> 函数的逻辑，使其在小时为0、分钟和秒数均大于0时（如 "15分30秒"），能正确显示秒数。此修复影响“时间余额卡片”和“任务计时器”。</li>
                                 <li><strong>[优化]</strong> 调整了“时间流图”中条形图的间距，将底部空白减少了50% (16px -> 8px)，并将条间距减少了 33% (24px -> 16px)。</li>
                                 <li><strong>[优化]</strong> 调整了“时间洞察仪表盘”顶部的过滤器布局，使“7天内/30天内/全部”时段按钮组**真正**靠右对齐。</li>
                                 <li><strong>[优化]</strong> 将“设置”页面中各部分标题（如“外观设置”）与其下方第一项内容之间的间距缩短了50% (24px -> 12px)。</li>
                                 <li><strong>[优化]</strong> 将“详细数据”表格中的标题 "获得/消费" 修改为 "总时间"，"平均时间" 修改为 "平均"。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.12.2 (2025-10-19)</strong></p>
                            <ul>
                                 <li><strong>[优化]</strong> 进一步减少了“互动分析”图表下方的空白区域，使布局更紧凑。</li>
                                 <li><strong>[优化]</strong> 将“详细数据”表格中“平均时间”列的格式修改为 "xx.x小时"。</li>
                                 <li><strong>[优化]</strong> 再次缩短了“时间流图”中两个条形图之间的垂直间距。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.12.1 (2025-10-19)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 优化了“互动分析”中排行榜视图的高度，减少了内容较少时的底部空白。</li>
                                <li><strong>[修复]</strong> 移除了“互动分析”中饼图/排行榜下方的分页圆点指示器。</li>
                                <li><strong>[优化]</strong> 将“详细数据”表格中“获得/消费”列的时间格式改为以小时为单位（例如 "+1.5小时"）。</li>
                                <li><strong>[修复]</strong> 修复了“详细数据”表格右侧边框可能溢出的问题。</li>
                                <li><strong>[优化]</strong> 将“时间流动概览”卡片标题改回“时间流图”。</li>
                                <li><strong>[优化]</strong> 减小了“时间流图”中获得/消费两个条形图之间的间距。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.12.0 (2025-10-19)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 恢复并优化了“报告”选项卡中的“时间流动概览”图表，现在色块按活动块（同分类连续时段）的时间顺序排列，以体现时间流动性。</li>
                                <li><strong>[修复]</strong> 修复了“互动分析”中切换图表/排行视图时，顶部的分页圆点短暂跳动的问题。</li>
                                <li><strong>[移除]</strong> 移除了“报告”选项卡顶部的“总获得/总消费时间”统计卡片。</li>
                            </ul>
                        </div>
                         <div class="version-history-item">
                            <p><strong>版本 v3.11.3 (2025-10-19)</strong></p>
                            <ul>
                                <li><strong>[移除]</strong> 移除了“报告”选项卡中的“时间流图”卡片。</li>
                                <li><strong>[修复]</strong> 优化了“互动分析”模块的高度逻辑，修复了在“分类视图”下查看饼图时底部存在过多空白的问题，同时保留了切换视图时的防抖动效果。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.11.2 (2025-10-19)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 修复了“时间洞察仪表盘”中，切换“图表”和“排行”视图时，因容器高度折叠导致的页面布局跳动问题。</li>
                                <li><strong>[修复]</strong> 优化了报告中可滑动图表 (饼图/排行/趋势) 的触摸逻辑，解决了在移动端上下滚动页面时，容易误触导致图表左右切换的问题。</li>
                                <li><strong>[优化]</strong> 重构了“关于”页面的版本历史结构，将最新版本置顶显示，并将所有旧版本移入可折叠的“历史版本更新”区域，以保持界面整洁。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.11.1 (2025-10-19)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 修复了“互动分析”中“任务视图”下的饼图可能显示超过5个任务的问题，现在严格按照Top 5 + 其他进行分组。</li>
                                <li><strong>[优化]</strong> 确保“数据管理”中的导出/导入/清空按钮始终在同一行显示，防止在小屏幕上换行。</li>
                                <li><strong>[优化]</strong> 简化了“通知诊断”设置项的界面，移除了描述和提示文字。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.11.0 (2025-10-19)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 新增“补记”功能：可在持续类任务的“更多”菜单中，为过去日期补录记录（支持按起止时间或按时长）。</li>
                                <li><strong>[修复]</strong> 修复了在分类任务列表中启动任务后，该任务卡片的计时器不更新、菜单无法打开的问题。</li>
                                <li><strong>[优化]</strong> 调整了饼图在“分类视图”下的标签格式，改为三行显示（分类名/百分比/时长）。</li>
                                <li><strong>[优化]</strong> 优化了习惯任务卡片的左侧彩色边框实现方式，避免卡片内容向右偏移。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.10.5 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 修复了一个 v3.10.4 引入的严重Bug：由于函数名拼写错误 (<code>getItemNameAndVategory</code>)，导致“时间洞察仪表盘”、“详细数据”和“趋势演变”模块的数据无法加载，图表消失。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.10.4 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 分类视图下的扇形图标签现在会同时显示百分比、时长和分类名。</li>
                                <li><strong>[优化]</strong> 扇形图时长格式优化：1小时内仅显示分钟数（例如 45分）。</li>
                                <li><strong>[优化]</strong> 调亮了图表（扇形图、排行榜）中“其他”类别的灰色，使其更柔和。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.10.3 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 彻底修复了排行榜短进度条下时间标签换行的问题。</li>
                                <li><strong>[优化]</strong> 优化了“分类视图”下排行榜的布局，使其在短标签下更美观。</li>
                                <li><strong>[优化]</strong> 优化了扇形图标签的定位，使其位于扇形区域的视觉中心。</li>
                                <li><strong>[功能]</strong> “任务视图”下的扇形图标签现在会同时显示百分比和时间长度。</li>
                                <li><strong>[功能]</strong> “分类视图”下的扇形图会直接显示分类名，不再使用图例。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.10.2 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 移除了饼图的外部引导线和标签，改为使用图例，以解决在移动设备上的显示问题。</li>
                                <li><strong>[功能]</strong> 饼图扇形内部新增百分比显示，提升数据可读性。</li>
                                <li><strong>[优化]</strong> 统一了排行榜中时间数值的字体样式（白色带阴好）。</li>
                                <li><strong>[优化]</strong> 调整了短进度条的排行榜标签，使其始终显示在进度条内部左侧。</li>
<li><strong>[优化]</strong> 针对“分类视图”下的排行榜，调整了布局以减少左侧空白，此优化不影响“任务视图”。</li>
                            </ul>
                        </div>
                         <div class="version-history-item">
                            <p><strong>版本 v3.10.1 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 饼图引导线从直线改为折线（SVG实现），解决了标签重叠和指向不准的问题。</li>
                                <li><strong>[优化]</strong> 将报告中“任务视图”下的“获得”颜色体系从蓝绿色系调整为更统一的绿色渐变系。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 vs3.10.0 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 彻底重构了饼图标签的实现方式，从 Canvas 绘图改为使用 HTML 元素，解决了标签显示不全、模糊、重叠的问题。</li>
                                <li><strong>[功能]</strong> 新增任务视图下的颜色标准化。</li>
                                <li><strong>[优化]</strong> 优化了饼图标签的排布逻辑，以避免相互遮挡。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                             <p><strong>版本 v3.9.6 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 修复了消费饼图错误地将某些分类归入“其他”的问题。</li>
                                <li><strong>[优化]</strong> 饼图改为使用引出线标注。</li>
                                <li><strong>[优化]</strong> 调整了排行榜的布局。</li>
                                <li><strong>[优化]</strong> 详细数据表新增“展开/折叠”功能。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.9.5 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 新增互动分析模块，支持在“图表视图”和“排行视图”之间切换。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.9.0 (2025-10-18)</strong></p>
                            <ul>
                                <li><strong>[功能]</strong> 趋势图重构为左右滑动切换。</li>
                                <li><strong>[功能]</strong> 新增通知诊断功能。</li>
                            </ul>
                        </div>
                       <div class="version-history-item">
                            <p><strong>版本 v3.8.2 (2025-10-17)</strong></p>
                             <ul>
                                 <li><strong>[修复]</strong> 修正 <code>formatTime</code> 函数逻辑。</li>
                             </ul>
                         </div>

                        <div class="version-history-item">
                            <p><strong>版本 v3.6.3 (2025-10-16)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 重构了活动日历的颜色计算逻辑，并采用更可靠的日期格式化方法，彻底解决了日历方块颜色不显示的问题。</li>
                                <li><strong>[修复]</strong> 统一了应用内所有功能的日期处理方式，确保数据在任何时区下都能准确地归属到正确的本地日期。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.6.2 (2025-10-16)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 修复了活动日历因时区处理不当导致的数据归属错误，确保了交易记录显示在正确的本地日期下。</li>
                                <li><strong>[修复]</strong> 纠正了每日详情弹窗的数据筛选逻辑，使其与日历的本地日期保持一致，解决了数据显示混淆的问题。</li>
                                <li><strong>[UI]</strong> 优化了“关于”页面中版本历史的结构，以支持长期记录所有更新信息。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.6.1 (2025-10-16)</strong></p>
                            <ul>
                                <li><strong>[修复]</strong> 为报告页面的卡片增加了顶部外边距，解决了与上方元素过于贴近的问题。</li>
                                <li><strong>[修复]</strong> 修正了“深度分析”表格中，任务平均时间因不当取整而显示为0的问题。</li>
                                <li><strong>[优化]</strong> 重构了时间格式化函数，使其在各种情况下都能更准确、稳定地显示时间。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.6.0 (2025-10-16)</strong></p>
                            <ul>
                                <li><strong>[UI] 界面风格调整:</strong> 整体UI风格参照早期经典版本进行焕新，恢复蓝紫色渐变背景和经典色调。</li>
                                <li><strong>[UI] 布局优化:</strong> 调整了任务卡片区域的边距，使其与余额卡片对齐；并确保任务卡片在手机上始终为双列显示。</li>
                                <li><strong>[UI] 报告页精简:</strong> 移除总任务数和完成次数统计，使核心指标（总获得/消耗时间）更突出，并调整为单行显示。</li>
                                <li><strong>[优化] 时间格式:</strong> 优化了余额和报告页的时间显示，当超过1小时后，将自动隐藏秒数，使阅读更清晰。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.5.1 (22025-10-16)</strong></p>
                            <ul>
                                <li><strong>[修复] 代码库稳定：</strong>移除了所有重复的JavaScript代码，解决了UI渲染失败和执行错误的问题。</li>
                                <li><strong>[修复] 数据兼容性：</strong>修正后的代码现在可以正确加载并迁移所有先前版本的数据。</li>
                                <li><strong>[保留] 功能完整：</strong>v3.5.0版本的所有功能（交互式日历、颜色梯度、完整版本历史）现在均可正常工作。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.5.0 (2025-10-16)</strong></p>
                            <ul>
                                <li><strong>[新功能] 交互式活动日历：</strong>点击日历上的任意日期，可以弹窗查看当日所有的时间收支详情。</li>
                                <li><strong>[UI] 日历视觉重构：</strong>活动日历的颜色不再是简单的指示条，而是整个色块。根据当日净收支，分为6个等级的红/绿色阶，视觉冲击力更强。</li>
                                <li><strong>[修复] 恢复完整版本历史：</strong>根据您的要求，已在“关于”页面中恢复并整理了所有历史版本的更新日志。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.4.2 (2025-10-16)</strong></p>
                            <ul>
                                <li><strong>[新功能] 自由颜色选择：</strong>创建或编辑任务时，可从16种预设颜色中为分类自由指定颜色。</li>
                                <li><strong>[优化] 随机颜色分配：</strong>若不指定颜色，系统会自动从可用颜色中随机选择。</li>
                                <li><strong>[UI] 标签颜色调优：</strong>引入两套全新的、更具高级感和区分度的色板。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.4.1 (2025-10-16)</strong></p>
                            <ul>
                                <li><strong>[修复] 历史标签颜色：</strong>自动修正历史任务的标签颜色。</li>
                                <li><strong>[优化] 标签颜色多样性：</strong>同一类型下的不同分类标签颜色不同。</li>
                                <li><strong>[新功能] 智能标签推荐：</strong>根据任务类型推荐常用标签。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.4.0 (2025-10-15)</strong></p>
                            <ul>
                                <li><strong>[UI] 色彩系统重构：</strong>全面更新应用色彩方案，提升视觉专业性和信息区分度。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.3.2 (22025-10-15)</strong></p>
                            <ul>
                                <li><strong>[修复] 报告页：</strong>彻底修复了活动日历布局混乱的问题，现在可以按月正确显示。</li>
                                <li><strong>[修复] 习惯系统：</strong>修复了首次完成习惯时计数不从1开始的问题。</li>
                                <li><strong>[修复] 最近任务：</strong>确保所有类型的任务完成后都能立即出现在“最近任务”列表中。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.3.1 (2025-10-15)</strong></p>
                            <ul>
                                <li><strong>[修复] 习惯系统增强：</strong>修复了习惯任务完成/撤回时连续天数状态更新不正确、不及时、可被利用的多个bug。</li>
                                <li><strong>[新功能] 习惯每日上限：</strong>现在可以为每个习惯任务设置每日完成次数上限，默认为1次。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v3.2.1 (2025-10-15)</strong></p>
                            <ul>
                                <li><strong>[优化]</strong> 为活动日历热图增加颜色图例，使其更易理解。</li>
                                <li><strong>[优化]</strong> 深度分析表格“按分类”视图合并收支为“净值”，并用颜色区分。</li>
                                <li><strong>[新功能]</strong> 深度分析表格增加“占比”列，显示各项目对总收支的贡献度。</li>
                            </ul>
                        </div>

                         <div class="version-history-item">
                            <p><strong>版本 v3.0</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> (重大功能) 新增“习惯任务”(Habit) 类型，支持连续打卡。</li>
                                <li><strong>[Feat]</strong> 习惯任务支持设置周期 (日/周/月)、时长及多种奖励规则（如固定奖励、递增奖励）。</li>
                                <li><strong>[Feat]</strong> 习惯任务卡片现在可以显示连续打卡 (Streak) 状态和徽章。</li>
                                <li><strong>[Feat]</strong> 重构设置 (Settings) 页面UI，改为更现代的列表样式。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v2.9</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 在任务历史记录中增加“撤回”(Undo)功能，可以撤销单条操作。</li>
                                <li><strong>[Feat]</strong> 新增“跟随系统”主题选项 (Auto Dark Mode)。</li>
                                <li><strong>[Feat]</strong> 在设置页面添加版本更新日志功能 (<code>&lt;details&gt;</code> 标签)。</li>
                                <li><strong>[Fix]</strong> 优化了运行中任务的操作按钮布局 (Pause/Cancel/Stop)，使其更紧凑。</li>
                                <li><strong>[Fix]</strong> 取消正在运行的任务不再需要二次确认。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v2.8</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> (重大功能) 实现了计时器持久化。现在刷新页面后，正在运行的任务计时器可以被恢复。</li>
                                <li><strong>[Feat]</strong> saveData 现在会保存 runningTasks 的状态，loadData 会在启动时恢复这些任务。</li>
                                <li><strong>[Fix]</strong> 优化了移动端任务卡片的布局和按钮触摸体验。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v2.5</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 新增“任务历史记录”查看功能（点击任务卡片上的 "📋" 图标或 "历史" 按钮）。</li>
                                <li><strong>[Feat]</strong> 新增“任务完成次数” (Completion Count) 统计，并显示在任务卡片上。</li>
                                <li><strong>[Feat]</strong> 优化分类管理，支持折叠/展开分类任务列表。</li>
                                <li><strong>[Feat]</strong> 新增“设置”页面，包含多种通知开关 (成就、长时间运行、余额不足、不活跃任务)。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v2.4</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> (重大功能) 持续任务新增“暂停”(Pause) 和“继续”(Resume) 功能。</li>
                                <li><strong>[Feat]</strong> 重新设计了余额卡片，增加了“今日获得”、“今日消耗”和“运行中”任务的统计显示。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v2.3</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> (重大重构) 引入了强大的数据迁移系统，以确保旧版本数据（v1.0, v2.0, v2.1, v2.2）能安全升级到新版本。</li>
                                <li><strong>[Feat]</strong> 导入数据时会进行智能版本检测和数据验证。</li>
                                <li><strong>[Feat]</strong> 新增数据迁移失败时的“自动备份”和“回滚”机制，以保障数据安全。</li>
                                <li><strong>[Feat]</strong> 新增“自定义提醒”功能，允许为任务设置特定时间或相对时间的提醒。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v2.0 (基于 Tailwind 的原型)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> (重大重构) 应用UI从简单列表重构为现代PWA风格 (底部标签栏、悬浮按钮、卡片式布局)。</li>
                                <li><strong>[Feat]</strong> 新增“获得时间”和“消费时间”两个主标签页。</li>
                                <li><strong>[Feat]</strong> 新增“最近任务”和“所有任务”（按分类）的视图。</li>
                                <li><strong>[Feat]</strong> 任务分类支持折叠/展开。</li>
                                <li><strong>[Feat]</strong> 新增“报告”标签页，包含数据概览（总获得/总消费等）。</li>
                                <li><strong>[Feat]</strong> 新增“数据管理”功能 (导入/导出数据, 清除数据)。</li>
                            </ul>
                        </div>
                        <div class="version-history-item">
                            <p><strong>版本 v1.0 (基础原型)</strong></p>
                            <ul>
                                <li><strong>[Feat]</strong> 实现了应用的核心概念：时间余额 (currentBalance)。</li>
                                <li><strong>[Feat]</strong> 实现了四种基础任务类型：奖励 (Reward)、持续 (Continuous)、即时兑换 (Instant Exchange)、持续兑换 (Continuous Exchange)。</li>
                                <li><strong>[Feat]</strong> 实现了任务的创建、删除和执行（开始/停止/完成）。</li>
                                <li><strong>[Feat]</strong> 实现了交易历史记录和基础的报告功能。</li>
                            </ul>
                        </div>
                         </div>
                </details>
            </div>
        </div>
    </div>
    </div><!-- 关闭 app-scroll-container -->

    <button class="fab" id="fabButton" onclick="showTaskModal()">+</button>

    <div class="bottom-tabs">
        <button class="tab-button active" data-tab="earn" onclick="switchTab('earn', event)"> <div class="tab-icon">⏰</div> <div>获得时间</div> </button>
        <button class="tab-button" data-tab="spend" onclick="switchTab('spend', event)"> <div class="tab-icon">🎯</div> <div>消费时间</div> </button>
        <button class="tab-button" data-tab="report" onclick="switchTab('report', event)"> <div class="tab-icon">📊</div> <div>报告</div> </button>
        <button class="tab-button" data-tab="settings" onclick="switchTab('settings', event)"> <div class="tab-icon">⚙️</div> <div>设置</div> </button>
    </div>

    <!-- [v6.4.0] 任务类型选择弹窗 -->
    <div class="modal" id="taskTypeModal">
        <div class="modal-content" style="max-width: 360px;">
            <div class="modal-header">
                <div class="modal-title">选择任务类型</div>
                <button class="close-btn" onclick="hideTaskTypeModal()">×</button>
            </div>
            <div class="task-type-section">
                <div class="task-type-group-label">🟢 获得时间 (Earn)</div>
                <div class="task-type-option" data-value="reward" onclick="selectTaskType(this)">
                    <div class="task-type-option-icon">🎯</div>
                    <div class="task-type-option-info">
                        <div class="task-type-option-name">按次任务</div>
                        <div class="task-type-option-desc">完成一次获得固定时间</div>
                    </div>
                </div>
                <div class="task-type-option" data-value="continuous" onclick="selectTaskType(this)">
                    <div class="task-type-option-icon">⏱️</div>
                    <div class="task-type-option-info">
                        <div class="task-type-option-name">计时任务</div>
                        <div class="task-type-option-desc">按实际时长×倍率获得时间</div>
                    </div>
                </div>
                <div class="task-type-option" data-value="continuous_target" onclick="selectTaskType(this)">
                    <div class="task-type-option-icon">🏆</div>
                    <div class="task-type-option-info">
                        <div class="task-type-option-name">达标任务</div>
                        <div class="task-type-option-desc">达到目标时长后获得奖励</div>
                    </div>
                </div>
            </div>
            <div class="task-type-section">
                <div class="task-type-group-label">🔴 消费时间 (Spend)</div>
                <div class="task-type-option" data-value="instant_redeem" onclick="selectTaskType(this)">
                    <div class="task-type-option-icon">💳</div>
                    <div class="task-type-option-info">
                        <div class="task-type-option-name">按次消费</div>
                        <div class="task-type-option-desc">兑换一次消费固定时间</div>
                    </div>
                </div>
                <div class="task-type-option" data-value="continuous_redeem" onclick="selectTaskType(this)">
                    <div class="task-type-option-icon">⏳</div>
                    <div class="task-type-option-info">
                        <div class="task-type-option-name">计时消费</div>
                        <div class="task-type-option-desc">按实际时长×倍率消费时间</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- [v6.4.0] 分类选择弹窗（底部抽屉式） -->
    <div class="modal bottom-sheet-modal" id="categorySelectModal">
        <div class="bottom-sheet-content">
            <div class="bottom-sheet-header">
                <div class="bottom-sheet-handle"></div>
                <div class="bottom-sheet-title" id="categorySelectModalTitle">选择分类</div>
            </div>
            <div class="bottom-sheet-body" id="categorySelectModalBody">
                <!-- 动态生成分类列表 -->
            </div>
        </div>
    </div>

    <div class="modal" id="taskModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="modalTitle">创建新任务</div>
                <button class="close-btn" onclick="hideTaskModal()">×</button>
            </div>
            <form id="taskForm" onsubmit="saveTask(event)">
                 <div class="form-group"> <label class="form-label">任务名称 *</label> <input type="text" id="taskName" class="form-input" placeholder="输入任务名称" required> <div class="error-message" id="taskNameError"></div> </div>
                 <div class="form-group"> <label class="form-label">任务类型 *</label> 
                    <div class="custom-select-trigger" id="taskTypeTrigger" onclick="showTaskTypeModal()" tabindex="0">请选择任务类型</div>
                    <input type="hidden" id="taskType" value="" required>
                    <div class="error-message" id="taskTypeError"></div> 
                 </div>
                 <div class="form-group"> <label class="form-label">任务分类 *</label> <input type="text" id="taskCategory" class="form-input" placeholder="输入分类名称" required> <div class="recommendations" id="categoryRecommendations"></div> <div class="error-message" id="taskCategoryError"></div> </div>
                 <div class="form-group hidden" id="colorSelectorContainer"> <label class="form-label">分类颜色 (自动匹配)</label> <div id="earnColorSelector" class="color-selector hidden"></div> <div id="spendColorSelector" class="color-selector hidden"></div> </div>
                 <div class="form-group hidden" id="fixedTimeGroup"> <label class="form-label" id="fixedTimeLabel">奖励时间 (分) *</label> <input type="text" id="fixedTime" class="form-input" placeholder="例如：1800"> <div class="time-presets"> <div class="time-preset" onclick="setTimePreset('fixedTime', 15)">15分</div> <div class="time-preset" onclick="setTimePreset('fixedTime', 30)">30分</div> <div class="time-preset" onclick="setTimePreset('fixedTime', 45)">45分</div> <div class="time-preset" onclick="setTimePreset('fixedTime', 60)">60分</div> </div> <div class="error-message" id="fixedTimeError"></div> </div>
                 <div class="form-group hidden" id="consumeTimeGroup"> <label class="form-label">消费时间 (分) *</label> <input type="text" id="consumeTime" class="form-input" placeholder="例如：1800"> <div class="time-presets"> <div class="time-preset" onclick="setTimePreset('consumeTime', 15)">15分</div> <div class="time-preset" onclick="setTimePreset('consumeTime', 30)">30分</div> <div class="time-preset" onclick="setTimePreset('consumeTime', 45)">45分</div> <div class="time-preset" onclick="setTimePreset('consumeTime', 60)">60分</div> </div> <div class="error-message" id="consumeTimeError"></div> </div>
                 <div class="form-group hidden" id="multiplierGroup"> <label class="form-label">时间倍率 *</label> <input type="text" id="multiplier" class="form-input" placeholder="默认：1.0"> <div class="time-presets"> <div class="time-preset" onclick="setMultiplierPreset(0.5)">0.5</div> <div class="time-preset" onclick="setMultiplierPreset(0.75)">0.75</div> <div class="time-preset" onclick="setMultiplierPreset(1.25)">1.25</div> <div class="time-preset" onclick="setMultiplierPreset(1.5)">1.5</div> </div> <div class="error-message" id="multiplierError"></div> </div>
                 <div class="form-group hidden" id="targetTimeGroup"> <label class="form-label">目标时长 (分) *</label> <input type="text" id="targetTime" class="form-input" placeholder="例如：3600"> <div class="time-presets"> <div class="time-preset" onclick="setTimePreset('targetTime', 30)">30分</div> <div class="time-preset" onclick="setTimePreset('targetTime', 45)">45分</div> <div class="time-preset" onclick="setTimePreset('targetTime', 60)">60分</div> <div class="time-preset" onclick="setTimePreset('targetTime', 90)">90分</div> </div> <div class="error-message" id="targetTimeError"></div> </div>
                 <div class="form-group hidden" id="bonusRewardGroup"> <label class="form-label">额外奖励 (分)</label> <input type="text" id="bonusReward" class="form-input" placeholder="例如：1800，可不填"> <div class="time-presets"> <div class="time-preset" onclick="setTimePreset('bonusReward', 15)">15分</div> <div class="time-preset" onclick="setTimePreset('bonusReward', 30)">30分</div> <div class="time-preset" onclick="setTimePreset('bonusReward', 45)">45分</div> <div class="time-preset" onclick="setTimePreset('bonusReward', 60)">60分</div> </div> <div class="error-message" id="bonusRewardError"></div> </div>
                 
                 <div class="form-group" id="habitToggleContainer"> <div class="setting-item" style="padding: 0; border: none;"> <div class="setting-info"> <div class="setting-name" id="habitToggleTitle">设置为习惯</div> <div class="setting-desc" id="habitToggleDesc">开启连续打卡和额外奖励</div> </div> <div class="setting-controls"><label class="switch"> <input type="checkbox" id="isHabitToggle" onchange="toggleHabitSettings()"> <span class="slider"></span> </label></div> </div> </div>
                 <div class="habit-settings hidden" id="habitSettingsGroup"> 
                    <div class="habit-settings-title" id="habitSettingsTitle">习惯设置</div> 
                    <!-- [v6.5.0] 周期改为滑块切换；移除持续时长输入 -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label class="form-label">周期</label>
                        <div class="reward-type-switch habit-period-switch">
                            <button type="button" class="active" data-period="daily" onclick="selectHabitPeriod('daily')">每天</button>
                            <button type="button" data-period="weekly" onclick="selectHabitPeriod('weekly')">每周</button>
                            <button type="button" data-period="monthly" onclick="selectHabitPeriod('monthly')">每月</button>
                            <button type="button" data-period="yearly" onclick="selectHabitPeriod('yearly')">每年</button>
                        </div>
                        <input type="hidden" id="habitPeriod" value="daily">
                    </div>
                    <div class="habit-grid"> 
                        <div class="form-group"> 
                            <label class="form-label" id="targetCountLabel">周期目标次数 *</label> 
                            <input type="number" id="targetCountInPeriod" class="form-input" value="1" min="1"> 
                        </div>
                        
                        <div class="form-group"> 
                            <label class="form-label">每日完成上限</label> 
                            <input type="number" id="habitDailyLimit" class="form-input" value="1" min="1"> 
                        </div> 
                    </div> 
                    
                    <div class="form-group"> 
                        <label class="form-label" id="habitRewardsLabel">习惯奖励 (可添加多个)</label> 
                        <div id="habitRewardsContainer"></div> 
                        <button type="button" class="btn btn-secondary" style="width: 100%; padding: 8px; margin-top: 10px;" onclick="addHabitRewardRule()">+ 添加奖励规则</button> 
                    </div> 
                </div>

                 <div class="form-group" id="reminderToggleContainer"> <div class="setting-item" style="padding: 0; border: none;"> <div class="setting-info"> <div class="setting-name">设置提醒</div> <div class="setting-desc">在指定时间或倒计时后发送通知</div> </div> <div class="setting-controls"><label class="switch"> <input type="checkbox" id="isReminderToggle"> <span class="slider"></span> </label></div> </div> </div>
                 <div class="habit-settings hidden" id="reminderSettingsGroup"> 
                    <div class="habit-settings-title">提醒设置</div> 
                    <div class="form-group"> <label class="form-label">提醒模式</label> <div class="mode-switch" id="reminderModeSwitch"> <button type="button" class="active" data-mode="absolute">具体时间</button> <button type="button" data-mode="relative">倒计时</button> </div> </div> 
                    
                    <div class="form-group hidden" id="recurringReminderToggleContainer">
                         <div class="setting-item" style="padding: 0; border: none;">
                            <div class="setting-info">
                                <div class="setting-name">循环提醒</div>
                                <div class="setting-desc">提醒触发后，自动按习惯周期设为下次提醒</div>
                            </div>
                            <div class="setting-controls">
                                <label class="switch">
                                    <input type="checkbox" id="isRecurringReminderToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <div id="reminderAbsoluteMode"> <div class="form-group"> <label class="form-label">提醒时间 *</label> <input type="datetime-local" id="reminderDateTime" class="form-input"> </div> </div> 
                    <div id="reminderRelativeMode" class="hidden"> <div class="form-group"> <label class="form-label">多长时间后提醒 *</label> <div class="input-group"> <input type="number" id="reminderHours" class="form-input" placeholder="0" min="0"> <span>小时</span> <input type="number" id="reminderMinutes" class="form-input" placeholder="0" min="0" max="59"> <span>分钟</span> </div> </div> </div> 
                </div>

                 <div class="form-group" id="appLauncherToggleContainer">
                    <div class="setting-item" style="padding: 0; border: none;">
                        <div class="setting-info">
                            <div class="setting-name">关联应用</div>
                            <div class="setting-desc">任务开始或兑换时自动启动应用</div>
                        </div>
                        <div class="setting-controls">
                            <label class="switch">
                                <input type="checkbox" id="isAppLauncherToggle" onchange="toggleAppLauncherSettings()">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="habit-settings hidden" id="appLauncherSettingsGroup">
                    <div class="habit-settings-title">应用设置</div>
                    <div class="form-group">
                        <label class="form-label">应用名称或包名</label>
                        <div style="position: relative;">
                            <input type="text" id="taskAppPackage" class="form-input" placeholder="输入搜索或选择应用" autocomplete="off" oninput="filterAppList()" onfocus="showAppDropdown()">
                            <div id="appDropdownList" class="app-dropdown hidden"></div>
                        </div>
                        <div class="form-label-small" style="margin-top:4px; color:var(--text-color-light);">
                            可搜索已安装应用，或直接输入包名。
                        </div>
                    </div>
                    <!-- [v5.3.0] 自动检测补录开关 -->
                    <div class="form-group" style="margin-top: 12px;">
                        <div class="setting-item" style="padding: 0; border: none;">
                            <div class="setting-info">
                                <div class="setting-name" style="display: flex; align-items: center; gap: 6px;">自动检测补录<button type="button" class="info-button" id="autoDetectInfoButton" aria-label="自动检测补录说明" onclick="event.stopPropagation();event.preventDefault();showAutoDetectInfoModal()">?</button></div>
                            </div>
                            <div class="setting-controls">
                                <label class="switch">
                                    <input type="checkbox" id="isAutoDetectToggle" onchange="toggleAutoDetect()">
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-group" id="floatingTimerToggleContainer">
                    <div class="setting-item" style="padding: 0; border: none;">
                        <div class="setting-info">
                            <div class="setting-name">悬浮窗计时器</div>
                            <div class="setting-desc">任务运行时显示时长或倒计时</div>
                        </div>
                        <div class="setting-controls">
                            <label class="switch">
                                <input type="checkbox" id="isFloatingTimerToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                </div>

                 <div class="form-buttons"> 
                     <button type="button" class="btn btn-secondary" onclick="hideTaskModal()">取消</button> 
                     <button type="button" class="btn btn-danger hidden" id="deleteBtn" onclick="deleteTask()">删除</button> 
                     <button type="submit" class="btn btn-primary" id="submitBtn">创建</button> 
                 </div>
            </form>
        </div>
    </div>

    <div class="modal" id="historyModal" onclick="if(event.target===this)hideHistoryModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="historyModalTitle">任务历史</div>
                <button class="close-btn" onclick="hideHistoryModal()">×</button>
            </div>
            
            <div class="history-combined-container">
                <div id="historyContentCalendar" class="history-calendar-section">
                </div>
                <div class="history-list-header">历史记录</div>
                <div id="historyContentList" class="history-list-section">
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="dayDetailModal" onclick="if(event.target===this)hideDayDetailModal()"> <div class="modal-content"> <div class="modal-header"> <div class="modal-title" id="dayDetailModalTitle">每日详情</div> <button class="close-btn" onclick="hideDayDetailModal()">×</button> </div> <div id="dayDetailContent"></div> </div> </div>

    <div class="modal" id="categoryDetailModal" onclick="if(event.target===this)hideCategoryDetailModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="categoryDetailModalTitle">分类详情</div>
                <button class="close-btn" onclick="hideCategoryDetailModal()">×</button>
            </div>
            <div id="categoryDetailContent"></div>
        </div>
    </div>

    <div class="modal" id="flowChartInfoModal" onclick="if(event.target===this)hideFlowChartInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">时间流图说明</div>
                <button class="close-btn" onclick="hideFlowChartInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p>时间流图以日程表的形式展示每日的时间活动轨迹。</p>
                <div style="display: grid; gap: 8px;">
                    <div>• 同时进行的任务会并列显示（最多3列）</div>
                    <div>• 同一任务暂停后继续会用虚线连接</div>
                    <div>• 蓝色三角指示当前时间位置</div>
                    <div>• 向上滚动自动加载更早日期</div>
                </div>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableFlowChartInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="allTasksInfoModal" onclick="if(event.target===this)hideAllTasksInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">✨ 卡片拖动排序</div>
                <button class="close-btn" onclick="hideAllTasksInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p style="line-height: 1.6;">长按后卡片会轻微放大并可自由拖动，松手即可完成排序。</p>
                <p style="line-height: 1.6;">拖动采用丝滑的物理动画，其他卡片会自动流畅地让出位置。支持上下左右任意方向移动，像在水面上推动积木一样自然顺滑。</p>
                <div style="font-size: 0.8rem; color: var(--text-color-light); font-style: italic; margin-top: 4px;">
                    <div>💎 真的很好玩！！！</div>
                    <div style="text-align: right;">--开发者</div>
                </div>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableAllTasksInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="activityHeatmapInfoModal" onclick="if(event.target===this)hideActivityHeatmapInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">活动日历是什么？</div>
                <button class="close-btn" onclick="hideActivityHeatmapInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p>活动日历以颜色强度呈现每日净时间，直观看到一段时间内的努力密度。</p>
                <div style="display: grid; gap: 8px;">
                    <div><strong>颜色含义</strong></div>
                    <div>- 净增加：浅绿 0-1小时；中绿 1-3小时；深绿 3小时以上</div>
                    <div>- 净减少：浅红 0-1小时；中红 1-3小时；深红 3小时以上</div>
                </div>
                <div style="display: grid; gap: 8px; margin-top: 4px;">
                    <div><strong>交互方式</strong></div>
                    <div>- 长按显示详情弹窗，可滑动切换日期</div>
                    <div>- 长按 3 秒后自动进入日详情页</div>
                </div>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableActivityHeatmapInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="analysisDashboardInfoModal" onclick="if(event.target===this)hideAnalysisDashboardInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">时间仪表盘是什么？</div>
                <button class="close-btn" onclick="hideAnalysisDashboardInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p>时间仪表盘汇总你在所选周期内的时间表现。</p>
                <div style="display: grid; gap: 8px;">
                    <div><strong>交互方式</strong></div>
                    <div>- 长按饼图扇区显示详情弹窗，可滑动切换其他扇区。</div>
                    <div>- 持续长按3秒后松开进入详情页，查看该分类/任务的明细。</div>
                </div>
                <div style="font-size: 0.8rem; color: var(--text-color-light); font-style: italic; margin-top: 4px;">
                    <div>🥚 当时我长按着转了一下午</div>
                    <div style="text-align: right;">--开发者</div>
                </div>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableAnalysisDashboardInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="tableInfoModal" onclick="if(event.target===this)hideTableInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">详细数据是什么？</div>
                <button class="close-btn" onclick="hideTableInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p>详细数据按表格列出分类/任务的时长与次数，支持筛选、排序和逐步展开更多行。</p>
                <div style="display: grid; gap: 8px;">
                    <div>- 点击表头可按总时间、次数、平均时间排序（再次点击切换升/降序）。</div>
                </div>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableTableInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="trendInfoModal" onclick="if(event.target===this)hideTrendInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">趋势演变是什么？</div>
                <button class="close-btn" onclick="hideTrendInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p>趋势演变展示近 7/30 天的每日获得/消费走势，按分类或任务堆叠，直观看到哪些项目在拉升或拖累净时间。</p>
                    <div><strong>交互方式</strong></div>
                    <div>- 长按柱子可激活高亮并拖动切换显示。</div>
                    <div>- 快速左右滑动可切换获得/消费图表。</div>
                </div>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableTrendInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <!-- [v5.3.0] 自动检测补录说明弹窗 -->
    <div class="modal" id="autoDetectInfoModal" onclick="if(event.target===this)hideAutoDetectInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">自动检测补录</div>
                <button class="close-btn" onclick="hideAutoDetectInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p>开启后，系统每日首次启动时自动检测关联应用的实际使用时长，并与您的记录对比后作调整。</p>
                <div style="display: grid; gap: 8px;">
                    <div><strong>🤖 漏记补录</strong>：实际使用 &gt; 已记录 → 自动补录差额（有一定惩罚）</div>
                    <div><strong>🔧 多记修正</strong>：已记录 &gt; 实际使用 → 自动扣减差额（有一定惩罚）</div>
                    <div><strong>🚀 首次启用</strong>：自动追溯最近7天数据（可在任务历史中撤销）</div>
                </div>
                <p style="font-size: 0.85rem; color: var(--text-color-light);">提示：开启后可在任务菜单中点击"🤖 自动检测"手动触发检测（检查最近7天）。</p>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableAutoDetectInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <!-- [v5.10.0] 屏幕时间说明弹窗 -->
    <div class="modal" id="screenTimeInfoModal" onclick="if(event.target===this)hideScreenTimeInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">📱 屏幕时间管理</div>
                <button class="close-btn" onclick="hideScreenTimeInfoModal()">×</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 12px; color: var(--text-color);">
                <p>屏幕时间管理帮助您控制手机使用，将节省的时间转化为奖励。</p>
                <div style="display: grid; gap: 8px;">
                    <div><strong>🎯 每日限额</strong>：设定每日屏幕使用时间上限</div>
                    <div><strong>🟢 节省奖励</strong>：实际使用 &lt; 限额 → 差额作为奖励存入余额</div>
                    <div><strong>🔴 超出扣除</strong>：实际使用 &gt; 限额 → 超出部分从余额扣除</div>
                    <div><strong>⚡ 自动结算</strong>：每日首次启动时自动结算前一天的屏幕时间</div>
                    <div><strong>📊 分类归属</strong>：可在设置中选择奖励/扣除归属的分类</div>
                </div>
                <p style="font-size: 0.85rem; color: var(--text-color-light);">提示：点击或滑动卡片顶部可展开/收起，点击展开后的卡片可进入屏幕时间详情页。</p>
                <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:4px;">
                    <button class="btn btn-secondary" onclick="disableScreenTimeInfoButton()">不再显示</button>
                </div>
            </div>
        </div>
    </div>

    <!-- [v5.2.0] 通用信息弹窗 -->
    <div class="modal" id="generalInfoModal" onclick="if(event.target===this)hideInfoModal()">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="generalInfoModalTitle">信息</div>
                <button class="close-btn" onclick="hideInfoModal()">×</button>
            </div>
            <div id="generalInfoModalContent" style="color: var(--text-color);"></div>
        </div>
    </div>

    <!-- [v5.2.1] 通用确认弹窗 -->
    <div class="modal" id="confirmModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="confirmModalTitle">确认</div>
                <button class="close-btn" onclick="resolveConfirm(false)">×</button>
            </div>
            <div id="confirmModalContent" style="color: var(--text-color); margin-bottom: 20px; white-space: pre-wrap;"></div>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="resolveConfirm(false)">取消</button>
                <button class="btn btn-primary" onclick="resolveConfirm(true)">确定</button>
            </div>
        </div>
    </div>

    <div class="modal" id="backdateModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="backdateModalTitle">补录任务</div>
                <button class="close-btn" onclick="hideBackdateModal()">×</button>
            </div>
            
            <!-- [v5.6.0] 智能检测功能已移除，改用自动补录系统 -->
            
            <form id="backdateForm" onsubmit="saveBackdate(event)">
                <input type="hidden" id="backdateTaskId">
                <div class="form-group">
                    <label class="form-label">任务名称</label>
                    <p id="backdateTaskName" style="font-weight: 500;"></p>
                </div>
                <div class="form-group">
                    <label class="form-label">补录日期 *</label>
                    <input type="date" id="backdateDate" class="form-input" required>
                </div>
                <div class="form-group" id="backdateModeSwitchContainer">
                    <label class="form-label">补录模式</label>
                    <div class="mode-switch">
                        <button type="button" class="active" data-mode="duration" onclick="switchBackdateMode('duration')">按时长</button>
                        <button type="button" data-mode="range" onclick="switchBackdateMode('range')">按起止时间</button>
                    </div>
                </div>

                <div id="backdateDurationMode">
                    <div class="form-group">
                        <label class="form-label">总时长 *</label>
                        <div class="input-group">
                            <input type="number" id="backdateHours" class="form-input" placeholder="0" min="0"> <span>小时</span>
                            <input type="number" id="backdateMinutes" class="form-input" placeholder="0" min="0" max="59"> <span>分钟</span>
                        </div>
                        <div class="error-message" id="backdateDurationError"></div>
                    </div>
                </div>

                <div id="backdateRangeMode" class="hidden">
                    <div class="form-group">
                        <label class="form-label">开始时间 *</label>
                        <input type="time" id="backdateStartTime" class="form-input">
                        <div class="error-message" id="backdateStartTimeError"></div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">结束时间 *</label>
                        <input type="time" id="backdateEndTime" class="form-input">
                        <div class="error-message" id="backdateEndTimeError"></div>
                    </div>
                </div>
                
                <div id="backdateCountMode" class="hidden">
                    <div class="form-group">
                        <label class="form-label">补录次数 *</label>
                        <div class="input-group">
                            <input type="number" id="backdateCount" class="form-input" value="1" min="1" style="width: 100px;"> <span>次</span>
                        </div>
                        <div class="error-message" id="backdateCountError"></div>
                    </div>
                </div>

                <div class="form-buttons">
                    <button type="button" class="btn btn-secondary" onclick="hideBackdateModal()">取消</button>
                    <button type="submit" class="btn btn-primary">确认补录</button>
                </div>
            </form>
        </div>
    </div>

    <div id="trendTooltip" class="trend-tooltip"></div>
    <div id="pieTooltip" class="trend-tooltip pie-tooltip"></div> <!-- [v5.1.0] 饼图长按弹窗 -->
    <div id="flowTooltip" class="trend-tooltip flow-tooltip"></div> <!-- [v5.1.1] 时间流图长按弹窗 -->
    <div id="heatmapTooltip" class="heatmap-tooltip"></div>
    <!-- [v6.4.6] 全局浮动任务菜单，独立于任务卡片以支持backdrop-filter -->
    <div id="globalTaskMenu" class="global-task-menu"></div>
</body>
<script>
        // ⚠️ 版本更新规则 (必读)：
        // 1. APP_VERSION 和版本日志的更新【必须】由用户明确下达命令后才能修改
        // 2. 用户会在更新开始前告知本次版本号
        // 3. 版本日志应在整个版本更新完成后才添加
        // 4. 未经用户授权，禁止自行修改版本号！
        const APP_VERSION = 'v6.5.0'; // 版本号与应用保持一致
        
        // [v5.8.1] Event Sourcing 准备：事件日志静默记录
        // 这是迁移到事件驱动架构的第一步，目前只记录不使用
        const EVENT_TYPES = {
            // 任务生命周期
            TASK_CREATED: 'TASK_CREATED',
            TASK_UPDATED: 'TASK_UPDATED',
            TASK_DELETED: 'TASK_DELETED',
            // 任务执行
            TASK_STARTED: 'TASK_STARTED',
            TASK_PAUSED: 'TASK_PAUSED',
            TASK_RESUMED: 'TASK_RESUMED',
            TASK_COMPLETED: 'TASK_COMPLETED',
            TASK_STOPPED: 'TASK_STOPPED', // 持续类结束（含消费）
            TASK_CANCELLED: 'TASK_CANCELLED',
            // 补录和撤回
            TASK_BACKDATED: 'TASK_BACKDATED',
            TRANSACTION_UNDONE: 'TRANSACTION_UNDONE',
            // 习惯相关
            HABIT_STREAK_ADVANCED: 'HABIT_STREAK_ADVANCED',
            HABIT_STREAK_BROKEN: 'HABIT_STREAK_BROKEN',
            // 设置
            SETTINGS_CHANGED: 'SETTINGS_CHANGED',
        };
        
        // 客户端唯一标识（用于区分多端事件来源）
        let clientId = localStorage.getItem('tb_client_id');
        if (!clientId) {
            clientId = 'client_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('tb_client_id', clientId);
        }
        
        // 本地事件序号（用于排序）
        let localEventSequence = parseInt(localStorage.getItem('tb_event_seq') || '0');
        
        // =====================================================
        // [v5.9.0] Event Sourcing Phase 4: 写入层切换
        // 功能开关：控制是否启用事件驱动写入
        // =====================================================
        
        // 🔧 开发开关：设为 true 启用事件驱动写入（测试阶段默认关闭）
        const USE_EVENT_SOURCING = false;
        
        /**
         * [v5.9.0] 核心事件分发器 - Phase 4 的核心
         * 事件驱动写入：先写事件 → 应用状态 → 保存快照
         * 
         * @param {string} eventType - 事件类型 (EVENT_TYPES.*)
         * @param {object} payload - 事件数据
         * @param {object} options - 选项
         * @param {boolean} options.skipSnapshot - 是否跳过保存快照（批量操作时使用）
         * @param {boolean} options.skipUI - 是否跳过UI更新
         * @returns {Promise<{success: boolean, eventId: string|null, error: string|null}>}
         */
        async function dispatchEvent(eventType, payload = {}, options = {}) {
            const currentUser = AV.User.current();
            if (!currentUser) {
                console.warn('[ES] dispatchEvent: 未登录');
                return { success: false, eventId: null, error: '未登录' };
            }
            
            const eventTime = new Date().toISOString();
            let eventId = null;
            
            try {
                // Step 1: 先持久化事件到云端（保证事件不丢失）
                localEventSequence++;
                localStorage.setItem('tb_event_seq', localEventSequence.toString());
                
                const Event = AV.Object.extend('UserTimeBankEvent');
                const event = new Event();
                
                const acl = new AV.ACL();
                acl.setReadAccess(currentUser, true);
                acl.setWriteAccess(currentUser, true);
                event.setACL(acl);
                
                event.set('owner', currentUser);
                event.set('eventType', eventType);
                event.set('payload', payload);
                event.set('clientId', clientId);
                event.set('sequence', localEventSequence);
                event.set('appVersion', APP_VERSION);
                event.set('eventTime', eventTime);
                
                // ⚠️ 同步等待保存完成（与 logEvent 不同）
                await event.save();
                eventId = event.id;
                console.log(`✅ [ES] 事件已持久化: ${eventType} (${eventId})`);
                
                // [v5.9.0] Phase 5: 记录本地事件用于冲突检测
                recordLocalEvent(eventType, payload, eventTime);

                // [v6.4.3] 移除事件分发后的自动差异检测
                // 这是导致单设备自我冲突的主要原因：本地刚保存，云端还没更新完就检测差异
                // 差异检测改为仅在页面恢复可见且经过较长休眠后触发
                
                // Step 2: 应用事件到本地状态
                const localState = {
                    tasks: tasks.reduce((acc, t) => { acc[t.id] = t; return acc; }, {}),
                    transactions: transactions,
                    balance: currentBalance,
                    habitStreaks: {}
                };
                
                // 提取习惯连续信息
                tasks.forEach(t => {
                    if (t.isHabit) {
                        localState.habitStreaks[t.id] = {
                            currentStreak: t.currentStreak || 0,
                            lastCompletedDate: t.lastCompletedDate || null
                        };
                    }
                });
                
                applyEventToState(localState, eventType, payload, eventTime);
                
                // Step 3: 将计算后的状态同步回全局变量
                tasks = Object.values(localState.tasks);
                transactions = localState.transactions;
                currentBalance = localState.balance;
                
                // 同步习惯连续信息
                Object.keys(localState.habitStreaks).forEach(taskId => {
                    const task = tasks.find(t => t.id === taskId);
                    if (task) {
                        task.currentStreak = localState.habitStreaks[taskId].currentStreak;
                        task.lastCompletedDate = localState.habitStreaks[taskId].lastCompletedDate;
                    }
                });
                
                // Step 4: 保存快照（作为缓存加速）
                if (!options.skipSnapshot) {
                    await saveData();
                }
                
                // Step 5: 更新UI
                if (!options.skipUI) {
                    updateUI();
                }
                
                return { success: true, eventId, error: null };
                
            } catch (e) {
                console.error(`❌ [ES] dispatchEvent 失败: ${eventType}`, e);
                
                // [v5.9.0] Phase 5: 网络失败时加入离线队列
                if (USE_EVENT_SOURCING) {
                    queueOfflineEvent(eventType, payload, eventTime);
                }
                
                return { success: false, eventId, error: e.message };
            }
        }
        
        // =====================================================
        // [v5.9.0] Event Sourcing Phase 5: 同步机制重构
        // 离线队列、事件合并、冲突检测
        // =====================================================
        
        // 离线事件队列（存储在 localStorage）
        const OFFLINE_QUEUE_KEY = 'tb_offline_events';
        
        /**
         * 获取离线事件队列
         */
        function getOfflineEventQueue() {
            try {
                const data = localStorage.getItem(OFFLINE_QUEUE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                console.warn('[ES] 读取离线队列失败:', e);
                return [];
            }
        }
        
        /**
         * 保存离线事件队列
         */
        function saveOfflineEventQueue(queue) {
            try {
                localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(queue));
            } catch (e) {
                console.warn('[ES] 保存离线队列失败:', e);
            }
        }
        
        /**
         * 将事件加入离线队列
         */
        function queueOfflineEvent(eventType, payload, eventTime) {
            const queue = getOfflineEventQueue();
            queue.push({
                eventType,
                payload,
                eventTime: eventTime || new Date().toISOString(),
                clientId,
                sequence: localEventSequence,
                queuedAt: Date.now()
            });
            saveOfflineEventQueue(queue);
            console.log(`📦 [ES] 事件已加入离线队列: ${eventType} (队列长度: ${queue.length})`);
        }
        
        /**
         * 上传离线队列中的事件
         * @returns {Promise<{uploaded: number, failed: number}>}
         */
        async function flushOfflineEventQueue() {
            const currentUser = AV.User.current();
            if (!currentUser) return { uploaded: 0, failed: 0 };
            
            const queue = getOfflineEventQueue();
            if (queue.length === 0) return { uploaded: 0, failed: 0 };
            
            console.log(`🔄 [ES] 开始上传离线队列: ${queue.length} 条事件`);
            
            let uploaded = 0;
            let failed = 0;
            const failedEvents = [];
            
            for (const item of queue) {
                try {
                    const Event = AV.Object.extend('UserTimeBankEvent');
                    const event = new Event();
                    
                    const acl = new AV.ACL();
                    acl.setReadAccess(currentUser, true);
                    acl.setWriteAccess(currentUser, true);
                    event.setACL(acl);
                    
                    event.set('owner', currentUser);
                    event.set('eventType', item.eventType);
                    event.set('payload', item.payload);
                    event.set('clientId', item.clientId);
                    event.set('sequence', item.sequence);
                    event.set('appVersion', APP_VERSION);
                    event.set('eventTime', item.eventTime);
                    event.set('wasOffline', true); // 标记为离线事件
                    
                    await event.save();
                    uploaded++;
                } catch (e) {
                    console.warn(`[ES] 离线事件上传失败:`, e.message);
                    failed++;
                    failedEvents.push(item);
                }
            }
            
            // 只保留失败的事件
            saveOfflineEventQueue(failedEvents);
            
            console.log(`✅ [ES] 离线队列上传完成: 成功 ${uploaded}, 失败 ${failed}`);
            return { uploaded, failed };
        }
        
        /**
         * 从云端拉取新事件并应用到本地
         * @param {Date} sinceDate - 从何时开始拉取
         * @returns {Promise<{applied: number, conflicts: array}>}
         */
        async function pullAndApplyEvents(sinceDate = null) {
            const currentUser = AV.User.current();
            if (!currentUser) return { applied: 0, conflicts: [] };
            
            console.log('[ES] 开始拉取远端事件...');
            
            try {
                // 分页拉取，避免遗漏事件；默认只取他端，防止重复应用本端事件
                const pageSize = 100;
                let skip = 0;
                let remoteEvents = [];
                let hasMore = true;

                while (hasMore) {
                    const query = new AV.Query('UserTimeBankEvent');
                    query.equalTo('owner', currentUser);
                    query.notEqualTo('clientId', clientId);
                    if (sinceDate) query.greaterThan('createdAt', sinceDate);
                    query.ascending('createdAt');
                    query.addAscending('sequence');
                    query.limit(pageSize);
                    query.skip(skip);

                    const batch = await query.find();
                    remoteEvents = remoteEvents.concat(batch);
                    hasMore = batch.length === pageSize;
                    skip += batch.length;
                }

                if (remoteEvents.length === 0) {
                    console.log('[ES] 没有新的远端事件');
                    return { applied: 0, conflicts: [] };
                }

                console.log(`[ES] 拉取到 ${remoteEvents.length} 条远端事件（分页完成）`);
                
                // 检测冲突
                const conflicts = detectConflicts(remoteEvents);
                
                // 应用事件到本地状态
                const localState = {
                    tasks: tasks.reduce((acc, t) => { acc[t.id] = t; return acc; }, {}),
                    transactions: transactions,
                    balance: currentBalance,
                    habitStreaks: {}
                };
                
                for (const eventObj of remoteEvents) {
                    const eventType = eventObj.get('eventType');
                    const payload = eventObj.get('payload') || {};
                    const eventTime = eventObj.get('eventTime') || eventObj.get('createdAt').toISOString();
                    
                    try {
                        applyEventToState(localState, eventType, payload, eventTime);
                    } catch (e) {
                        console.warn(`[ES] 应用远端事件失败: ${eventType}`, e.message);
                    }
                }
                
                // 同步状态
                tasks = Object.values(localState.tasks);
                transactions = localState.transactions;
                currentBalance = localState.balance;
                
                // 保存快照
                await saveData();
                updateUI();
                
                console.log(`✅ [ES] 已应用 ${remoteEvents.length} 条远端事件`);
                
                return { applied: remoteEvents.length, conflicts };
                
            } catch (e) {
                console.error('[ES] 拉取远端事件失败:', e);
                return { applied: 0, conflicts: [], error: e.message };
            }
        }
        
        /**
         * 检测冲突：多端同时修改同一任务
         */
        function detectConflicts(remoteEvents) {
            const conflicts = [];
            const localRecentEvents = getRecentLocalEvents();
            
            for (const remote of remoteEvents) {
                const remotePayload = remote.get('payload') || {};
                const remoteTaskId = remotePayload.taskId;
                const remoteTime = new Date(remote.get('eventTime') || remote.get('createdAt'));
                
                // 检查本地是否在相近时间修改了同一任务
                for (const local of localRecentEvents) {
                    if (local.payload.taskId === remoteTaskId) {
                        const localTime = new Date(local.eventTime);
                        const timeDiff = Math.abs(remoteTime - localTime);
                        
                        // 5分钟内的并发修改视为冲突
                        if (timeDiff < 5 * 60 * 1000) {
                            conflicts.push({
                                taskId: remoteTaskId,
                                localEvent: local,
                                remoteEvent: {
                                    eventType: remote.get('eventType'),
                                    payload: remotePayload,
                                    eventTime: remote.get('eventTime'),
                                    clientId: remote.get('clientId')
                                },
                                timeDiff
                            });
                        }
                    }
                }
            }
            
            if (conflicts.length > 0) {
                console.warn(`⚠️ [ES] 检测到 ${conflicts.length} 处冲突`);
            }
            
            return conflicts;
        }

        // [v6.4.2] 云端/本地差异保底检测，必要时自动拉起诊断弹窗
        // [v6.4.3] 修复：大幅降低敏感度，防止单设备自我冲突
        let syncDriftPrompting = false;
        let lastDriftCheckTime = 0;
        let lastSaveTime = 0; // [v6.4.3] 记录最后保存时间，用于静默期判断
        const DRIFT_CHECK_COOLDOWN = 60000; // [v6.4.3] 60秒冷却时间，避免频繁弹窗
        const POST_SAVE_SILENCE_PERIOD = 15000; // [v6.4.3] 保存后15秒内不检测差异
        
        async function detectAndPromptSyncDrift(trigger = 'auto') {
            if (syncDriftPrompting) return;
            
            const now = Date.now();
            
            // [v6.4.3] 保存后静默期：刚保存完不检测，避免自我冲突
            if (now - lastSaveTime < POST_SAVE_SILENCE_PERIOD) {
                console.log(`[ES] 差异检测跳过: 保存后静默期 (${Math.floor((POST_SAVE_SILENCE_PERIOD - (now - lastSaveTime))/1000)}s)`);
                return;
            }
            
            // [v6.4.3] 冷却时间检查
            if (now - lastDriftCheckTime < DRIFT_CHECK_COOLDOWN) {
                console.log(`[ES] 差异检测跳过: 冷却中 (${Math.floor((DRIFT_CHECK_COOLDOWN - (now - lastDriftCheckTime))/1000)}s)`);
                return;
            }
            
            // [v6.4.3] 本地有活跃操作时不检测
            if (now - lastLocalActionTime < 10000) {
                console.log('[ES] 差异检测跳过: 本地活跃中');
                return;
            }
            
            const currentUser = AV.User.current();
            if (!currentUser) return;

            try {
                const pendingQueue = getOfflineEventQueue();
                const hasPending = pendingQueue && pendingQueue.length > 0;

                // 如果有待上传事件，先尝试上传一次，避免误报
                if (hasPending) {
                    await flushOfflineEventQueue();
                }

                const query = new AV.Query('UserTimeBankData');
                query.equalTo('owner', currentUser);
                const results = await query.find();
                if (results.length === 0) return;

                const cloudObj = results[0];
                const cloudData = cloudObj.get('data') || {};
                const cloudTasks = cloudData.tasks || [];
                const cloudTransactions = cloudData.transactions || [];
                const cloudBalance = cloudData.currentBalance || 0;
                const cloudVersion = cloudData.dataVersion || cloudData.version || 0;
                const cloudRunningTasks = cloudData.runningTasks || [];

                const localTaskCount = tasks ? tasks.length : 0;
                const localTxCount = transactions ? transactions.length : 0;
                const localBalance = currentBalance || 0;
                const localRunningCount = runningTasks ? runningTasks.size : 0;

                const countDiff = cloudTasks.length !== localTaskCount || cloudTransactions.length !== localTxCount;
                const balanceDiff = Math.abs(cloudBalance - localBalance) > 1e-3;
                const versionDiff = cloudVersion !== (localDataVersion || 0);
                
                // [v6.4.2] 新增：运行中任务差异检测（关键！能发现手机端结束任务但电脑端未同步的情况）
                const runningDiff = cloudRunningTasks.length !== localRunningCount;
                
                // [v6.4.2] 判断是否应该弹窗
                const hasMeaningfulDiff = countDiff || balanceDiff || runningDiff;
                const shouldPrompt = hasPending || hasMeaningfulDiff;
                
                // [v6.4.3] 只在有明显差异且不是刚保存完时才弹窗
                // 避免本地保存和云端同步的时间差导致误报
                if (shouldPrompt) {
                    // [v6.4.3] 额外检查：如果云端版本等于本地版本，说明是同一设备刚保存的，跳过
                    if (cloudVersion === localDataVersion && !hasPending) {
                        console.log('[ES] 跳过弹窗: 版本一致，可能是同步延迟');
                        return;
                    }
                    
                    syncDriftPrompting = true;
                    lastDriftCheckTime = now;
                    
                    console.log(`[ES] 检测到差异 (${trigger}): count=${countDiff}, balance=${balanceDiff}, running=${runningDiff}, version=${versionDiff}, pending=${hasPending}`);
                    // [v6.4.3] 改为静默日志，不再自动弹出诊断弹窗干扰用户
                    // 用户可以手动点击云端同步诊断按钮查看
                    console.warn('⚠️ 同步差异检测到，用户可手动查看诊断');
                    // showNotification('⚠️ 同步差异', '检测到本地/云端可能不一致，正在打开诊断…', 'reminder');
                    // await showCloudSyncDiagnostics();
                }
            } catch (e) {
                console.warn('[ES] 差异检测失败:', e.message);
            } finally {
                syncDriftPrompting = false;
            }
        }
        
        /**
         * 获取最近的本地事件（用于冲突检测）
         */
        function getRecentLocalEvents() {
            // 从 localStorage 获取最近记录的事件
            try {
                const data = localStorage.getItem('tb_recent_events');
                return data ? JSON.parse(data) : [];
            } catch (e) {
                return [];
            }
        }
        
        /**
         * 记录本地事件（用于冲突检测）
         */
        function recordLocalEvent(eventType, payload, eventTime) {
            try {
                const recentEvents = getRecentLocalEvents();
                recentEvents.push({ eventType, payload, eventTime, clientId });
                
                // 只保留最近30分钟的事件
                const cutoff = Date.now() - 30 * 60 * 1000;
                const filtered = recentEvents.filter(e => new Date(e.eventTime).getTime() > cutoff);
                
                localStorage.setItem('tb_recent_events', JSON.stringify(filtered.slice(-50))); // 最多50条
            } catch (e) {
                console.warn('[ES] 记录本地事件失败:', e);
            }
        }
        
        /**
         * 网络恢复时的同步处理
         */
        async function syncOnNetworkRestore() {
            console.log('🌐 [ES] 网络恢复，开始同步...');
            
            // 1. 先上传离线队列
            const uploadResult = await flushOfflineEventQueue();
            
            // 2. 拉取并应用远端事件
            const lastSyncTime = localStorage.getItem('tb_last_event_sync');
            const sinceDate = lastSyncTime ? new Date(parseInt(lastSyncTime)) : null;
            
            const pullResult = await pullAndApplyEvents(sinceDate);
            
            // 3. 更新同步时间
            localStorage.setItem('tb_last_event_sync', Date.now().toString());
            
            // 4. 显示同步结果
            if (uploadResult.uploaded > 0 || pullResult.applied > 0) {
                showToast(`同步完成: 上传${uploadResult.uploaded}条, 接收${pullResult.applied}条`, 3000);
            }
            
            if (pullResult.conflicts && pullResult.conflicts.length > 0) {
                showToast(`⚠️ 检测到${pullResult.conflicts.length}处并发修改`, 4000);
                // [v6.4.3] 仅在真正检测到多端并发修改时才弹出诊断
                // 这是用户主动请求同步的场景，可以弹窗
                try { await showCloudSyncDiagnostics(); } catch(e) { console.warn('auto diagnostics failed', e); }
            }

            // [v6.4.3] 移除网络恢复时的自动差异检测，避免误报
            // await detectAndPromptSyncDrift('network-restore');
            
            return { uploadResult, pullResult };
        }
        
        // 监听网络状态变化
        if (typeof window !== 'undefined') {
            window.addEventListener('online', () => {
                if (USE_EVENT_SOURCING) {
                    syncOnNetworkRestore();
                }
            });
        }
        
        /**
         * [v5.8.1] 静默记录事件到云端
         * 这是零风险的旁听模式，不影响任何现有逻辑
         * @param {string} type - 事件类型
         * @param {object} payload - 事件数据
         */
        async function logEvent(type, payload = {}) {
            const currentUser = AV.User.current();
            if (!currentUser) return; // 未登录不记录
            
            try {
                localEventSequence++;
                localStorage.setItem('tb_event_seq', localEventSequence.toString());
                
                const Event = AV.Object.extend('UserTimeBankEvent');
                const event = new Event();
                
                // 设置ACL：只有当前用户可读写
                const acl = new AV.ACL();
                acl.setReadAccess(currentUser, true);
                acl.setWriteAccess(currentUser, true);
                event.setACL(acl);
                
                event.set('owner', currentUser);
                event.set('eventType', type);
                event.set('payload', payload);
                event.set('clientId', clientId);
                event.set('sequence', localEventSequence);
                event.set('appVersion', APP_VERSION);
                event.set('eventTime', new Date().toISOString());
                
                // 异步保存，不阻塞主流程
                event.save().then(() => {
                    console.log(`📝 事件已记录: ${type}`);
                }).catch(err => {
                    console.warn(`事件记录失败(非致命): ${type}`, err.message);
                });
            } catch (e) {
                console.warn('事件记录异常(非致命):', e.message);
            }
        }
        
        // =====================================================
        // [v5.9.0] Event Sourcing Phase 3: 状态计算与验证
        // 从事件日志重建状态，用于数据一致性校验和恢复
        // =====================================================
        
        /**
         * 从云端获取所有事件并计算状态
         * @param {Date|null} sinceDate - 可选，只获取此日期之后的事件
         * @returns {Promise<{tasks: object, transactions: array, balance: number, habitStreaks: object}>}
         */
        async function computeStateFromEvents(sinceDate = null) {
            const currentUser = AV.User.current();
            if (!currentUser) {
                console.warn('[ES] 未登录，无法计算状态');
                return null;
            }
            
            console.log('[ES] 开始从事件日志计算状态...');
            const startTime = Date.now();
            
            try {
                // 1. 获取所有事件，按时间排序
                const query = new AV.Query('UserTimeBankEvent');
                query.equalTo('owner', currentUser);
                if (sinceDate) {
                    query.greaterThan('createdAt', sinceDate);
                }
                query.ascending('createdAt');
                query.addAscending('sequence');
                query.limit(1000); // 分页获取，避免一次性加载过多
                
                let allEvents = [];
                let skip = 0;
                let hasMore = true;
                
                while (hasMore) {
                    query.skip(skip);
                    const batch = await query.find();
                    allEvents = allEvents.concat(batch);
                    skip += batch.length;
                    hasMore = batch.length === 1000;
                    
                    if (hasMore) {
                        console.log(`[ES] 已加载 ${allEvents.length} 条事件，继续加载...`);
                    }
                }
                
                console.log(`[ES] 共加载 ${allEvents.length} 条事件`);
                
                if (allEvents.length === 0) {
                    console.log('[ES] 没有事件记录，返回空状态');
                    return {
                        tasks: {},
                        transactions: [],
                        balance: 0,
                        habitStreaks: {}
                    };
                }
                
                // 2. 重放事件，构建状态
                const state = {
                    tasks: {},           // taskId -> task object
                    transactions: [],     // 交易记录数组
                    balance: 0,           // 当前余额
                    habitStreaks: {}      // taskId -> {currentStreak, lastCompletedDate}
                };
                
                for (const eventObj of allEvents) {
                    const eventType = eventObj.get('eventType');
                    const payload = eventObj.get('payload') || {};
                    const eventTime = eventObj.get('eventTime') || eventObj.get('createdAt').toISOString();
                    
                    try {
                        applyEventToState(state, eventType, payload, eventTime);
                    } catch (e) {
                        console.warn(`[ES] 事件处理失败: ${eventType}`, e.message, payload);
                    }
                }
                
                const elapsed = Date.now() - startTime;
                console.log(`[ES] 状态计算完成，耗时 ${elapsed}ms`);
                console.log(`[ES] 结果: ${Object.keys(state.tasks).length} 任务, ${state.transactions.length} 交易, 余额 ${state.balance}`);
                
                return state;
                
            } catch (e) {
                console.error('[ES] 状态计算失败:', e);
                return null;
            }
        }
        
        /**
         * 将单个事件应用到状态对象
         * @param {object} state - 要修改的状态对象
         * @param {string} eventType - 事件类型
         * @param {object} payload - 事件数据
         * @param {string} eventTime - 事件时间 ISO 字符串
         */
        function applyEventToState(state, eventType, payload, eventTime) {
            switch (eventType) {
                // --- 任务生命周期 ---
                case EVENT_TYPES.TASK_CREATED:
                    state.tasks[payload.taskId] = {
                        ...payload.task,
                        id: payload.taskId
                    };
                    break;
                    
                case EVENT_TYPES.TASK_UPDATED:
                    if (state.tasks[payload.taskId]) {
                        Object.assign(state.tasks[payload.taskId], payload.changes);
                    }
                    break;
                    
                case EVENT_TYPES.TASK_DELETED:
                    delete state.tasks[payload.taskId];
                    break;
                
                // --- 任务完成（产生交易） ---
                case EVENT_TYPES.TASK_COMPLETED:
                    if (payload.transaction) {
                        state.transactions.push(payload.transaction);
                        state.balance += payload.transaction.amount || 0;
                    }
                    // 更新习惯连续天数
                    if (payload.habitStreak && payload.taskId) {
                        state.habitStreaks[payload.taskId] = {
                            currentStreak: payload.habitStreak.newStreak || 1,
                            lastCompletedDate: eventTime.split('T')[0]
                        };
                    }
                    break;
                
                // --- 补录（也产生交易） ---
                case EVENT_TYPES.TASK_BACKDATED:
                    if (payload.transaction) {
                        state.transactions.push(payload.transaction);
                        state.balance += payload.transaction.amount || 0;
                    }
                    // 补录可能影响习惯连续天数
                    if (payload.habitStreak && payload.taskId) {
                        state.habitStreaks[payload.taskId] = {
                            currentStreak: payload.habitStreak.newStreak || 1,
                            lastCompletedDate: payload.transaction?.date || eventTime.split('T')[0]
                        };
                    }
                    break;
                
                // --- 撤回交易 ---
                case EVENT_TYPES.TRANSACTION_UNDONE:
                    if (payload.undoneTransactionId) {
                        // 找到并移除被撤回的交易
                        const idx = state.transactions.findIndex(t => t.id === payload.undoneTransactionId);
                        if (idx !== -1) {
                            const removed = state.transactions.splice(idx, 1)[0];
                            state.balance -= removed.amount || 0;
                        }
                    }
                    if (payload.reversalTransaction) {
                        state.transactions.push(payload.reversalTransaction);
                        state.balance += payload.reversalTransaction.amount || 0;
                    }
                    break;
                
                // --- 习惯相关 ---
                case EVENT_TYPES.HABIT_STREAK_ADVANCED:
                    if (payload.taskId) {
                        state.habitStreaks[payload.taskId] = {
                            currentStreak: payload.newStreak || 1,
                            lastCompletedDate: eventTime.split('T')[0]
                        };
                    }
                    break;
                    
                case EVENT_TYPES.HABIT_STREAK_BROKEN:
                    if (payload.taskId) {
                        state.habitStreaks[payload.taskId] = {
                            currentStreak: 0,
                            lastCompletedDate: null
                        };
                    }
                    break;
                
                // --- 任务执行状态（不影响余额，仅用于日志） ---
                case EVENT_TYPES.TASK_STARTED:
                case EVENT_TYPES.TASK_PAUSED:
                case EVENT_TYPES.TASK_RESUMED:
                case EVENT_TYPES.TASK_STOPPED:
                case EVENT_TYPES.TASK_CANCELLED:
                case EVENT_TYPES.SETTINGS_CHANGED:
                    // 这些事件目前仅记录，不影响最终状态
                    break;
                    
                default:
                    console.warn(`[ES] 未知事件类型: ${eventType}`);
            }
        }
        
        /**
         * 验证当前快照与事件日志计算结果的一致性
         * @returns {Promise<{isValid: boolean, differences: array}>}
         */
        async function validateStateFromEvents() {
            console.log('[ES] 开始状态验证...');
            
            const eventState = await computeStateFromEvents();
            if (!eventState) {
                return { isValid: false, error: '无法从事件计算状态' };
            }
            
            const differences = [];
            
            // 1. 验证余额
            if (Math.abs(currentBalance - eventState.balance) > 0.001) {
                differences.push({
                    type: 'balance',
                    snapshot: currentBalance,
                    computed: eventState.balance,
                    diff: currentBalance - eventState.balance
                });
            }
            
            // 2. 验证交易数量
            if (transactions.length !== eventState.transactions.length) {
                differences.push({
                    type: 'transaction_count',
                    snapshot: transactions.length,
                    computed: eventState.transactions.length
                });
            }
            
            // 3. 验证任务数量
            const snapshotTaskCount = tasks.length;
            const eventTaskCount = Object.keys(eventState.tasks).length;
            if (snapshotTaskCount !== eventTaskCount) {
                differences.push({
                    type: 'task_count',
                    snapshot: snapshotTaskCount,
                    computed: eventTaskCount
                });
            }
            
            // 4. 验证习惯连续天数（如果任务是习惯类型）
            for (const task of tasks) {
                if (task.isHabit && eventState.habitStreaks[task.id]) {
                    const snapshotStreak = task.currentStreak || 0;
                    const eventStreak = eventState.habitStreaks[task.id].currentStreak || 0;
                    if (snapshotStreak !== eventStreak) {
                        differences.push({
                            type: 'habit_streak',
                            taskId: task.id,
                            taskName: task.name,
                            snapshot: snapshotStreak,
                            computed: eventStreak
                        });
                    }
                }
            }
            
            const isValid = differences.length === 0;
            
            if (isValid) {
                console.log('[ES] ✅ 状态验证通过！快照与事件日志一致');
            } else {
                console.warn('[ES] ⚠️ 发现差异:', differences);
            }
            
            return { isValid, differences, eventState };
        }
        
        /**
         * 修复状态：用事件计算的状态覆盖当前快照
         * ⚠️ 危险操作，仅在确认事件日志正确时使用
         * @returns {Promise<boolean>}
         */
        async function repairStateFromEvents() {
            const result = await validateStateFromEvents();
            
            if (!result.eventState) {
                showToast('无法从事件计算状态', 3000);
                return false;
            }
            
            if (result.isValid) {
                showToast('状态一致，无需修复', 2000);
                return true;
            }
            
            console.log('[ES] 开始修复状态...');
            console.log('[ES] 差异:', result.differences);
            
            // 暂时只修复余额，更复杂的修复需要更多验证
            const balanceDiff = result.differences.find(d => d.type === 'balance');
            if (balanceDiff) {
                console.log(`[ES] 修复余额: ${currentBalance} -> ${result.eventState.balance}`);
                currentBalance = result.eventState.balance;
            }
            
            // 记录修复事件
            await logEvent('STATE_REPAIRED', {
                differences: result.differences,
                action: 'balance_corrected'
            });
            
            // 保存修复后的状态
            await saveData();
            updateUI();
            
            showToast(`已修复 ${result.differences.length} 处差异`, 3000);
            return true;
        }
        
        // [v5.6.0] Toast 通知函数
        // [v6.0.0] 支持全局通透模式
        function showToast(message, duration = 2000) {
            // 移除已有的 toast
            const existingToast = document.getElementById('toastNotification');
            if (existingToast) {
                existingToast.remove();
            }
            
            // 检查是否是通透模式
            const isGlassMode = document.body.classList.contains('glass-mode');
            
            // 创建 toast 元素
            const toast = document.createElement('div');
            toast.id = 'toastNotification';
            toast.textContent = message;
            
            if (isGlassMode) {
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.12) 100%);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    backdrop-filter: blur(20px);
                    -webkit-backdrop-filter: blur(20px);
                    color: white;
                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
                    padding: 12px 24px;
                    border-radius: 24px;
                    font-size: 0.9rem;
                    z-index: 10000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    max-width: 80%;
                    text-align: center;
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
                `;
            } else {
                toast.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 24px;
                    font-size: 0.9rem;
                    z-index: 10000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    max-width: 80%;
                    text-align: center;
                `;
            }
            document.body.appendChild(toast);
            
            // 显示动画
            requestAnimationFrame(() => {
                toast.style.opacity = '1';
            });
            
            // 自动隐藏
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        const APP_DIRECTORY = {
            // --- 社交/通讯 ---
            "微信": "com.tencent.mm",
            "QQ": "com.tencent.mobileqq",
            "微博": "com.sina.weibo",
            "小红书": "com.xingin.xhs",
            "知乎": "com.zhihu.android",
            "Telegram": "org.telegram.messenger",
            "Twitter": "com.twitter.android",
            "X": "com.twitter.android",
            // --- 视频/娱乐 ---
            "抖音": "com.ss.android.ugc.aweme",
            "快手": "com.smile.gifmaker",
            "B站": "tv.danmaku.bili",
            "哔哩哔哩": "tv.danmaku.bili",
            "YouTube": "com.google.android.youtube",
            "Netflix": "com.netflix.mediaclient",
            "Spotify": "com.spotify.music",
            "网易云音乐": "com.netease.cloudmusic",
            "QQ音乐": "com.tencent.qqmusic",
            // --- 游戏 (最热门) ---
            "王者荣耀": "com.tencent.tmgp.sgame",
            "和平精英": "com.tencent.tmgp.pubgmhd",
            "原神": "com.miHoYo.Yuanshen",
            "崩坏：星穹铁道": "com.miHoYo.hkrpg",
            "金铲铲之战": "com.tencent.jkchess",
            "英雄联盟手游": "com.tencent.lolm",
            "穿越火线": "com.tencent.tmgp.cf",
            "Minecraft": "com.mojang.minecraftpe",
            "第五人格360": "com.netease.dwrg.qihoo",
            "荒野乱斗": "com.tencent.tmgp.supercell.brawlstars",
            "逆水寒": "com.netease.nshm",
            // --- 生活/工具 ---
            "支付宝": "com.eg.android.AlipayGphone",
            "淘宝": "com.taobao.taobao",
            "京东": "com.jingdong.app.mall",
            "拼多多": "com.xunmeng.pinduoduo",
            "美团": "com.sankuai.meituan",
            "饿了么": "me.ele",
            "高德地图": "com.autonavi.minimap",
            "百度地图": "com.baidu.BaiduMap",
            "Chrome": "com.android.chrome",
            "Edge": "com.microsoft.emmx",

            // --- 扩展词典 2025-12 热门应用 ---
            "腾讯视频": "com.tencent.qqlive",
            "爱奇艺": "com.qiyi.video",
            "优酷": "com.youku.phone",
            "芒果TV": "com.hunantv.imgo.activity",
            "抖音极速版": "com.ss.android.ugc.aweme.lite",
            "快手极速版": "com.kuaishou.nebula",
            "今日头条": "com.ss.android.article.news",
            "百度": "com.baidu.searchbox",
            "央视新闻": "cn.cntvnews",
            "网易新闻": "com.netease.newsreader.activity",
            "新浪新闻": "com.sina.news",
            "澎湃新闻": "com.thepaper.news",
            "搜狐新闻": "com.sohu.newsclient",
            "腾讯地图": "com.tencent.map",
            "滴滴出行": "com.sdu.didi.psnger",
            "哈啰出行": "com.hellobike",
            "曹操出行": "com.caocao.gulf",
            "携程": "ctrip.android.view",
            "去哪儿": "com.Qunar",
            "同程旅行": "com.tongcheng.android",
            "12306": "com.MobileTicket",
            "高铁管家": "com.huochebang.station",
            "车来了": "com.ygkj.chelaile.standard",
            "腾讯会议": "com.tencent.wemeet.app",
            "钉钉": "com.alibaba.android.rimet",
            "企业微信": "com.tencent.wework",
            "飞书": "com.ss.android.lark",
            "WPS Office": "cn.wps.moffice_eng",
            "OneNote": "com.microsoft.office.onenote",
            "Word": "com.microsoft.office.word",
            "Excel": "com.microsoft.office.excel",
            "PowerPoint": "com.microsoft.office.powerpoint",
            "Outlook": "com.microsoft.office.outlook",
            "Notion": "com.notion.android",
            "印象笔记": "com.yinxiang",
            "Todoist": "com.todoist",
            "滴答清单": "com.ticktick.task",
            "Forest": "cc.forestapp",
            "Google Keep": "com.google.android.keep",
            "网易有道词典": "com.youdao.dict",
            "喜马拉雅": "com.ximalaya.ting.android",
            "荔枝": "com.lizhi.fm",
            "Kindle": "com.amazon.kindle",
            "掌阅": "com.chaozh.iReaderFree",
            "多看阅读": "com.duokan.reader",
            "微信读书": "com.tencent.weread",
            "得到": "com.luojilab.player",
            "百度网盘": "com.baidu.netdisk",
            "阿里云盘": "com.alicloud.databox",
            "夸克": "com.quark.browser",
            "QQ邮箱": "com.tencent.androidqqmail",
            "网易邮箱大师": "com.netease.mail",
            "Gmail": "com.google.android.gm",
            "Firefox": "org.mozilla.firefox",
            "Brave": "com.brave.browser",
            "Keep健身": "com.gotokeep.keep",
            "咕咚": "com.codoon.gps",
            "Nike Run Club": "com.nike.plusgps",
            "华为运动健康": "com.huawei.health",
            "Zepp Life": "com.huami.watch.hmwatchmanager",
            "Fitbit": "com.fitbit.FitbitMobile",
            "米家": "com.xiaomi.smarthome",
            "华为智能家居": "com.huawei.smarthome",
            "Philips Hue": "com.philips.lighting.hue2",
            "盒马": "com.wudaokou.hippo",
            "大众点评": "com.dianping.v1",
            "美团外卖": "com.sankuai.meituan.takeoutnew",
            "肯德基": "com.yum.android.kfc",
            "麦当劳": "com.mcdonalds.gma.cn",
            "星巴克": "com.starbucks.cn",
            "必胜客": "com.yum.pizzahut",
            "得物": "com.shizhuang.duapp",
            "闲鱼": "com.taobao.idlefish",
            "1688": "com.alibaba.wireless",
            "苏宁易购": "com.suning.mobile.ebuy",
            "京东金融": "com.jd.jrapp",
            "云闪付": "com.unionpay",
            "招商银行": "com.cmbchina.ccd.pluto.cmbActivity",
            "微信国际版": "com.weico.international",
            "Instagram": "com.instagram.android",
            "WhatsApp": "com.whatsapp",
            "LINE": "jp.naver.line.android",
            "Messenger": "com.facebook.orca",
            "Snapchat": "com.snapchat.android",
            "Discord": "com.discord",
            "Slack": "com.Slack",
            "Zoom": "us.zoom.videomeetings",
            "Teams": "com.microsoft.teams",
            "Skype": "com.skype.raider",
            "腾讯课堂": "com.tencent.edu",
            "网易云课堂": "com.netease.edu.study",
            "学习强国": "cn.xuexi.android",
            "Coursera": "org.coursera.android",
            "Khan Academy": "org.khanacademy.android",
            "Duolingo": "com.duolingo",
            "Google Classroom": "com.google.android.apps.classroom",
            "Memrise": "com.memrise.android.memrisecompanion",
            "Speedtest": "com.ookla.speedtest",
            "Airbnb": "com.airbnb.android",
            "Booking": "com.booking"
        };
        
        // --- [v6.6.0] 腾讯云 CloudBase 初始化 ---
        const TCB_ENV_ID = 'cloud1-8gvjsmyd7860b4a3';
        
        // 全局变量声明（等待 SDK 加载后初始化）
        let app = null;
        let auth = null;
        let db = null;
        let _ = null;
        let cloudbaseInitialized = false;
        
        // SDK 初始化函数（带重试）
        function initCloudBase() {
            // 检查各种可能的全局变量名
            const sdk = window.cloudbase || window.CloudBase || window.tcb;
            
            if (!sdk) {
                console.error('[CloudBase] SDK not available. cloudbase:', typeof cloudbase, 
                    ', CloudBase:', typeof CloudBase, ', tcb:', typeof tcb);
                console.error('[CloudBase] SDK loaded flag:', window.cloudbaseSDKLoaded);
                console.error('[CloudBase] SDK error:', window.cloudbaseSDKError);
                return false;
            }
            
            try {
                // v2 SDK 初始化只需要 env 和 region
                app = sdk.init({
                    env: TCB_ENV_ID,
                    region: 'ap-shanghai' // 上海地域
                });
                
                auth = app.auth();
                db = app.database();
                _ = db.command; // 数据库操作符
                
                cloudbaseInitialized = true;
                console.log('[CloudBase] SDK initialized successfully');
                return true;
            } catch (e) {
                console.error('[CloudBase] Init error:', e);
                return false;
            }
        }
        
        // 等待 SDK 加载后再初始化
        function waitForCloudBase(callback, maxRetries = 20, interval = 200) {
            let retries = 0;
            
            function tryInit() {
                if (initCloudBase()) {
                    if (callback) callback(true);
                    return;
                }
                
                retries++;
                if (retries < maxRetries) {
                    console.log(`[CloudBase] Waiting for SDK... (${retries}/${maxRetries})`);
                    setTimeout(tryInit, interval);
                } else {
                    console.error('[CloudBase] SDK failed to load after', maxRetries, 'retries');
                    if (callback) callback(false);
                }
            }
            
            tryInit();
        }
        
        // 启动初始化等待
        waitForCloudBase(function(success) {
            if (success) {
                console.log('[CloudBase] Ready to use');
                // 尝试恢复登录状态
                refreshLoginState().then(state => {
                    if (state) {
                        console.log('[CloudBase] Login state restored');
                    }
                });
            } else {
                console.error('[CloudBase] Failed to initialize');
            }
        });
        
        // [v6.6.0] 缓存登录状态（避免频繁异步调用）
        let cachedLoginState = null;
        
        // 同步检查是否已登录（使用缓存）
        function isLoggedIn() {
            return cachedLoginState && cachedLoginState.user;
        }
        
        // 异步刷新登录状态缓存
        async function refreshLoginState() {
            // 确保 auth 已初始化
            if (!cloudbaseInitialized || !auth) {
                console.warn('[Auth] refreshLoginState called before SDK init');
                cachedLoginState = null;
                return null;
            }
            
            try {
                // CloudBase v2 hasLoginState() 同步返回 LoginState 或 null
                cachedLoginState = auth.hasLoginState();
                console.log('[Auth] Login state:', cachedLoginState ? 'logged in' : 'not logged in');
            } catch (e) {
                console.warn('[Auth] hasLoginState error:', e);
                cachedLoginState = null;
            }
            return cachedLoginState;
        }
        
        // ============================================================================
        // [v6.6.0] 多表数据访问层 (DAL - Data Access Layer) - CloudBase 版
        // 将单一 JSON 重构为 5 张独立表，实现细粒度同步
        // ============================================================================
        
        // --- 架构开关 ---
        const USE_MULTI_TABLE = true; // 已启用多表架构
        const MULTI_TABLE_VERSION = 2; // 多表架构版本号 (CloudBase)
        
        // --- 表定义 (CloudBase 集合名) ---
        const TABLES = {
            PROFILE: 'tb_profile',      // 用户配置（1条/用户）
            TASK: 'tb_task',            // 任务表（N条/用户）
            TRANSACTION: 'tb_transaction', // 交易表（只增不改）
            RUNNING: 'tb_running',      // 运行中任务（临时表）
            DAILY: 'tb_daily'           // 每日汇总（缓存表）
        };
        
        // --- 实时监听管理 (替代 LeanCloud LiveQuery) ---
        const watchers = {
            profile: null,
            task: null,
            transaction: null,
            running: null
        };
        
        // --- 多表 DAL 核心 ---
        const DAL = {
            // ========== 初始化 ==========
            async init() {
                // 使用同步版本检查登录状态
                const loginState = auth.hasLoginState();
                if (!loginState) return false;
                
                // 检查是否需要导入数据（新用户）
                const profileExists = await this.checkProfileExists();
                return profileExists;
            },
            
            // ========== 检查 Profile 是否存在 ==========
            async checkProfileExists() {
                try {
                    const res = await db.collection(TABLES.PROFILE).limit(1).get();
                    return res.data && res.data.length > 0;
                } catch (e) {
                    console.error('[DAL] checkProfileExists error:', e);
                    return false;
                }
            },
            
            // ========== 创建空 Profile ==========
            async createEmptyProfile() {
                const loginState = auth.hasLoginState();
                if (!loginState) throw new Error('未登录');
                
                const res = await db.collection(TABLES.PROFILE).add({
                    multiTableVersion: MULTI_TABLE_VERSION,
                    settings: {},
                    reportState: {},
                    categoryColors: [],
                    collapsedCategories: [],
                    cachedBalance: 0,
                    createdAt: db.serverDate()
                });
                
                return res.id;
            },
            
            // ========== 从备份导入数据 (CloudBase 版) ==========
            async importFromBackup(data) {
                // 使用同步版本检查登录状态
                const loginState = auth.hasLoginState();
                if (!loginState) throw new Error('未登录');
                
                console.log('🚀 [DAL] 开始导入备份数据...');
                setAuthStatus('正在导入数据...', 'status-syncing');
                
                // 1. 清理现有数据
                await this.clearAllData();
                
                // 2. 创建 Profile
                await db.collection(TABLES.PROFILE).add({
                    multiTableVersion: MULTI_TABLE_VERSION,
                    settings: data.notificationSettings || {},
                    reportState: data.reportState || {},
                    categoryColors: data.categoryColors || [],
                    collapsedCategories: data.collapsedCategories || [],
                    cachedBalance: data.currentBalance || 0,
                    importedAt: db.serverDate()
                });
                console.log('✅ [DAL] Profile 导入完成');
                
                // 3. 导入 Tasks
                const oldTasks = data.tasks || [];
                for (const t of oldTasks) {
                    await db.collection(TABLES.TASK).add({
                        taskId: t.id,
                        name: t.name,
                        category: t.category,
                        amount: t.amount,
                        unit: t.unit || 'minutes',
                        type: t.type,
                        multiplier: t.multiplier || 1,
                        isHabit: t.isHabit || false,
                        habitDetails: t.habitDetails || null,
                        enableFloatingTimer: t.enableFloatingTimer || false,
                        lastUsed: t.lastUsed || null,
                        isSystem: t.isSystem || false,
                        data: t
                    });
                }
                console.log(`✅ [DAL] ${oldTasks.length} 个任务导入完成`);
                
                // 4. 导入 Transactions (分批)
                const oldTransactions = data.transactions || [];
                const BATCH_SIZE = 20;
                for (let i = 0; i < oldTransactions.length; i += BATCH_SIZE) {
                    const batch = oldTransactions.slice(i, i + BATCH_SIZE);
                    for (const tx of batch) {
                        await db.collection(TABLES.TRANSACTION).add({
                            txId: tx.id,
                            taskId: tx.taskId,
                            taskName: tx.taskName,
                            amount: tx.amount,
                            type: tx.type,
                            timestamp: tx.timestamp,
                            description: tx.description || '',
                            isStreakAdvancement: tx.isStreakAdvancement || false,
                            isSystem: tx.isSystem || false,
                            data: tx
                        });
                    }
                    console.log(`✅ [DAL] 交易批次 ${Math.floor(i/BATCH_SIZE) + 1} 导入完成`);
                }
                console.log(`✅ [DAL] 共 ${oldTransactions.length} 条交易导入完成`);
                
                // 5. 导入 DailyChanges
                const oldDaily = data.dailyChanges || {};
                for (const [date, d] of Object.entries(oldDaily)) {
                    await db.collection(TABLES.DAILY).add({
                        date: date,
                        earned: d.earned || 0,
                        spent: d.spent || 0
                    });
                }
                console.log(`✅ [DAL] ${Object.keys(oldDaily).length} 条日汇总导入完成`);
                
                console.log('🎉 [DAL] 数据导入完成！');
                setAuthStatus('导入完成 ✅', 'status-online');
                showNotification('🎉 数据导入完成', '您的数据已成功导入！', 'achievement');
            },
            
            // ========== 清理所有数据 ==========
            async clearAllData() {
                const collections = [TABLES.PROFILE, TABLES.TASK, TABLES.TRANSACTION, TABLES.RUNNING, TABLES.DAILY];
                for (const col of collections) {
                    let hasMore = true;
                    while (hasMore) {
                        try {
                            const res = await db.collection(col).limit(100).get();
                            // 防御性检查：确保 res.data 存在
                            if (!res || !res.data || res.data.length === 0) {
                                hasMore = false;
                            } else {
                                for (const doc of res.data) {
                                    await db.collection(col).doc(doc._id).remove();
                                }
                            }
                        } catch (e) {
                            console.warn(`[DAL] clearAllData error on ${col}:`, e);
                            hasMore = false; // 出错则跳过这个集合
                        }
                    }
                }
                console.log('✅ [DAL] 所有数据已清理');
            },
            
            // ========== Profile 操作 ==========
            profileId: null,
            profileData: null,
            
            async loadProfile() {
                const res = await db.collection(TABLES.PROFILE).limit(1).get();
                if (res.data && res.data.length > 0) {
                    this.profileId = res.data[0]._id;
                    this.profileData = res.data[0];
                    return this.profileData;
                }
                return null;
            },
            
            async saveProfile(data) {
                if (!this.profileId) {
                    await this.loadProfile();
                }
                if (!this.profileId) {
                    throw new Error('Profile 不存在');
                }
                
                await db.collection(TABLES.PROFILE).doc(this.profileId).update(data);
                Object.assign(this.profileData, data);
                return this.profileData;
            },
            
            // ========== Task 操作 ==========
            taskCache: new Map(), // taskId -> _id (CloudBase doc id)
            
            async loadAllTasks() {
                const res = await db.collection(TABLES.TASK).limit(1000).get();
                
                this.taskCache.clear();
                const taskMap = new Map();
                
                // 去重逻辑
                (res.data || []).forEach(doc => {
                    const task = doc.data || {
                        id: doc.taskId,
                        name: doc.name,
                        category: doc.category,
                        amount: doc.amount,
                        unit: doc.unit,
                        type: doc.type,
                        multiplier: doc.multiplier,
                        isHabit: doc.isHabit,
                        habitDetails: doc.habitDetails,
                        enableFloatingTimer: doc.enableFloatingTimer,
                        lastUsed: doc.lastUsed,
                        isSystem: doc.isSystem
                    };
                    
                    if (taskMap.has(task.id)) {
                        // 保留较新的，删除旧的
                        db.collection(TABLES.TASK).doc(doc._id).remove();
                    } else {
                        taskMap.set(task.id, { task, docId: doc._id });
                    }
                });
                
                const tasks = [];
                taskMap.forEach(({ task, docId }) => {
                    this.taskCache.set(task.id, docId);
                    tasks.push(task);
                });
                
                return tasks;
            },
            
            async saveTask(task) {
                const existingDocId = this.taskCache.get(task.id);
                
                const taskData = {
                    taskId: task.id,
                    name: task.name,
                    category: task.category,
                    amount: task.amount,
                    unit: task.unit || 'minutes',
                    type: task.type,
                    multiplier: task.multiplier || 1,
                    isHabit: task.isHabit || false,
                    habitDetails: task.habitDetails || null,
                    enableFloatingTimer: task.enableFloatingTimer || false,
                    lastUsed: task.lastUsed || null,
                    isSystem: task.isSystem || false,
                    data: task
                };
                
                if (existingDocId) {
                    await db.collection(TABLES.TASK).doc(existingDocId).update(taskData);
                } else {
                    const res = await db.collection(TABLES.TASK).add(taskData);
                    this.taskCache.set(task.id, res.id);
                }
            },
            
            async deleteTask(taskId) {
                const docId = this.taskCache.get(taskId);
                if (docId) {
                    await db.collection(TABLES.TASK).doc(docId).remove();
                    this.taskCache.delete(taskId);
                }
            },
            
            // ========== Transaction 操作 ==========
            transactionCache: new Map(), // txId -> _id
            
            async loadAllTransactions() {
                const res = await db.collection(TABLES.TRANSACTION)
                    .orderBy('timestamp', 'desc')
                    .limit(1000)
                    .get();
                
                this.transactionCache.clear();
                const txMap = new Map();
                
                // 去重逻辑
                (res.data || []).forEach(doc => {
                    const tx = doc.data || {
                        id: doc.txId,
                        taskId: doc.taskId,
                        taskName: doc.taskName,
                        amount: doc.amount,
                        type: doc.type,
                        timestamp: doc.timestamp,
                        description: doc.description,
                        isStreakAdvancement: doc.isStreakAdvancement,
                        isSystem: doc.isSystem
                    };
                    
                    if (txMap.has(tx.id)) {
                        // 删除重复
                        db.collection(TABLES.TRANSACTION).doc(doc._id).remove();
                    } else {
                        txMap.set(tx.id, { tx, docId: doc._id });
                    }
                });
                
                const transactions = [];
                txMap.forEach(({ tx, docId }) => {
                    this.transactionCache.set(tx.id, docId);
                    transactions.push(tx);
                });
                
                transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                return transactions;
            },
            
            async addTransaction(tx) {
                const res = await db.collection(TABLES.TRANSACTION).add({
                    txId: tx.id,
                    taskId: tx.taskId,
                    taskName: tx.taskName,
                    amount: tx.amount,
                    type: tx.type,
                    timestamp: tx.timestamp,
                    description: tx.description || '',
                    isStreakAdvancement: tx.isStreakAdvancement || false,
                    isSystem: tx.isSystem || false,
                    rawSeconds: tx.rawSeconds,
                    data: tx
                });
                
                this.transactionCache.set(tx.id, res.id);
                
                // 更新日汇总和余额
                await this.updateDailyChange(tx);
                await this.updateCachedBalance(tx.type === 'earn' ? tx.amount : -tx.amount);
                
                return res.id;
            },
            
            async deleteTransaction(txId) {
                const docId = this.transactionCache.get(txId);
                if (docId) {
                    // 获取交易数据用于反向更新
                    const res = await db.collection(TABLES.TRANSACTION).doc(docId).get();
                    const tx = res.data?.data || res.data;
                    
                    await db.collection(TABLES.TRANSACTION).doc(docId).remove();
                    this.transactionCache.delete(txId);
                    
                    if (tx) {
                        await this.updateCachedBalance(tx.type === 'earn' ? -tx.amount : tx.amount);
                        await this.updateDailyChange(tx, true);
                    }
                }
            },
            
            // ========== RunningTask 操作 ==========
            runningCache: new Map(), // taskId -> _id
            
            async loadRunningTasks() {
                const res = await db.collection(TABLES.RUNNING).get();
                
                this.runningCache.clear();
                const running = new Map();
                
                (res.data || []).forEach(doc => {
                    const taskId = doc.taskId;
                    const data = doc.data || {
                        startTime: doc.startTime,
                        accumulatedTime: doc.accumulatedTime,
                        isPaused: doc.isPaused
                    };
                    this.runningCache.set(taskId, doc._id);
                    running.set(taskId, data);
                });
                
                return running;
            },
            
            async startTask(taskId, data) {
                const existingDocId = this.runningCache.get(taskId);
                
                const runningData = {
                    taskId: taskId,
                    startTime: data.startTime,
                    accumulatedTime: data.accumulatedTime || 0,
                    isPaused: data.isPaused || false,
                    clientId: clientId,
                    data: data
                };
                
                if (existingDocId) {
                    await db.collection(TABLES.RUNNING).doc(existingDocId).update(runningData);
                } else {
                    const res = await db.collection(TABLES.RUNNING).add(runningData);
                    this.runningCache.set(taskId, res.id);
                }
            },
            
            async stopTask(taskId) {
                const docId = this.runningCache.get(taskId);
                if (docId) {
                    await db.collection(TABLES.RUNNING).doc(docId).remove();
                    this.runningCache.delete(taskId);
                }
            },
            
            async updateRunningTask(taskId, data) {
                const docId = this.runningCache.get(taskId);
                if (docId) {
                    await db.collection(TABLES.RUNNING).doc(docId).update({
                        accumulatedTime: data.accumulatedTime || 0,
                        isPaused: data.isPaused || false,
                        data: data
                    });
                }
            },
            
            // ========== DailyChange 操作 ==========
            dailyCache: new Map(), // date -> _id
            
            async loadDailyChanges() {
                const res = await db.collection(TABLES.DAILY).limit(1000).get();
                
                this.dailyCache.clear();
                const daily = {};
                
                (res.data || []).forEach(doc => {
                    const date = doc.date;
                    this.dailyCache.set(date, doc._id);
                    daily[date] = {
                        earned: doc.earned || 0,
                        spent: doc.spent || 0
                    };
                });
                
                return daily;
            },
            
            async updateDailyChange(tx, reverse = false) {
                const date = getLocalDateString(new Date(tx.timestamp));
                const existingDocId = this.dailyCache.get(date);
                const multiplier = reverse ? -1 : 1;
                const earnDelta = tx.type === 'earn' ? tx.amount * multiplier : 0;
                const spendDelta = tx.type === 'spend' ? tx.amount * multiplier : 0;
                
                if (existingDocId) {
                    await db.collection(TABLES.DAILY).doc(existingDocId).update({
                        earned: _.inc(earnDelta),
                        spent: _.inc(spendDelta)
                    });
                } else {
                    const res = await db.collection(TABLES.DAILY).add({
                        date: date,
                        earned: earnDelta > 0 ? earnDelta : 0,
                        spent: spendDelta > 0 ? spendDelta : 0
                    });
                    this.dailyCache.set(date, res.id);
                }
            },
            
            // ========== 余额操作 ==========
            async updateCachedBalance(delta) {
                if (!this.profileId) {
                    await this.loadProfile();
                }
                if (this.profileId) {
                    await db.collection(TABLES.PROFILE).doc(this.profileId).update({
                        cachedBalance: _.inc(delta)
                    });
                    if (this.profileData) {
                        this.profileData.cachedBalance = (this.profileData.cachedBalance || 0) + delta;
                    }
                }
            },
            
            async recalculateBalance() {
                const transactions = await this.loadAllTransactions();
                let balance = 0;
                transactions.forEach(tx => {
                    balance += tx.type === 'earn' ? tx.amount : -tx.amount;
                });
                
                if (this.profileId) {
                    await db.collection(TABLES.PROFILE).doc(this.profileId).update({
                        cachedBalance: balance
                    });
                    if (this.profileData) {
                        this.profileData.cachedBalance = balance;
                    }
                }
                
                return balance;
            },
            
            // ========== CloudBase 实时监听 ==========
            async subscribeAll() {
                const loginState = auth.hasLoginState();
                if (!loginState) return;
                
                // [v6.6.0] 防止重复订阅：先取消现有订阅
                await this.unsubscribeAll();
                
                // 监听 Task 表
                watchers.task = db.collection(TABLES.TASK)
                    .where({})
                    .watch({
                        onChange: (snapshot) => {
                            console.log('📡 [DAL] Task 变更:', snapshot.type);
                            for (const change of snapshot.docChanges) {
                                const doc = change.doc;
                                if (change.dataType === 'add') {
                                    const task = doc.data;
                                    if (task && !this.taskCache.has(task.id) && !tasks.some(t => t.id === task.id)) {
                                        this.taskCache.set(task.id, doc);
                                        tasks.push(task);
                                    }
                                } else if (change.dataType === 'update') {
                                    const task = doc.data;
                                    if (task) {
                                        this.taskCache.set(task.id, doc);
                                        const idx = tasks.findIndex(t => t.id === task.id);
                                        if (idx >= 0) {
                                            tasks[idx] = task;
                                        } else {
                                            tasks.push(task);
                                        }
                                    }
                                } else if (change.dataType === 'remove') {
                                    const taskId = doc.taskId;
                                    console.log('📡 [DAL] 任务删除:', taskId);
                                    this.taskCache.delete(taskId);
                                    tasks = tasks.filter(t => t.id !== taskId);
                                }
                            }
                            updateAllUI();
                        },
                        onError: (err) => {
                            console.error('❌ [DAL] Task watch error:', err);
                        }
                    });
                
                // 监听 Transaction 表
                watchers.transaction = db.collection(TABLES.TRANSACTION)
                    .where({})
                    .watch({
                        onChange: (snapshot) => {
                            console.log('📡 [DAL] Transaction 变更:', snapshot.type);
                            for (const change of snapshot.docChanges) {
                                const doc = change.doc;
                                if (change.dataType === 'add') {
                                    const tx = doc.data;
                                    if (tx && !this.transactionCache.has(tx.id) && !transactions.some(t => t.id === tx.id)) {
                                        this.transactionCache.set(tx.id, doc);
                                        transactions.unshift(tx);
                                        currentBalance += tx.type === 'earn' ? tx.amount : -tx.amount;
                                        const date = getLocalDateString(new Date(tx.timestamp));
                                        if (!dailyChanges[date]) dailyChanges[date] = { earned: 0, spent: 0 };
                                        if (tx.type === 'earn') {
                                            dailyChanges[date].earned += tx.amount;
                                        } else {
                                            dailyChanges[date].spent += tx.amount;
                                        }
                                    }
                                } else if (change.dataType === 'remove') {
                                    const txId = doc.txId;
                                    console.log('📡 [DAL] 交易删除:', txId);
                                    const existingTx = transactions.find(t => t.id === txId);
                                    if (existingTx) {
                                        currentBalance -= existingTx.type === 'earn' ? existingTx.amount : -existingTx.amount;
                                    }
                                    this.transactionCache.delete(txId);
                                    transactions = transactions.filter(t => t.id !== txId);
                                }
                            }
                            updateAllUI();
                        },
                        onError: (err) => {
                            console.error('❌ [DAL] Transaction watch error:', err);
                        }
                    });
                
                // 监听 RunningTask 表
                watchers.running = db.collection(TABLES.RUNNING)
                    .where({})
                    .watch({
                        onChange: (snapshot) => {
                            console.log('📡 [DAL] Running 变更:', snapshot.type);
                            for (const change of snapshot.docChanges) {
                                const doc = change.doc;
                                const taskId = doc.taskId;
                                const remoteClientId = doc.clientId;
                                
                                if (change.dataType === 'add') {
                                    const data = doc.data;
                                    console.log('📡 [DAL] 任务开始:', taskId);
                                    if (!runningTasks.has(taskId)) {
                                        this.runningCache.set(taskId, doc);
                                        runningTasks.set(taskId, data);
                                    }
                                } else if (change.dataType === 'update') {
                                    const data = doc.data;
                                    // 忽略自己触发的更新
                                    if (remoteClientId === clientId) {
                                        console.log(`🛡️ [DAL] 忽略 update 事件: 本机触发 (taskId=${taskId})`);
                                        continue;
                                    }
                                    // 保护期检查
                                    const timeSinceLastSave = Date.now() - lastSuccessfulSaveTime;
                                    if (timeSinceLastSave < LIVEQUERY_GRACE_PERIOD) {
                                        console.log(`🛡️ [DAL] 忽略 update 事件: 保护期内 (${Math.round(timeSinceLastSave/1000)}s)`);
                                        continue;
                                    }
                                    console.log('📡 [DAL] 任务状态更新:', taskId, data?.isPaused ? '(已暂停)' : '(运行中)', `(来自其他设备)`);
                                    this.runningCache.set(taskId, doc);
                                    if (data && runningTasks.has(taskId)) {
                                        runningTasks.set(taskId, data);
                                    }
                                } else if (change.dataType === 'remove') {
                                    // [v6.4.6] 保护机制
                                    const timeSinceLastSave = Date.now() - lastSuccessfulSaveTime;
                                    if (timeSinceLastSave < LIVEQUERY_GRACE_PERIOD) {
                                        console.log(`🛡️ [DAL] 忽略 delete 事件: 保护期内 (${Math.round(timeSinceLastSave/1000)}s < ${LIVEQUERY_GRACE_PERIOD/1000}s)`);
                                        continue;
                                    }
                                    if (remoteClientId === clientId && !runningTasks.has(taskId)) {
                                        console.log(`🛡️ [DAL] 忽略 delete 事件: 本地已处理 (taskId=${taskId})`);
                                        continue;
                                    }
                                    console.log('📡 [DAL] 任务停止:', taskId, `(来自 ${remoteClientId === clientId ? '本机' : '其他设备'})`);
                                    this.runningCache.delete(taskId);
                                    runningTasks.delete(taskId);
                                }
                            }
                            updateAllUI();
                        },
                        onError: (err) => {
                            console.error('❌ [DAL] Running watch error:', err);
                        }
                    });
                
                // 监听 Profile 表
                watchers.profile = db.collection(TABLES.PROFILE)
                    .where({})
                    .watch({
                        onChange: (snapshot) => {
                            console.log('📡 [DAL] Profile 变更');
                            for (const change of snapshot.docChanges) {
                                if (change.dataType === 'update') {
                                    const doc = change.doc;
                                    profileData = doc;
                                    notificationSettings = doc.settings || {};
                                    categoryColors = new Map(doc.categoryColors || []);
                                    collapsedCategories = new Set(doc.collapsedCategories || []);
                                    updateAllUI();
                                    updateNotificationSettingsUI();
                                }
                            }
                        },
                        onError: (err) => {
                            console.error('❌ [DAL] Profile watch error:', err);
                        }
                    });
                
                console.log('✅ [DAL] 所有表实时监听已启动');
                setAuthStatus('已同步 ✅', 'status-online');
            },
            
            async unsubscribeAll() {
                for (const key of Object.keys(watchers)) {
                    if (watchers[key]) {
                        await watchers[key].close();
                        watchers[key] = null;
                    }
                }
            },
            
            // ========== 完整加载 ==========
            async loadAll() {
                console.log('🔄 [DAL] 开始加载所有数据...');
                setAuthStatus('加载中...', 'status-syncing');
                
                const [profile, loadedTasks, loadedTransactions, loadedRunning, loadedDaily] = await Promise.all([
                    this.loadProfile(),
                    this.loadAllTasks(),
                    this.loadAllTransactions(),
                    this.loadRunningTasks(),
                    this.loadDailyChanges()
                ]);
                
                if (!profile) {
                    throw new Error('Profile 不存在，请先导入数据');
                }
                
                // 应用到全局状态 (CloudBase 直接访问属性)
                profileData = profile;
                tasks = loadedTasks;
                transactions = loadedTransactions;
                runningTasks = loadedRunning;
                dailyChanges = loadedDaily;
                currentBalance = profile.cachedBalance || 0;
                notificationSettings = profile.settings || {};
                categoryColors = new Map(profile.categoryColors || []);
                collapsedCategories = new Set(profile.collapsedCategories || []);
                
                // 设置为已完成首次同步
                hasCompletedFirstCloudSync = true;
                
                console.log(`✅ [DAL] 加载完成: ${tasks.length}任务, ${transactions.length}交易, ${runningTasks.size}运行中`);
                
                // 订阅实时更新
                await this.subscribeAll();
                
                return true;
            }
        };
        
        // ============================================================================
        // [v6.0.0] 多表架构 END
        // ============================================================================
        
        // --- App State ---
        let currentBalance = 0; 
        let tasks = []; 
        let transactions = []; 
        let categoryColors = new Map(); 
        let collapsedCategories = new Set(); 
        let expandedTaskCategories = new Set(); // [v5.0.0] 记录已展开全部任务的分类
        let runningTasks = new Map();
        let currentEditingTask = null; 
        let timerInterval = null; 
        let dailyChanges = {}; 
        let currentHistoryTask = null; 
        let currentSelectedColor = null;
        let activeMenuTaskId = null; // 用于在重绘时保持菜单打开状态
        let currentBackdateTaskId = null; // [v3.11.0] For backdate modal
        let currentBackdateMode = 'duration'; // [v3.11.0] 'duration' or 'range'
        let isProcessingNudge = false; // [v4.3.8] 异步锁，防止 Habit Nudge 循环
        let highlightedHabits = new Set(); // [v4.4.0] 存储高亮的未完成习惯 ID
        let highlightTimer = null; // [v4.4.0] 管理高亮状态的 30 分钟计时器
        
        // [v4.5.0] 任务历史日历视图的状态
        let currentHistoryView = 'list'; // 'list' or 'calendar'
        let currentHistoryCalendarDate = new Date(); // 用于日历的月份导航
        
        // [v4.5.2] Pie chart render optimization
        let pendingPieRender = null;
        
        // [v4.8.0] 本地保护机制：记录用户最后一次操作时间戳
        let lastLocalActionTime = 0;
        
        // [v6.0.0] 休眠恢复保护：记录页面进入休眠的时间
        let lastHibernateTime = 0;
        let isRecoveringFromHibernate = false; // 标记正在从休眠恢复


        let reportState = { 
            heatmapDate: new Date(), 
            analysisPeriod: '7d', // [v5.1.0] Default to 7 days
            analysisView: 'category', 
            trendPeriod: '30d', 
            trendView: 'category', 
            tablePeriod: 'all', 
            tableView: 'category', 
            tableSortKey: 'amount_abs_desc',
            tableVisibleRows: 10,
            insightView: 'chart',
            insightSubViewIndex: 0
        };
        // [v3.15.0] Added habitNudge settings
	// [v4.6.1] Added floatingTimer setting
        let notificationSettings = { 
            achievement: true, 
            longRunning: false, 
            longRunningThreshold: 3600, 
            lowBalance: false, 
            lowBalanceThreshold: 1800,
            lastLowBalanceAlertDate: null,
            habitNudgeEnabled: false,
            habitNudgeTime: '21:00',
            lastNudgeDate: null,
	    floatingTimerPermissionPrompted: false,
	    floatingTimer: true, // [New] 默认开启悬浮窗
            // [v6.4.5] 戒除奖励显示模式: 'offset'抵扣消费, 'separate'独立分类
            abstinenceRewardMode: 'offset',
            abstinenceRewardModePrompted: false // 是否已显示过选择弹窗
        };

        // [v5.2.0] 动态应用列表缓存
        let dynamicAppList = null;
        let dynamicAppListFetched = false; // 避免每次打开编辑都重新拉取应用列表
        let appDropdownVisible = false;

        function populateAppSuggestions() {
            if (dynamicAppListFetched) return; // 已经尝试加载过，避免重复耗时调用
            dynamicAppListFetched = true;

            // [v5.2.0] 预加载已安装应用列表
            if (typeof Android !== 'undefined' && Android.getInstalledApps) {
                try {
                    const appsJson = Android.getInstalledApps();
                    dynamicAppList = JSON.parse(appsJson);
                    dynamicAppList.sort((a, b) => a.appName.localeCompare(b.appName, 'zh'));
                    console.log(`[AppList] Loaded ${dynamicAppList.length} installed apps`);
                } catch (e) {
                    console.error('[AppList] Failed to load:', e);
                    dynamicAppList = null;
                }
            }
        }

        function showAppDropdown() {
            const dropdown = document.getElementById('appDropdownList');
            if (!dropdown) return;
            
            // 如果有动态列表，显示下拉
            if (dynamicAppList && dynamicAppList.length > 0) {
                filterAppList();
                dropdown.classList.remove('hidden');
                appDropdownVisible = true;
            }
        }

        function hideAppDropdown() {
            const dropdown = document.getElementById('appDropdownList');
            if (dropdown) {
                dropdown.classList.add('hidden');
                appDropdownVisible = false;
            }
        }

        function filterAppList() {
            const dropdown = document.getElementById('appDropdownList');
            const input = document.getElementById('taskAppPackage');
            if (!dropdown || !input) return;
            
            const filter = input.value.toLowerCase().trim();
            
            // 优先使用动态列表，降级使用内置词典
            let apps = [];
            if (dynamicAppList && dynamicAppList.length > 0) {
                apps = dynamicAppList;
            } else {
                // 降级：使用内置 APP_DIRECTORY
                apps = Object.entries(APP_DIRECTORY).map(([name, pkg]) => ({
                    appName: name,
                    packageName: pkg
                }));
            }
            
            // 过滤匹配
            const filtered = apps.filter(app => 
                app.appName.toLowerCase().includes(filter) || 
                app.packageName.toLowerCase().includes(filter)
            ).slice(0, 20); // 最多显示 20 个
            
            if (filtered.length === 0) {
                dropdown.innerHTML = '<div class="app-dropdown-item" style="color: var(--text-color-light); cursor: default;">无匹配应用，可直接输入包名</div>';
            } else {
                dropdown.innerHTML = filtered.map(app => `
                    <div class="app-dropdown-item" onclick="selectApp('${app.packageName}', '${app.appName.replace(/'/g, "\\'")}')">
                        <div class="app-dropdown-item-name">${app.appName}</div>
                        <div class="app-dropdown-item-pkg">${app.packageName}</div>
                    </div>
                `).join('');
            }
            
            dropdown.classList.remove('hidden');
            appDropdownVisible = true;
        }

        function selectApp(packageName, appName) {
            const input = document.getElementById('taskAppPackage');
            if (input) {
                // 显示应用名，实际值存储包名
                input.value = appName;
                input.dataset.selectedPackage = packageName;
            }
            hideAppDropdown();
        }

        // 点击外部关闭下拉列表
        document.addEventListener('click', function(e) {
            if (appDropdownVisible) {
                const dropdown = document.getElementById('appDropdownList');
                const input = document.getElementById('taskAppPackage');
                if (dropdown && input && !dropdown.contains(e.target) && e.target !== input) {
                    hideAppDropdown();
                }
            }
        });

        function resolveAppInputValue(appPackage) {
            if (!appPackage) return '';
            // 先从动态列表查找
            if (dynamicAppList) {
                const found = dynamicAppList.find(app => app.packageName === appPackage);
                if (found) return found.appName;
            }
            // 降级：从内置词典查找
            const entry = Object.entries(APP_DIRECTORY).find(([, pkg]) => pkg === appPackage);
            return entry ? entry[0] : appPackage;
        }

        // [v5.2.0] 获取实际包名（处理用户输入应用名的情况）
        function resolveAppPackage(inputValue) {
            if (!inputValue) return '';
            
            // 1. 检查是否有选中的包名
            const input = document.getElementById('taskAppPackage');
            if (input && input.dataset.selectedPackage) {
                return input.dataset.selectedPackage;
            }
            
            // 2. 从动态列表查找
            if (dynamicAppList) {
                const found = dynamicAppList.find(app => 
                    app.appName === inputValue || app.packageName === inputValue
                );
                if (found) return found.packageName;
            }
            
            // 3. 从内置词典查找
            if (APP_DIRECTORY.hasOwnProperty(inputValue)) {
                return APP_DIRECTORY[inputValue];
            }
            
            // 4. 直接作为包名使用
            return inputValue;
        }
        
        // --- [v4.0.0] Sync State ---
        let cloudDataObject = null; // Stores the AV.Object for the user's data
        let liveQuery = null;       // Stores the LiveQuery subscription
        let isSyncing = false;      // Flag to prevent save loops
        let isSaving = false;       // Flag to prevent concurrent saves
        let saveQueue = null;       // Queue for pending saves

        // [v4.8.7] 启动同步锁：防止App启动时旧数据自动保存覆盖云端新数据
        let hasCompletedFirstCloudSync = false;

        // [v4.8.8] 乐观锁核心：记录最后一次成功同步(读取或保存)时的云端时间戳
        let lastCloudUpdateTime = 0;
        
        // [v5.8.1] 严格版本号系统：每次成功保存+1，必须与云端完全一致才能保存
        let localDataVersion = 0;
        
        // [v6.4.4] 保存后静默期：防止 LiveQuery 收到自己的推送后覆盖本地状态
        // 增加到 8 秒，确保覆盖网络延迟和 LiveQuery 重试
        let lastSuccessfulSaveTime = 0;
        const LIVEQUERY_GRACE_PERIOD = 8000; // 保存后 8 秒内忽略云端推送

        const earnColors = [ '#007f5f', '#2b9348', '#55a630', '#80b918', '#aacc00', '#bfd200', '#d4d700', '#dddf00', '#eeef20', '#ffff3f', '#ade8f4', '#48cae4', '#00b4d8', '#0096c7', '#0077b6', '#023e8a' ];
        const spendColors = [ '#ffbe0b', '#fb5607', '#ff006e', '#8338ec', '#3a86ff', '#ef476f', '#f78c6b', '#ffd166', '#c9184a', '#ff4d6d', '#ff8fa3', '#ffb3c1', '#fca311', '#e85d04', '#dc2f02', '#9d0208' ];
        // [v3.10.3] Standardized colors for task view
        const TASK_VIEW_EARN_COLORS = ['#4CAF50', '#66BB6A', '#81C784', '#A5D6A7', '#C8E6C9'];
        const TASK_VIEW_SPEND_COLORS = ['#f44336', '#FF5722', '#FF9800', '#FFC107', '#F8BBD0'];
        const OTHER_COLOR = '#BDBDBD'; // [v3.10.4] Lighter Gray (was #9E9E9E)
        // [v6.0.0] “其他”分类专用颜色 - 融入各自色系
        const OTHER_EARN_COLOR = '#78909C';  // 蓝灰色，融入绿/蓝色系
        const OTHER_SPEND_COLOR = '#F48FB1'; // 粉红色，融入红/橙色系

        // [v5.2.0] 系统任务常量（用于屏幕时间管理等系统级奖惩）
        const SYSTEM_CATEGORY = '系统';
        const SYSTEM_CATEGORY_COLOR = '#607D8B'; // 蓝灰色
        const SYSTEM_TASKS = {
            SCREEN_TIME: {
                id: 'system-screen-time',
                name: '屏幕时间管理',
                category: SYSTEM_CATEGORY,
                isSystem: true
            }
        };

        // [v4.12.0] Bootstrapper: 检查并初始化示例数据
        async function checkAndBootstrap() {
            // 直接读取原始字符串，不解析 JSON，速度最快且不报错
            const rawData = localStorage.getItem('timeBankData');
            const hasVisited = localStorage.getItem('tb_has_visited');

            // 判定标准：既没有数据主文件，也没有"已访问"标记，才是纯粹的新用户
            if (!rawData && !hasVisited) {
                // 不再弹出任何提示，也不自动导入，保持空白以便 CTA 提示
                localStorage.setItem('tb_has_visited', 'true');
                return false;
            }
            return false; // 老用户
        }

        // --- App Initialization and Core UI ---
        
        // [v4.0.0] Modified initApp
        // [v6.6.0] CloudBase 版本
        async function initApp() {
            console.log("App v6.6.0 Starting (CloudBase)...");
            
            // 1. 检查 CloudBase 登录状态并刷新缓存
            const loginState = await refreshLoginState();
            updateAuthUI(loginState);
            
            // 1.5 引导程序：如需首次初始化示例数据
            await checkAndBootstrap();
            
            // 2. Load Data
            if (isLoggedIn()) {
                try {
                    // 检查是否有数据
                    const hasData = await DAL.init();
                    if (hasData) {
                        await DAL.loadAll();
                    } else {
                        // 新用户或无数据，显示导入提示
                        console.log('[initApp] 无云端数据，显示导入提示');
                        showNotification('📦 需要导入数据', '请在设置页面导入您的备份文件', 'warning');
                    }
                } catch (e) {
                    console.error('[initApp] 数据加载失败:', e);
                    showAlert('数据加载失败: ' + e.message, '错误');
                }
            } else {
                // 未登录，使用本地数据
                await loadData();
            }
            
            populateAppSuggestions();
            
            // 3. Init UI components
            renderColorSelectors(); 
            updateNotificationSettingsUI();
            initScreenTimeSettings(); // [v5.2.0] 屏幕时间管理初始化
            initAccentTheme(); // [v6.0.0] 初始化主题色
            initBackground(); // [v6.0.0] 初始化背景
            startGlobalTimer(); 
            // [v4.8.1] Immediately check reminders on init (for Android boot/startup auto-launch)
            try { checkReminders(); } catch (e) { console.error('checkReminders failed on init', e); }
            // [v4.9.0] Immediately check abstinence habits on init
            try { checkAbstinenceHabits(); } catch (e) { console.error('checkAbstinenceHabits failed on init', e); }
            if ('Notification' in window && notificationSettings.achievement && Notification.permission === 'default') { 
                requestNotificationPermission(); 
            } 
            setupReportEventListeners(); 
            setupTaskModalEventListeners();
            applyCardLayout(); // [v4.6.0] 应用卡片布局
            initCardStack(); // [v5.10.0] 初始化卡片堆叠
            
            // [v6.6.0] 更新云端状态 UI
            updateCloudStatusUI();
        }
        
        // [v6.6.0] 更新云端状态 UI
        async function updateCloudStatusUI() {
            const statusContainer = document.getElementById('multiTableStatusContainer');
            
            if (!statusContainer) return;
            
            const loginState = auth.hasLoginState();
            if (!loginState || !loginState.user) {
                statusContainer.style.display = 'none';
                return;
            }
            
            try {
                // 检查是否有数据
                const hasData = await DAL.checkProfileExists();
                if (hasData) {
                    statusContainer.style.display = 'block';
                } else {
                    statusContainer.style.display = 'none';
                }
            } catch (e) {
                statusContainer.style.display = 'none';
            }
        }
        
        function startGlobalTimer() { if (timerInterval) clearInterval(timerInterval); timerInterval = setInterval(() => { updateRunningTimers(); checkReminders(); }, 1000); }

        // [v4.8.5] 实时刷新所有习惯的状态（检查是否断签）
        function refreshHabitStatuses() {
            const now = new Date();
            tasks.forEach(task => {
                if (task.isHabit) {
                    checkHabitStreak(task, now);
                }
            });
        }
        
        function updateAllUI() { 
            // [v4.3.2] FIX 1: Removed "if (isSyncing) return;" to allow UI to refresh even during sync.
            // isSyncing flag is now only checked in saveData() to prevent save loops.
            refreshHabitStatuses();
            updateRecentTasks(); 
            updateCategoryTasks(); 
            updateBalance(); 
            updateWidgets(); // [v5.10.0] 同步更新桌面小组件
            if(document.getElementById('reportTab').classList.contains('active')) { 
                updateAllReports(); 
            } 
            updateDemoCTAVisibility();
            resetDailyLowBalanceFlagIfNeeded();
            updateHighlightHabitsButtonVisibility();
        }

        function updateHighlightHabitsButtonVisibility() {
            const btn = document.getElementById('highlightHabitsButton');
            if (!btn) return;
            btn.classList.toggle('hidden', !hasIncompleteDailyHabits());
        }

        function hasIncompleteDailyHabits() {
            const todayStr = getLocalDateString(new Date());
            return tasks.some(task => {
                if (!task.isHabit || !task.habitDetails || task.habitDetails.period !== 'daily') return false;
                // 仅统计“获得”类习惯
                if (!['reward', 'continuous', 'continuous_target'].includes(task.type)) return false;
                const { currentCount, targetCount } = getHabitPeriodInfo(task, transactions, new Date());
                if (currentCount >= targetCount) return false;
                const dailyLimit = task.habitDetails.dailyLimit || 1;
                const completionsToday = transactions.filter(t => t.taskId === task.id && getLocalDateString(t.timestamp) === todayStr).length;
                return completionsToday < dailyLimit;
            });
        }

        // --- Swipe Navigation ---
        function setupSwipeNavigation() {
            // [v5.0.0] 使用新的滚动容器
            const container = document.getElementById('appScrollContainer') || document.querySelector('.main-container');
            if (!container) return;
            let startX = 0, startY = 0, isTracking = false;

            const shouldIgnore = (target) => {
                // 如果任务卡片拖动激活中，忽略滑动
                if (typeof isTaskDragging !== 'undefined' && isTaskDragging) return true;
                // 如果日历长按激活中，忽略滑动
                if (typeof heatmapTooltipLongPressActive !== 'undefined' && heatmapTooltipLongPressActive) return true;
                // [v5.1.1] 如果时间流图长按激活中，忽略滑动
                if (typeof flowTooltipLongPressActive !== 'undefined' && flowTooltipLongPressActive) return true;
                // 移除 .heatmap-grid 的无条件屏蔽，允许在日历上左右滑动切换页签
                return !!(target.closest('.modal') || target.closest('input, textarea, select') || target.closest('.task-card-menu'));
            };

            container.addEventListener('touchstart', (e) => {
                if (!e.touches || e.touches.length !== 1) return;
                if (shouldIgnore(e.target)) return;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isTracking = true;
            }, { passive: true });

            container.addEventListener('touchend', (e) => {
                if (!isTracking || !e.changedTouches || e.changedTouches.length !== 1) { isTracking = false; return; }
                // 再次检查拖动状态
                if (typeof isTaskDragging !== 'undefined' && isTaskDragging) { isTracking = false; return; }
                // 再次检查长按状态
                if (typeof heatmapTooltipLongPressActive !== 'undefined' && heatmapTooltipLongPressActive) { isTracking = false; return; }
                // [v5.1.1] 检查时间流图长按状态
                if (typeof flowTooltipLongPressActive !== 'undefined' && (flowTooltipLongPressActive || flowTooltipLongPressCooldown)) { isTracking = false; return; }
                const dx = e.changedTouches[0].clientX - startX;
                const dy = e.changedTouches[0].clientY - startY;
                isTracking = false;

                const absX = Math.abs(dx);
                const absY = Math.abs(dy);
                const HORIZONTAL_FACTOR = 1.5;
                const MIN_SWIPE = 70;
                if (absX < MIN_SWIPE || absX < absY * HORIZONTAL_FACTOR) return; // 垂直滑动或幅度太小

                const active = getActiveTab();
                const target = e.changedTouches[0].target;
                // 仅在报告页的互动区域屏蔽：互动分析图表、趋势图区域、时间流图区域
                if (active === 'report' && target && target.closest && (target.closest('#interactiveAnalysisWrapper') || target.closest('#pieChartContainerWrapper') || target.closest('#trendChartContainerWrapper') || target.closest('#trendChartWrapper'))) {
                    return;
                }
                const currentIndex = TAB_ORDER.indexOf(active);
                if (currentIndex === -1) return;
                const nextIndex = dx < 0 ? currentIndex + 1 : currentIndex - 1;
                if (nextIndex < 0 || nextIndex >= TAB_ORDER.length) return;
                switchTab(TAB_ORDER[nextIndex]);
            }, { passive: true });
        }

        // 余额不足提醒：每日仅触发一次
        function resetDailyLowBalanceFlagIfNeeded() {
            const todayKey = getLocalDateString(new Date());
            if (notificationSettings.lastLowBalanceAlertDate !== todayKey) {
                notificationSettings.lastLowBalanceAlertDate = null;
            }
        }

        function recomputeBalanceAndDailyChanges() {
            currentBalance = 0;
            dailyChanges = {};
            transactions.forEach(tx => {
                const amt = tx.amount || 0;
                if (tx.type === 'earn') {
                    currentBalance += amt;
                    updateDailyChanges('earned', amt, tx.timestamp);
                } else {
                    currentBalance -= amt;
                    updateDailyChanges('spent', amt, tx.timestamp);
                }
            });
        }

        // 显示/隐藏示例数据导入 CTA，仅在完全无数据时出现
        function updateDemoCTAVisibility() {
            const cta = document.getElementById('demoCTA');
            if (!cta) return;
            const hasAnyData = (tasks && tasks.length > 0) || (transactions && transactions.length > 0);
            cta.classList.toggle('hidden', hasAnyData);
        }

        function handleDemoCTAImport() {
            if (typeof initDemoData === 'function') {
                initDemoData();
            }
        }

        // 用户开始创建自有任务时的示例数据清理引导
        async function maybeCleanupDemoDataOnFirstUse() {
            // 仅针对首次提示：若已有提示则跳过
            if (localStorage.getItem('tb_demo_cleanup_done') === 'true') return;

            // 必须存在示例任务或示例交易才提示
            const hasDemoTasks = tasks.some(t => t.id && t.id.startsWith('demo_'));
            const hasDemoTx = transactions.some(tx => tx.taskId && tx.taskId.startsWith('demo_'));
            if (!hasDemoTasks && !hasDemoTx) return;

            // 提示用户清理示例历史，可选是否删除示例任务
            const clearHistory = await showConfirm('检测到示例历史数据。是否清除示例的交易记录和余额以开始使用？（推荐清除）', '清理示例数据');
            if (clearHistory) {
                // 保留用户可能已新增的真实交易，仅移除示例交易
                transactions = transactions.filter(tx => !(tx.taskId && tx.taskId.startsWith('demo_')));
                runningTasks.clear();
                recomputeBalanceAndDailyChanges();
            }

            if (hasDemoTasks) {
                const removeDemoTasks = await showConfirm('是否同时删除示例任务？选择“取消”则保留示例任务作为模板。', '删除示例任务');
                if (removeDemoTasks) {
                    tasks = tasks.filter(t => !(t.id && t.id.startsWith('demo_')));
                }
            }

            localStorage.setItem('tb_demo_cleanup_done', 'true');
            updateAllUI();
            saveData();
        }

        // ============================================
        // [v4.6.0] 报告卡片管理器
        // ============================================
        const DEFAULT_CARD_ORDER = ['activityHeatmap', 'analysisDashboard', 'dataTable', 'trendChart'];
        let cardLayoutConfig = null;

        function getCardLayoutConfig() {
            if (cardLayoutConfig) return cardLayoutConfig;
            try {
                const saved = localStorage.getItem('tb_card_layout');
                if (saved) {
                    cardLayoutConfig = JSON.parse(saved);
                    // 确保所有卡片都在配置中
                    DEFAULT_CARD_ORDER.forEach(id => {
                        if (!cardLayoutConfig.find(c => c.id === id)) {
                            cardLayoutConfig.push({ id, visible: true });
                        }
                    });
                } else {
                    cardLayoutConfig = DEFAULT_CARD_ORDER.map(id => ({ id, visible: true }));
                }
            } catch (e) {
                cardLayoutConfig = DEFAULT_CARD_ORDER.map(id => ({ id, visible: true }));
            }
            return cardLayoutConfig;
        }

        function saveCardLayoutConfig() {
            try {
                localStorage.setItem('tb_card_layout', JSON.stringify(cardLayoutConfig));
            } catch (e) {}
        }

        function applyCardLayout() {
            const config = getCardLayoutConfig();
            const reportTab = document.getElementById('reportTab');
            const cards = reportTab.querySelectorAll('.report-section[data-card-id]');
            const cardMap = {};
            cards.forEach(card => { cardMap[card.dataset.cardId] = card; });

            // 按配置顺序重新排列
            const managerEntry = reportTab.querySelector('.card-manager-entry');
            config.forEach(item => {
                const card = cardMap[item.id];
                if (card) {
                    card.style.display = item.visible ? '' : 'none';
                    reportTab.insertBefore(card, managerEntry);
                }
            });
        }

        function openCardManager() {
            const modal = document.getElementById('cardManagerModal');
            modal.classList.remove('hidden');
            renderCardManagerList();
        }

        function closeCardManager() {
            const modal = document.getElementById('cardManagerModal');
            modal.classList.add('hidden');
            applyCardLayout();
        }

        function renderCardManagerList() {
            const list = document.getElementById('cardManagerList');
            const config = getCardLayoutConfig();
            const reportTab = document.getElementById('reportTab');

            list.innerHTML = config.map((item, index) => {
                const card = reportTab.querySelector(`.report-section[data-card-id="${item.id}"]`);
                const name = card ? card.dataset.cardName : item.id;
                return `
                    <div class="card-manager-item" draggable="true" data-index="${index}" data-card-id="${item.id}">
                        <span class="card-manager-drag-handle">☰</span>
                        <span class="card-manager-name">${name}</span>
                        <label class="card-manager-toggle">
                            <input type="checkbox" ${item.visible ? 'checked' : ''} onchange="toggleCardVisibility('${item.id}', this.checked)">
                            <span class="slider"></span>
                        </label>
                    </div>
                `;
            }).join('');

            // 添加拖拽事件
            const items = list.querySelectorAll('.card-manager-item');
            items.forEach(item => {
                item.addEventListener('dragstart', handleCardDragStart);
                item.addEventListener('dragend', handleCardDragEnd);
                item.addEventListener('dragover', handleCardDragOver);
                item.addEventListener('drop', handleCardDrop);
                item.addEventListener('dragleave', handleCardDragLeave);
                // 触摸支持
                item.addEventListener('touchstart', handleCardTouchStart, { passive: false });
            });
            // 全局触摸事件绑定到list上
            list.addEventListener('touchmove', handleCardTouchMove, { passive: false });
            list.addEventListener('touchend', handleCardTouchEnd);
            list.addEventListener('touchcancel', handleCardTouchEnd);
        }

        let cardDragSrcIndex = null;
        let cardTouchDragItem = null;
        let cardTouchStartY = 0;
        let cardTouchStartX = 0;
        let cardTouchLongPressTimer = null;
        let cardTouchIsActive = false;
        let cardTouchHoverIndex = null; // 当前悬停的目标位置
        let cardTouchItemStartTop = 0; // 元素初始位置
        let cardTouchOffsetY = 0; // 当前偏移量

        function handleCardDragStart(e) {
            cardDragSrcIndex = parseInt(e.target.closest('.card-manager-item').dataset.index);
            e.target.closest('.card-manager-item').classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleCardDragEnd(e) {
            e.target.closest('.card-manager-item').classList.remove('dragging');
            document.querySelectorAll('.card-manager-item').forEach(item => item.classList.remove('drag-over'));
        }

        function handleCardDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const item = e.target.closest('.card-manager-item');
            if (item && parseInt(item.dataset.index) !== cardDragSrcIndex) {
                item.classList.add('drag-over');
            }
        }

        function handleCardDragLeave(e) {
            e.target.closest('.card-manager-item')?.classList.remove('drag-over');
        }

        function handleCardDrop(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.card-manager-item');
            if (!targetItem) return;
            const targetIndex = parseInt(targetItem.dataset.index);
            if (targetIndex === cardDragSrcIndex) return;

            const config = getCardLayoutConfig();
            const [moved] = config.splice(cardDragSrcIndex, 1);
            config.splice(targetIndex, 0, moved);
            cardLayoutConfig = config;
            saveCardLayoutConfig();
            renderCardManagerList();
        }

        function handleCardTouchStart(e) {
            const item = e.target.closest('.card-manager-item');
            if (!item) return;
            
            // 阻止系统长按菜单
            e.preventDefault();
            
            const touch = e.touches[0];
            cardTouchStartY = touch.clientY;
            cardTouchStartX = touch.clientX;
            cardTouchDragItem = item;
            cardDragSrcIndex = parseInt(item.dataset.index);
            cardTouchIsActive = false;
            cardTouchHoverIndex = null;
            cardTouchOffsetY = 0;
            cardTouchItemStartTop = item.getBoundingClientRect().top;
            
            // 长按200ms后激活拖拽
            cardTouchLongPressTimer = setTimeout(() => {
                cardTouchIsActive = true;
                cardTouchHoverIndex = cardDragSrcIndex;
                // 记录激活时的位置
                cardTouchStartY = touch.clientY;
                item.classList.add('dragging');
                // 触觉反馈
                if (navigator.vibrate) navigator.vibrate(15);
            }, 200);
        }

        function handleCardTouchMove(e) {
            if (!cardTouchDragItem) return;
            
            const touch = e.touches[0];
            const deltaY = touch.clientY - cardTouchStartY;
            const deltaX = Math.abs(touch.clientX - cardTouchStartX);
            
            // 如果还没激活拖拽，且移动超过阈值，取消长按
            if (!cardTouchIsActive && (Math.abs(deltaY) > 8 || deltaX > 8)) {
                clearTimeout(cardTouchLongPressTimer);
                cardTouchDragItem = null;
                return;
            }
            
            if (!cardTouchIsActive) return;
            e.preventDefault();
            
            // 跟手移动
            cardTouchOffsetY = deltaY;
            cardTouchDragItem.style.transform = `translateY(${cardTouchOffsetY}px) scale(1.02)`;
            
            const list = document.getElementById('cardManagerList');
            const items = Array.from(list.querySelectorAll('.card-manager-item'));
            const touchY = touch.clientY;
            
            // 找出当前手指悬停的位置索引
            let hoverIdx = cardDragSrcIndex;
            for (let i = 0; i < items.length; i++) {
                if (i === cardDragSrcIndex) continue;
                const rect = items[i].getBoundingClientRect();
                const center = rect.top + rect.height / 2;
                if (touchY < center && i < cardDragSrcIndex) {
                    hoverIdx = i;
                    break;
                } else if (touchY > center && i > cardDragSrcIndex) {
                    hoverIdx = i;
                }
            }
            
            // 如果悬停位置变化，更新挤压动效
            if (hoverIdx !== cardTouchHoverIndex) {
                cardTouchHoverIndex = hoverIdx;
                updateCardShiftEffect(items, cardDragSrcIndex, hoverIdx);
            }
        }

        function updateCardShiftEffect(items, srcIdx, hoverIdx) {
            items.forEach((item, i) => {
                item.classList.remove('shift-up', 'shift-down');
                if (i === srcIdx) return; // 源元素不需要shift
                
                if (hoverIdx < srcIdx) {
                    // 向上拖 - 中间的元素向下移
                    if (i >= hoverIdx && i < srcIdx) {
                        item.classList.add('shift-down');
                    }
                } else if (hoverIdx > srcIdx) {
                    // 向下拖 - 中间的元素向上移
                    if (i > srcIdx && i <= hoverIdx) {
                        item.classList.add('shift-up');
                    }
                }
            });
        }

        function handleCardTouchEnd(e) {
            clearTimeout(cardTouchLongPressTimer);
            
            if (!cardTouchDragItem) return;
            
            const list = document.getElementById('cardManagerList');
            const items = Array.from(list.querySelectorAll('.card-manager-item'));
            const dragItem = cardTouchDragItem;
            const srcIdx = cardDragSrcIndex;
            const hoverIdx = cardTouchHoverIndex;
            const wasActive = cardTouchIsActive;
            const currentOffset = cardTouchOffsetY; // 当前跟手偏移量
            
            // 如果激活了拖拽且位置变化，先动画移动到目标位置
            if (wasActive && hoverIdx !== null && hoverIdx !== srcIdx) {
                // 计算目标位置的偏移量
                const itemHeight = 54; // 卡片高度 + gap
                const targetOffset = (hoverIdx - srcIdx) * itemHeight;
                
                // 先确保当前位置被应用（无动画）
                dragItem.style.transition = 'none';
                dragItem.style.transform = `translateY(${currentOffset}px) scale(1.02)`;
                
                // 强制重排，然后添加过渡动画
                dragItem.offsetHeight; // 触发reflow
                
                requestAnimationFrame(() => {
                    // 移动到目标位置，同时scale保持1.02（保持高亮状态的样式一致）
                    dragItem.style.transition = 'transform 0.3s cubic-bezier(0.34, 1.2, 0.64, 1)';
                    dragItem.style.transform = `translateY(${targetOffset}px) scale(1.02)`;
                    
                    // 位移动画完成后，开始淡出高亮
                    setTimeout(() => {
                        // 先把scale改为1，有一个微妙的收缩效果
                        dragItem.style.transition = 'transform 0.15s ease-out, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease';
                        dragItem.style.transform = `translateY(${targetOffset}px) scale(1)`;
                        dragItem.classList.remove('dragging');
                    }, 280);
                    
                    // 动画全部结束后重新渲染
                    setTimeout(() => {
                        // 先保存新顺序
                        const config = getCardLayoutConfig();
                        const [moved] = config.splice(srcIdx, 1);
                        config.splice(hoverIdx, 0, moved);
                        cardLayoutConfig = config;
                        saveCardLayoutConfig();
                        
                        // 清除所有状态并重新渲染
                        items.forEach(it => {
                            it.classList.remove('shift-up', 'shift-down', 'dragging');
                            it.style.transform = '';
                            it.style.transition = '';
                        });
                        renderCardManagerList();
                    }, 480);
                });
            } else {
                // 没有位置变化，清除shift并恢复
                items.forEach(it => {
                    if (it !== dragItem) {
                        it.classList.remove('shift-up', 'shift-down');
                    }
                });
                
                // 平滑回弹到原位
                dragItem.style.transition = 'transform 0.25s cubic-bezier(0.34, 1.2, 0.64, 1), background 0.2s ease 0.1s, color 0.2s ease 0.1s';
                dragItem.style.transform = 'translateY(0) scale(1)';
                
                // 延迟移除高亮效果
                setTimeout(() => {
                    dragItem.classList.remove('dragging');
                }, 150);
                
                setTimeout(() => {
                    dragItem.style.transform = '';
                    dragItem.style.transition = '';
                }, 250);
            }
            
            cardTouchDragItem = null;
            cardTouchHoverIndex = null;
            cardTouchIsActive = false;
            cardTouchOffsetY = 0;
        }

        function toggleCardVisibility(cardId, visible) {
            const config = getCardLayoutConfig();
            const item = config.find(c => c.id === cardId);
            if (item) {
                item.visible = visible;
                saveCardLayoutConfig();
            }
        }

        function resetCardLayout() {
            cardLayoutConfig = DEFAULT_CARD_ORDER.map(id => ({ id, visible: true }));
            saveCardLayoutConfig();
            renderCardManagerList();
            applyCardLayout();
        }
        
        // ========== [v5.0.0] 任务卡片长按拖动排序（支持全方向自由移动） ==========
        let isTaskDragging = false; // 全局拖动锁，防止同步更新UI
        let taskDragState = {
            item: null,
            grid: null,
            category: null,
            srcIndex: null,      // 被拖动卡片的原始DOM索引
            currentOrder: [],    // 当前视觉顺序，例如 [0,1,2,3] 变成 [0,2,1,3] 表示卡片2和1交换了位置
            startX: 0,
            startY: 0,
            isActive: false,
            longPressTimer: null,
            cardRects: [],       // 缓存各卡片槽位的原始位置
            cols: 2
        };
        
        function bindTaskCardDragEvents() {
            document.querySelectorAll('.category-tasks-grid').forEach(grid => {
                // 移除旧事件防止重复绑定
                grid.removeEventListener('touchmove', handleTaskDragMove);
                grid.removeEventListener('touchend', handleTaskDragEnd);
                grid.removeEventListener('touchcancel', handleTaskDragEnd);
                
                grid.querySelectorAll('.task-card').forEach(card => {
                    card.removeEventListener('touchstart', handleTaskDragStart);
                    card.addEventListener('touchstart', handleTaskDragStart, { passive: false });
                });
                grid.addEventListener('touchmove', handleTaskDragMove, { passive: false });
                grid.addEventListener('touchend', handleTaskDragEnd);
                grid.addEventListener('touchcancel', handleTaskDragEnd);
            });
        }
        
        // 全局 touchmove 监听，在拖动激活时阻止页面滚动
        document.addEventListener('touchmove', function(e) {
            if (isTaskDragging && taskDragState.isActive) {
                e.preventDefault();
            }
        }, { passive: false });
        
        function handleTaskDragStart(e) {
            const card = e.target.closest('.task-card');
            if (!card) return;
            
            // 如果点击的是按钮或菜单，不触发拖动
            if (e.target.closest('button') || e.target.closest('.task-card-menu')) return;
            
            const grid = card.closest('.category-tasks-grid');
            const categoryDiv = card.closest('.category-tasks');
            const category = categoryDiv?.dataset.category;
            if (!grid || !category) return;
            
            const cards = Array.from(grid.querySelectorAll('.task-card'));
            const srcIndex = cards.indexOf(card);
            const touch = e.touches[0];
            
            // 缓存所有卡片的原始位置
            const cardRects = cards.map(c => {
                const r = c.getBoundingClientRect();
                return { left: r.left, top: r.top, width: r.width, height: r.height, centerX: r.left + r.width/2, centerY: r.top + r.height/2 };
            });
            
            taskDragState = {
                item: card,
                grid: grid,
                category: category,
                srcIndex: srcIndex,
                currentOrder: cards.map((_, i) => i), // 初始顺序 [0,1,2,...]
                startX: touch.clientX,
                startY: touch.clientY,
                isActive: false,
                longPressTimer: null,
                cardRects: cardRects,
                cols: 2
            };
            
            // 长按250ms激活拖动
            taskDragState.longPressTimer = setTimeout(() => {
                taskDragState.isActive = true;
                isTaskDragging = true; // 设置全局锁
                taskDragState.startX = touch.clientX;
                taskDragState.startY = touch.clientY;
                card.classList.add('task-dragging');
                if (navigator.vibrate) navigator.vibrate(15);
            }, 250);
        }
        
        function handleTaskDragMove(e) {
            if (!taskDragState.item) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - taskDragState.startX;
            const deltaY = touch.clientY - taskDragState.startY;
            
            // 如果未激活且移动超过阈值，取消长按并允许页面滚动
            if (!taskDragState.isActive) {
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    clearTimeout(taskDragState.longPressTimer);
                    taskDragState.item = null;
                    isTaskDragging = false;
                }
                return; // 未激活时不阻止默认行为，允许滚动
            }
            
            // 已激活，阻止滚动
            e.preventDefault();
            e.stopPropagation();
            
            // 计算相对于起始点的位移
            const moveX = Math.round(deltaX);
            const moveY = Math.round(deltaY);
            
            taskDragState.item.style.transform = `translate3d(${moveX}px, ${moveY}px, 0) scale(1.02)`;
            
            // 检测手指当前在哪个槽位（使用手指位置判断）
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            const cardRects = taskDragState.cardRects;
            
            // 找到手指当前所在的槽位
            let targetSlot = -1;
            for (let i = 0; i < cardRects.length; i++) {
                const rect = cardRects[i];
                if (touchX >= rect.left && touchX <= rect.left + rect.width &&
                    touchY >= rect.top && touchY <= rect.top + rect.height) {
                    targetSlot = i;
                    break;
                }
            }
            
            // 如果手指移到了新槽位，更新顺序
            if (targetSlot !== -1) {
                const srcIdx = taskDragState.srcIndex;
                const currentOrder = taskDragState.currentOrder;
                
                // 找到被拖动卡片当前在顺序中的位置
                const draggedPosInOrder = currentOrder.indexOf(srcIdx);
                
                // 如果目标槽位不是当前位置，重新排列
                if (draggedPosInOrder !== targetSlot) {
                    // 从当前位置移除
                    currentOrder.splice(draggedPosInOrder, 1);
                    // 插入到目标位置
                    currentOrder.splice(targetSlot, 0, srcIdx);
                    
                    // 更新所有卡片的视觉位置
                    updateCardPositions();
                }
            }
        }
        
        function updateCardPositions() {
            const cards = Array.from(taskDragState.grid.querySelectorAll('.task-card'));
            const cardRects = taskDragState.cardRects;
            const currentOrder = taskDragState.currentOrder;
            const srcIdx = taskDragState.srcIndex;
            
            cards.forEach((card, domIdx) => {
                if (domIdx === srcIdx) return; // 被拖动的卡片跟随手指，不处理
                
                // 找到这张卡片在当前顺序中的位置（即它应该显示在哪个槽位）
                const slotIndex = currentOrder.indexOf(domIdx);
                
                let targetTransform = '';
                if (slotIndex !== domIdx) {
                    // 需要移动到新槽位
                    const fromRect = cardRects[domIdx];
                    const toRect = cardRects[slotIndex];
                    const shiftX = Math.round(toRect.left - fromRect.left);
                    const shiftY = Math.round(toRect.top - fromRect.top);
                    targetTransform = `translate3d(${shiftX}px, ${shiftY}px, 0)`;
                }
                
                // 只有 transform 变化才更新 DOM
                if (card.style.transform !== targetTransform) {
                    card.classList.add('task-shifting');
                    card.style.transform = targetTransform;
                }
            });
        }
        
        function handleTaskDragEnd(e) {
            clearTimeout(taskDragState.longPressTimer);
            
            if (!taskDragState.item) return;
            
            const { item, grid, category, srcIndex, currentOrder, isActive, cardRects } = taskDragState;
            const cards = Array.from(grid.querySelectorAll('.task-card'));
            
            // 找到被拖动卡片最终所在的槽位
            const finalSlot = currentOrder.indexOf(srcIndex);
            const hasChanged = isActive && finalSlot !== srcIndex;
            
            if (hasChanged) {
                // 计算目标位置的偏移
                const fromRect = cardRects[srcIndex];
                const toRect = cardRects[finalSlot];
                const targetDeltaX = Math.round(toRect.left - fromRect.left);
                const targetDeltaY = Math.round(toRect.top - fromRect.top);
                
                // 动画移动到目标位置
                item.style.transition = 'transform 0.25s cubic-bezier(0.34, 1.2, 0.64, 1)';
                item.style.transform = `translate3d(${targetDeltaX}px, ${targetDeltaY}px, 0) scale(1)`;
                
                // 动画结束后更新数据并重渲染
                setTimeout(() => {
                    // 找到该分类的任务并按当前 sortIndex 排序
                    const categoryTasks = tasks.filter(t => t.category === category);
                    categoryTasks.sort((a, b) => {
                        const aIdx = a.sortIndex ?? 9999;
                        const bIdx = b.sortIndex ?? 9999;
                        if (aIdx !== bIdx) return aIdx - bIdx;
                        return (b.isHabit ? 1 : 0) - (a.isHabit ? 1 : 0);
                    });
                    
                    // 按照 currentOrder 重新排列任务
                    const reorderedTasks = currentOrder.map(idx => categoryTasks[idx]);
                    
                    // 更新所有任务的 sortIndex
                    reorderedTasks.forEach((t, idx) => {
                        if (t) t.sortIndex = idx;
                    });
                    
                    saveData();
                    
                    // 清除所有状态并重渲染
                    cards.forEach(c => {
                        c.classList.remove('task-dragging', 'task-shifting');
                        c.style.transform = '';
                    });
                    isTaskDragging = false;
                    updateCategoryTasks();
                }, 280);
            } else {
                // 没有位置变化，回弹
                cards.forEach(c => {
                    c.classList.remove('task-shifting');
                    c.style.transform = '';
                });
                
                if (isActive) {
                    item.style.transition = 'transform 0.2s ease-out';
                    item.style.transform = 'translate3d(0, 0, 0) scale(1)';
                    setTimeout(() => {
                        item.classList.remove('task-dragging');
                        item.style.transform = '';
                        item.style.transition = '';
                        isTaskDragging = false;
                    }, 200);
                } else {
                    item.classList.remove('task-dragging');
                    isTaskDragging = false;
                }
            }
            
            // 重置状态
            taskDragState = {
                item: null, grid: null, category: null, srcIndex: null, currentOrder: [],
                startX: 0, startY: 0, isActive: false, longPressTimer: null, cardRects: [], cols: 2
            };
        }
        
        const TAB_ORDER = ['earn', 'spend', 'report', 'settings'];
        function switchTab(tabName, evt = null) {
            const tabId = `${tabName}Tab`;
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
            const targetContent = document.getElementById(tabId);
            if (targetContent) targetContent.classList.add('active');

            const sourceBtn = evt ? (evt.currentTarget || evt.target.closest('.tab-button')) : document.querySelector(`.tab-button[data-tab="${tabName}"]`);
            if (sourceBtn) sourceBtn.classList.add('active');

            const fab = document.getElementById('fabButton');
            if (fab) fab.style.display = (tabName === 'report' || tabName === 'settings') ? 'none' : 'block';
            if (tabName === 'report') { reportState.heatmapDate = new Date(); updateAllReports(); }
        }

        function getActiveTab() {
            const activeContent = document.querySelector('.tab-content.active');
            if (activeContent && activeContent.id.endsWith('Tab')) {
                return activeContent.id.replace('Tab', '');
            }
            return TAB_ORDER[0];
        }
        
        // --- Task Rendering ---
        // [v4.4.0] "最近任务" 保持 6 个, 不再修改
        function updateRecentTasks() { 
            if (isTaskDragging) return; // 拖动中不更新
            const earnTasks = tasks.filter(t => ['reward', 'continuous', 'continuous_target'].includes(t.type)); const spendTasks = tasks.filter(t => ['instant_redeem', 'continuous_redeem'].includes(t.type)); const sortByLastUsed = (taskList) => [...taskList].sort((a, b) => (b.lastUsed || 0) - (a.lastUsed || 0)).slice(0, 6); renderTaskList('recentEarnTasks', sortByLastUsed(earnTasks)); renderTaskList('recentSpendTasks', sortByLastUsed(spendTasks)); 
        }
        function updateCategoryTasks() { 
            if (isTaskDragging) return; // 拖动中不更新
            const earnTasks = tasks.filter(t => ['reward', 'continuous', 'continuous_target'].includes(t.type)); 
            const spendTasks = tasks.filter(t => ['instant_redeem', 'continuous_redeem'].includes(t.type)); 
            renderCategoryTasks('categoryEarnTasks', groupTasksByCategory(earnTasks)); 
            renderCategoryTasks('categorySpendTasks', groupTasksByCategory(spendTasks));
            // 绑定任务卡片拖动事件
            setTimeout(bindTaskCardDragEvents, 0);
        }
        function groupTasksByCategory(taskList) { return taskList.reduce((acc, task) => { (acc[task.category] = acc[task.category] || []).push(task); return acc; }, {}); }
        // [v5.0.0] 分类内任务最大显示数量
        const CATEGORY_TASK_LIMIT = 6;
        
        function renderCategoryTasks(containerId, tasksByCategory) { 
            const container = document.getElementById(containerId); 
            if (Object.keys(tasksByCategory).length === 0) { 
                container.innerHTML = `<div class="empty-message" style="color:var(--text-color-light)">暂无任务</div>`; 
                return; 
            } 
            container.innerHTML = Object.entries(tasksByCategory).map(([category, categoryTasks]) => { 
                const isCollapsed = collapsedCategories.has(category); 
                const color = categoryColors.get(category) || '#666'; 
                // [v4.12.0] 按 sortIndex 排序，如无则按习惯优先
                categoryTasks.sort((a, b) => {
                    const aIdx = a.sortIndex ?? 9999;
                    const bIdx = b.sortIndex ?? 9999;
                    if (aIdx !== bIdx) return aIdx - bIdx;
                    return (b.isHabit ? 1 : 0) - (a.isHabit ? 1 : 0);
                });
                
                // [v5.0.0] 分类内任务折叠逻辑：超过6个任务时折叠
                const isTaskExpanded = expandedTaskCategories.has(category);
                const totalCount = categoryTasks.length;
                const shouldFold = totalCount > CATEGORY_TASK_LIMIT && !isTaskExpanded;
                const visibleTasks = shouldFold ? categoryTasks.slice(0, CATEGORY_TASK_LIMIT) : categoryTasks;
                const hiddenCount = totalCount - CATEGORY_TASK_LIMIT;
                
                // [v5.0.0] 展开/收起按钮
                let expandBtn = '';
                if (totalCount > CATEGORY_TASK_LIMIT) {
                    if (shouldFold) {
                        expandBtn = `<div style="grid-column: 1 / -1; text-align: center; padding: 2px 0;"><button class="category-expand-btn" onclick="toggleCategoryTaskExpand('${escapeHtml(category)}', event)"><span class="expand-icon">▼</span>展开 ${hiddenCount} 个</button></div>`;
                    } else {
                        expandBtn = `<div style="grid-column: 1 / -1; text-align: center; padding: 2px 0;"><button class="category-expand-btn expanded" onclick="toggleCategoryTaskExpand('${escapeHtml(category)}', event)"><span class="expand-icon">▼</span>收起</button></div>`;
                    }
                }
                
                return `<div class="category-tasks" data-category="${escapeHtml(category)}"><div class="category-header ${isCollapsed ? 'collapsed' : ''}" onclick="toggleCategory('${category}')"><div class="category-info"><div class="category-color" style="background-color: ${color}"></div><div class="category-name">${category}</div><div class="category-count">(${categoryTasks.length})</div></div><div class="category-toggle">▼</div></div><div class="category-tasks-list ${isCollapsed ? 'collapsed' : ''}"><div class="category-tasks-grid">${renderTaskCards(visibleTasks)}${expandBtn}</div></div></div>`; 
            }).join(''); 
        }
        function renderTaskList(containerId, taskList) { const container = document.getElementById(containerId); if (taskList.length === 0) { container.innerHTML = `<div class="empty-message" style="color:var(--text-color-light)">暂无最近任务</div>`; return; } container.innerHTML = renderTaskCards(taskList); }
        
// --- SCRIPT BLOCK 1/3 END --- </script>
<script> // --- SCRIPT BLOCK 2/3 START ---
        // [v4.5.4] Updated renderTaskCards (修复达标文本, 修复计时器UI, 增加高亮 class)

        const clampChannel = (v) => Math.min(255, Math.max(0, v));
        const clamp01 = (v) => Math.min(1, Math.max(0, v));
        const hexToRgb = (hex) => {
            if (!hex) return null;
            let h = hex.trim();
            if (h.startsWith('#')) h = h.slice(1);
            if (h.length === 3) h = h.split('').map(c => c + c).join('');
            if (h.length !== 6) return null;
            const r = parseInt(h.slice(0, 2), 16);
            const g = parseInt(h.slice(2, 4), 16);
            const b = parseInt(h.slice(4, 6), 16);
            if ([r, g, b].some(n => Number.isNaN(n))) return null;
            return { r, g, b };
        };
        const channelToHex = (v) => clampChannel(Math.round(v)).toString(16).padStart(2, '0');
        const adjustColor = (hex, percent) => {
            const rgb = hexToRgb(hex);
            if (!rgb) return hex;
            const factor = percent / 100;
            const r = factor >= 0 ? rgb.r + (255 - rgb.r) * factor : rgb.r * (1 + factor);
            const g = factor >= 0 ? rgb.g + (255 - rgb.g) * factor : rgb.g * (1 + factor);
            const b = factor >= 0 ? rgb.b + (255 - rgb.b) * factor : rgb.b * (1 + factor);
            return `#${channelToHex(r)}${channelToHex(g)}${channelToHex(b)}`;
        };
        const hexToHsl = (hex) => {
            const rgb = hexToRgb(hex);
            if (!rgb) return null;
            const r = rgb.r / 255; const g = rgb.g / 255; const b = rgb.b / 255;
            const max = Math.max(r, g, b); const min = Math.min(r, g, b);
            let h; let s; const l = (max + min) / 2;
            if (max === min) { h = 0; s = 0; }
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    default: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, l };
        };
        const hslToHex = (h, s, l) => {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            let r; let g; let b;
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return `#${channelToHex(r * 255)}${channelToHex(g * 255)}${channelToHex(b * 255)}`;
        };
        // [v5.1.0] 徽章/标签渐变色生成（徽章左浅右深）
        const getBadgeGradient = (baseColor) => {
            const color = baseColor || '#7c4dff';
            const hsl = hexToHsl(color);
            if (!hsl) return 'var(--accent-gradient)';
            const s = clamp01(Math.max(0.45, Math.min(0.9, hsl.s + 0.05)));
            let startL; let endL;
            if (hsl.l >= 0.7) {
                // 亮色（如黄）：徽章左浅右深
                startL = clamp01(hsl.l - 0.02);
                endL = clamp01(hsl.l - 0.14);
            } else {
                // 深色：徽章左浅右深
                startL = clamp01(hsl.l + 0.14);
                endL = clamp01(hsl.l - 0.02);
            }
            const left = hslToHex(hsl.h, s, startL);
            const right = hslToHex(hsl.h, s, endL);
            return `linear-gradient(135deg, ${left}, ${right})`;
        };

        // [v5.1.0] 分类标签渐变（左深右浅）
        const getCategoryGradient = (baseColor) => {
            const color = baseColor || '#7c4dff';
            const hsl = hexToHsl(color);
            if (!hsl) return 'var(--accent-gradient)';
            const s = clamp01(Math.max(0.45, Math.min(0.9, hsl.s + 0.05)));
            let startL; let endL;
            if (hsl.l >= 0.7) {
                // 亮色：左深右浅
                startL = clamp01(hsl.l - 0.16);
                endL = clamp01(hsl.l - 0.04);
            } else {
                // 深色：左深右浅
                startL = clamp01(hsl.l - 0.06);
                endL = clamp01(hsl.l + 0.10);
            }
            const left = hslToHex(hsl.h, s, startL);
            const right = hslToHex(hsl.h, s, endL);
            return `linear-gradient(135deg, ${left}, ${right})`;
        };

        // [v5.1.x] 基于分类色生成任务切片梯度色组
        const generateCategoryTaskColors = (baseColor, count) => {
            const fallback = ['#7c4dff', '#6a48d7', '#8c6ae3', '#a88eeb', '#c8b8f4'];
            const hsl = hexToHsl(baseColor || '#7c4dff');
            if (!hsl) return fallback.slice(0, count);
            const s = clamp01(Math.max(0.35, Math.min(0.9, hsl.s + 0.02)));
            const colors = [];
            const baseL = clamp01(hsl.l); // 以第二名为基准色
            const darkL = clamp01(baseL - 0.07); // 第一名略深
            const lightStep = 0.08;

            if (count === 1) {
                colors.push(hslToHex(hsl.h, s, baseL));
                return colors;
            }

            // 第一名：最深；第二名：基准色；第3-4名逐步变浅；第5名及以后不再变浅
            colors.push(hslToHex(hsl.h, s, darkL));
            colors.push(hslToHex(hsl.h, s, baseL));
            const maxLightIdx = 4; // 第5名(idx=4)及以后固定亮度
            for (let i = 2; i < count; i++) {
                const stepIdx = Math.min(i - 1, maxLightIdx - 1);
                const l = clamp01(baseL + lightStep * stepIdx);
                colors.push(hslToHex(hsl.h, s, l));
            }
            return colors;
        };

        // [v6.0.0] 为任务视图生成基于分类的颜色映射
        // 按任务所属分类分组，同分类下多任务使用递减色阶
        function buildTaskViewColorMap(taskItems) {
            const colorMap = new Map();
            // 1. 按分类分组任务
            const categoryGroups = new Map();
            taskItems.forEach(item => {
                if (item.name === '其他') return;
                // 查找任务获取分类
                const task = tasks.find(t => t.name === item.name);
                const category = task?.category || '未分类';
                if (!categoryGroups.has(category)) {
                    categoryGroups.set(category, []);
                }
                categoryGroups.get(category).push(item.name);
            });
            // 2. 为每个分类组生成颜色
            categoryGroups.forEach((taskNames, category) => {
                const baseColor = getCategoryColorSafe(category);
                const colors = generateCategoryTaskColors(baseColor, taskNames.length);
                taskNames.forEach((name, idx) => {
                    colorMap.set(name, colors[idx]);
                });
            });
            // 注意："其他"颜色由调用方根据 earn/spend 类型决定
            return colorMap;
        }

        // [v5.1.0] 饼图长按弹窗（防误触：移动阈值+触控专用）
        // ====== ⭐ CRITICAL: 防误触机制 - 修改前请仔细检查 ======
        // 1. PIE_SWIPE_THRESHOLD: 滑动阈值，超过则取消长按
        // 2. pieTooltipTouchMoveBlocker: 长按激活后阻断页面滚动
        // 3. setPointerCapture: 接管指针事件防止滚动
        // 4. evt.preventDefault/stopPropagation: 长按状态下阻止默认行为
        // ========================================================
        let pieTooltipLongPressTimer = null;
        let pieTooltipPointerId = null;
        let pieTooltipLongPressActive = false;
        let pieTooltipLongPressCooldown = false;
        let pieTooltipStartX = 0;
        let pieTooltipStartY = 0;
        let pieTooltipMoveHandler = null;
        let pieTooltipEndHandler = null;
        let pieTooltipGlobalListenersBound = false;
        let pieTooltipRAFId = null;
        let pieDetailLongPressTimer = null;
        let pieDetailProgressPlanned = false;
        let pieTooltipCurrentSliceName = null; // 跟踪当前显示的slice名称
        let pieTooltipCurrentMeta = null; // 跟踪当前显示slice对应的meta
        let pieTooltipTouchMoveBlocker = null; // 长按激活后阻断touchmove滚动
        let pieActiveSliceName = null; // 当前高亮的扇形名称
        const PIE_SWIPE_THRESHOLD = 20; // 滑动取消阈值（像素），适当放宽以支持饼图上的弧形滑动

        function startPieDetailProgress() {
            const tooltipEl = document.getElementById('pieTooltip');
            if (!tooltipEl) return;
            const bar = tooltipEl.querySelector('.pie-tooltip-progress');
            if (!bar) return;
            bar.classList.remove('animating');
            void bar.offsetWidth; // 强制重绘
            bar.classList.add('animating');
        }

        function stopPieDetailProgress() {
            const tooltipEl = document.getElementById('pieTooltip');
            if (!tooltipEl) return;
            const bar = tooltipEl.querySelector('.pie-tooltip-progress');
            if (bar) {
                bar.classList.remove('animating');
            }
        }

        function hidePieTooltip() {
            const tooltipEl = document.getElementById('pieTooltip');
            if (!tooltipEl) return;
            tooltipEl.classList.remove('show', 'moving');
            tooltipEl.style.transition = '';
            stopPieDetailProgress();
            if (pieTooltipRAFId) cancelAnimationFrame(pieTooltipRAFId);
            pieTooltipRAFId = null;
            pieTooltipCurrentSliceName = null;
            pieTooltipCurrentMeta = null;
            clearPieActiveHighlight();
            // 清理长按状态，防止进入详情后再次触发
            clearTimeout(pieTooltipLongPressTimer);
            clearTimeout(pieDetailLongPressTimer);
            pieTooltipLongPressActive = false;
            pieTooltipLongPressCooldown = true;
            pieDetailProgressPlanned = false;
            pieTooltipPointerId = null;
            // 移除touchmove阻断器
            if (pieTooltipTouchMoveBlocker) {
                window.removeEventListener('touchmove', pieTooltipTouchMoveBlocker, { passive: false, capture: true });
                pieTooltipTouchMoveBlocker = null;
            }
            // 移除pointer事件监听
            if (pieTooltipMoveHandler) {
                window.removeEventListener('pointermove', pieTooltipMoveHandler, { passive: false, capture: true });
                pieTooltipMoveHandler = null;
            }
            if (pieTooltipEndHandler) {
                window.removeEventListener('pointerup', pieTooltipEndHandler, true);
                window.removeEventListener('pointercancel', pieTooltipEndHandler, true);
                pieTooltipEndHandler = null;
            }
        }

        function bindPieTooltipGlobalListeners() {
            if (pieTooltipGlobalListenersBound) return;
            window.addEventListener('scroll', hidePieTooltip, true);
            window.addEventListener('resize', hidePieTooltip);
            pieTooltipGlobalListenersBound = true;
        }

        // ===== 饼图扇形外扩动画（CSS d 属性过渡） =====
        // 预先计算 base 和 expanded 两套路径，长按时切换 d 属性

        function setPieActiveHighlight(container, meta, slice) {
            if (!container || !slice) return;
            // 清除所有其他高亮（还原到 base）
            document.querySelectorAll('.pie-highlight-slice.active').forEach(el => {
                el.classList.remove('active');
                const baseD = el.getAttribute('data-d-base');
                if (baseD) el.setAttribute('d', baseD);
            });
            // 找到对应的扇形并激活
            const highlightPath = container.querySelector(`.pie-highlight-slice[data-slice-name="${CSS.escape(slice.name)}"]`);
            if (highlightPath) {
                highlightPath.classList.add('active');
                const expandedD = highlightPath.getAttribute('data-d-expanded');
                if (expandedD) highlightPath.setAttribute('d', expandedD);
            }
            pieActiveSliceName = slice.name;
        }

        function clearPieActiveHighlight() {
            document.querySelectorAll('.pie-highlight-slice.active').forEach(el => {
                el.classList.remove('active');
                const baseD = el.getAttribute('data-d-base');
                if (baseD) el.setAttribute('d', baseD);
            });
            pieActiveSliceName = null;
        }

        function getPieSliceAtPoint(container, meta, clientX, clientY) {
            if (!container || !meta || !meta.slices || meta.slices.length === 0) return null;
            const rect = container.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const dx = clientX - cx;
            const dy = clientY - cy;
            const radius = Math.sqrt(dx * dx + dy * dy);
            const maxR = rect.width / 2;
            // 忽略中心空白与外圈外（增加内圈容差避免快速移动时丢失）
            if (radius > maxR * 1.05 || radius < maxR * 0.20) return null;
            let angle = Math.atan2(dy, dx); // [-pi, pi]
            angle = angle < -Math.PI / 2 ? angle + 2 * Math.PI : angle; // 从 12 点方向开始
            const deg = ((angle + Math.PI / 2) * 180) / Math.PI; // 0deg 在顶部，顺时针
            let percent = (deg / 360) * 100;
            // 规范化百分比到 [0, 100) 范围
            if (percent < 0) percent += 100;
            if (percent >= 100) percent -= 100;
            
            // 优先精确匹配
            let matchedSlice = meta.slices.find(slice => percent >= slice.start && percent < slice.end);
            if (matchedSlice) return matchedSlice;
            
            // 12点边界特殊处理：处理跨越0点的扇形
            const firstSlice = meta.slices[0];
            const lastSlice = meta.slices[meta.slices.length - 1];
            // 如果第一个扇形从0开始，percent接近100时应该匹配最后一个扇形
            if (firstSlice && firstSlice.start === 0 && percent > 99) {
                if (lastSlice && percent < lastSlice.end + 1) return lastSlice;
            }
            // 如果percent接近0，应该匹配第一个扇形
            if (percent < 1 && firstSlice && firstSlice.start === 0) {
                return firstSlice;
            }
            
            // 容差匹配（处理边界间隙）
            const tolerance = 1.0; // 1% 容差（约3.6度）
            matchedSlice = meta.slices.find(slice => {
                // 检查是否在扇形范围的容差内
                if (percent >= slice.start - tolerance && percent < slice.end + tolerance) return true;
                // 处理跨越0点的情况
                if (slice.end >= 99 && percent < tolerance) return true;
                if (slice.start <= 1 && percent > 100 - tolerance) return true;
                return false;
            });
            
            return matchedSlice || null;
        }

        function showPieTooltip(meta, slice, clientX, clientY, isMoving = false) {
            const tooltipEl = document.getElementById('pieTooltip');
            if (!tooltipEl || !slice) return;
            const percentText = `${slice.percent.toFixed(0)}%`;
            let detailHtml = '';
            
            // 辅助函数：截断名称（限制4个字符）
            const truncateName = (name, maxLen = 4) => name.length > maxLen ? name.slice(0, maxLen) + '...' : name;
            const maxDetailRows = 4; // 统一显示数量上限
            
            // 分类视图"其他"：显示被合并的分类列表
            if (meta.view === 'category' && slice.name === '其他' && slice.otherCategories && slice.otherCategories.length > 0) {
                const otherRows = slice.otherCategories.slice(0, maxDetailRows).map(cat => `<div class="trend-tooltip-row" style="padding-left: 8px; opacity: 0.85;"><span style="font-size: 0.75rem;" title="${escapeHtml(cat.name)}">· ${escapeHtml(truncateName(cat.name))}</span><span style="font-size: 0.75rem;">${formatTime(cat.value)}</span></div>`).join('');
                detailHtml = `<div style="border-top: 1px solid rgba(255,255,255,0.15); padding-top: 2px;"><div class="trend-tooltip-row" style="opacity: 0.7; font-size: 0.7rem;"><span>包含分类</span><span></span></div>${otherRows}</div>`;
            }
            // 分类视图：显示任务明细
            else if (meta.view === 'category' && slice.tasks && slice.tasks.length > 0) {
                const taskRows = slice.tasks.slice(0, maxDetailRows).map(task => `<div class="trend-tooltip-row" style="padding-left: 8px; opacity: 0.85;"><span style="font-size: 0.75rem;" title="${escapeHtml(task.name)}">· ${escapeHtml(truncateName(task.name))}</span><span style="font-size: 0.75rem;">${formatTime(task.value)}</span></div>`).join('');
                detailHtml = `<div style="border-top: 1px solid rgba(255,255,255,0.15); padding-top: 2px;"><div class="trend-tooltip-row" style="opacity: 0.7; font-size: 0.7rem;"><span>任务明细</span><span></span></div>${taskRows}</div>`;
            }
            // 任务视图"其他"：显示第6-15名任务
            else if (meta.view === 'task' && slice.name === '其他' && slice.otherTasks && slice.otherTasks.length > 0) {
                const otherRows = slice.otherTasks.slice(0, maxDetailRows).map(task => `<div class="trend-tooltip-row" style="padding-left: 8px; opacity: 0.85;"><span style="font-size: 0.75rem;" title="${escapeHtml(task.name)}">· ${escapeHtml(truncateName(task.name))}</span><span style="font-size: 0.75rem;">${formatTime(task.value)}</span></div>`).join('');
                detailHtml = `<div style="border-top: 1px solid rgba(255,255,255,0.15); padding-top: 2px;"><div class="trend-tooltip-row" style="opacity: 0.7; font-size: 0.7rem;"><span>包含任务</span><span></span></div>${otherRows}</div>`;
            }
            // 任务视图：显示最近记录（包括系统任务如屏幕时间管理）
            else if (meta.view === 'task') {
                let taskTransactions = [];
                if (slice.taskId) {
                    // 普通任务：按taskId查询
                    taskTransactions = (cachedAnalysisFilteredTransactions || [])
                        .filter(t => t.taskId === slice.taskId)
                        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                        .slice(0, maxDetailRows);
                } else if (slice.isSystem || slice.name === '屏幕时间管理') {
                    // 系统任务：按isSystem和taskName查询
                    taskTransactions = (cachedAnalysisFilteredTransactions || [])
                        .filter(t => t.isSystem && (t.taskName === slice.name || t.taskName === '屏幕时间管理'))
                        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                        .slice(0, maxDetailRows);
                }
                if (taskTransactions.length > 0) {
                    const recordRows = taskTransactions.map(t => {
                        const dateStr = new Date(t.timestamp).toLocaleDateString('zh-CN', { month: 'numeric', day: 'numeric' });
                        return `<div class="trend-tooltip-row" style="padding-left: 8px; opacity: 0.85;"><span style="font-size: 0.75rem;">· ${dateStr}</span><span style="font-size: 0.75rem;">${formatTime(Math.abs(t.amount))}</span></div>`;
                    }).join('');
                    detailHtml = `<div style="border-top: 1px solid rgba(255,255,255,0.15); padding-top: 2px;"><div class="trend-tooltip-row" style="opacity: 0.7; font-size: 0.7rem;"><span>最近记录</span><span></span></div>${recordRows}</div>`;
                }
            }
            
            // 提示文字：分类视图、任务视图（含"其他"和系统任务）都支持长按3秒
            const isCategoryOther = meta.view === 'category' && slice.name === '其他' && slice.otherCategories && slice.otherCategories.length > 0;
            const isSystemTask = slice.isSystem || slice.name === '屏幕时间管理';
            const canShowDetail = isCategoryOther || (meta.view === 'category') || (meta.view === 'task' && (slice.taskId || isSystemTask || (slice.name === '其他' && slice.otherTasks && slice.otherTasks.length > 0)));
            const hintText = meta.view === 'category' ? (isCategoryOther ? '其他分类' : '分类') : (slice.name === '其他' ? '更多任务' : '任务');
            const hintHtml = canShowDetail ? `<div class="heatmap-tooltip-hint">长按 3 秒查看${hintText}详情</div>` : '';
            
            const html = `<span class="trend-tooltip-title">${escapeHtml(slice.name)}</span>
                <div class="trend-tooltip-list">
                    <div class="trend-tooltip-row"><span>占比</span><span>${percentText}</span></div>
                    <div class="trend-tooltip-row"><span>${meta.typeLabel}</span><span>${formatTime(slice.value)}</span></div>
                    ${detailHtml}
                </div>
                ${hintHtml}`;
            
            // 移动时如果slice变化则更新内容，否则只更新位置
            const sliceChanged = pieTooltipCurrentSliceName !== slice.name;
            if (!isMoving || sliceChanged) {
                tooltipEl.innerHTML = `<div class="trend-tooltip-content">${html}</div><div class="pie-tooltip-progress"></div>`;
                pieTooltipCurrentSliceName = slice.name;
                // slice变化后恢复进度条动画状态
                if (isMoving && pieDetailProgressPlanned) {
                    const progressBar = tooltipEl.querySelector('.pie-tooltip-progress');
                    if (progressBar) {
                        progressBar.classList.remove('animating');
                        void progressBar.offsetWidth; // 强制重绘
                        progressBar.classList.add('animating');
                    }
                }
            }
            tooltipEl.classList.add('show');
            tooltipEl.classList.toggle('moving', !!isMoving);

            const applyPosition = () => {
                const margin = 8;
                const rect = tooltipEl.getBoundingClientRect();
                let left = clientX - rect.width / 2;
                let top = clientY - rect.height - 12;
                if (left + rect.width + margin > window.innerWidth) left = window.innerWidth - rect.width - margin;
                if (left < margin) left = margin;
                if (top < margin) top = clientY + 12;
                tooltipEl.style.left = `${left}px`;
                tooltipEl.style.top = `${top}px`;
            };

            if (isMoving) {
                if (pieTooltipRAFId) cancelAnimationFrame(pieTooltipRAFId);
                pieTooltipRAFId = requestAnimationFrame(() => {
                    applyPosition();
                    pieTooltipRAFId = null;
                });
            } else {
                applyPosition();
            }

            // 只在首次显示时启动进度条，移动时不重启（分类视图和任务视图都支持）
            if (!isMoving && pieDetailProgressPlanned) {
                startPieDetailProgress();
            }
        }

        function initPieTooltips() {
            const tooltipEl = document.getElementById('pieTooltip');
            if (!tooltipEl) return;
            hidePieTooltip();
            bindPieTooltipGlobalListeners();

            const containers = document.querySelectorAll('.pie-chart-container[data-pie-meta]');
            containers.forEach(container => {
                const metaStr = container.getAttribute('data-pie-meta');
                if (!metaStr) return;
                let meta;
                try { meta = JSON.parse(decodeURIComponent(metaStr)); } catch(e) { return; }

                const pointerDownHandler = (e) => {
                    if (e.pointerType === 'mouse') return; // 仅触控/触笔
                    clearTimeout(pieTooltipLongPressTimer);
                    clearTimeout(pieDetailLongPressTimer);
                    clearPieActiveHighlight();
                    pieTooltipPointerId = e.pointerId;
                    pieTooltipLongPressActive = false;
                    pieTooltipLongPressCooldown = false;
                    // 分类视图和任务视图都支持进度条（任务视图需要有taskId且非"其他"）
                    pieDetailProgressPlanned = true;
                    pieTooltipStartX = e.clientX;
                    pieTooltipStartY = e.clientY;
                    // [v5.1.1] 立即添加touchmove阻断器，防止等待期间触发页面滚动
                    if (pieTooltipTouchMoveBlocker) {
                        window.removeEventListener('touchmove', pieTooltipTouchMoveBlocker, { passive: false, capture: true });
                    }
                    pieTooltipTouchMoveBlocker = (ev) => { ev.preventDefault(); };
                    window.addEventListener('touchmove', pieTooltipTouchMoveBlocker, { passive: false, capture: true });

                    const moveHandler = (evt) => {
                        if (evt.pointerId !== pieTooltipPointerId) return;
                        if (pieTooltipLongPressActive) {
                            evt.preventDefault();
                            evt.stopPropagation();
                            // 尝试在所有饼图容器中查找当前位置对应的扇形
                            let foundSlice = null;
                            let foundMeta = null;
                            let foundContainer = null;
                            const allContainers = document.querySelectorAll('.pie-chart-container[data-pie-meta]');
                            for (const c of allContainers) {
                                const mStr = c.getAttribute('data-pie-meta');
                                if (!mStr) continue;
                                try {
                                    const m = JSON.parse(decodeURIComponent(mStr));
                                    const s = getPieSliceAtPoint(c, m, evt.clientX, evt.clientY);
                                    if (s) { foundSlice = s; foundMeta = m; foundContainer = c; break; }
                                } catch(e) {}
                            }
                            if (foundSlice && foundMeta) {
                                // 如果slice变化（包括从null变为有效slice），重置3秒详情定时器
                                if (foundSlice.name !== pieTooltipCurrentSliceName || pieTooltipCurrentSliceName === null) {
                                    // [v5.8.0] 切换扇形时震动反馈
                                    if (typeof Android !== 'undefined' && Android.vibrate) {
                                        Android.vibrate(10);
                                    } else if (navigator.vibrate) {
                                        navigator.vibrate(10);
                                    }
                                    clearTimeout(pieDetailLongPressTimer);
                                    pieTooltipCurrentMeta = foundMeta;
                                    // 分类视图"其他"：进入其他分类详情
                                    if (foundMeta.view === 'category' && foundSlice.name === '其他' && foundSlice.otherCategories && foundSlice.otherCategories.length > 0) {
                                        pieDetailLongPressTimer = setTimeout(() => {
                                            // [v5.8.0] 进入详情页震动反馈
                                            if (typeof Android !== 'undefined' && Android.vibrate) {
                                                Android.vibrate(20);
                                            } else if (navigator.vibrate) {
                                                navigator.vibrate(20);
                                            }
                                            hidePieTooltip();
                                            showOtherCategoriesDetail(foundSlice.otherCategories, foundMeta.typeKey || 'earn', true);
                                        }, 2750);
                                    }
                                    // 分类视图：进入分类详情
                                    else if (foundMeta.view === 'category') {
                                        pieDetailLongPressTimer = setTimeout(() => {
                                            // [v5.8.0] 进入详情页震动反馈
                                            if (typeof Android !== 'undefined' && Android.vibrate) {
                                                Android.vibrate(20);
                                            } else if (navigator.vibrate) {
                                                navigator.vibrate(20);
                                            }
                                            hidePieTooltip();
                                            showCategoryDetail(foundSlice.name, foundMeta.typeKey || 'earn', true);
                                        }, 2750);
                                    }
                                    // 任务视图：进入任务历史（非"其他"且有taskId）
                                    else if (foundMeta.view === 'task' && foundSlice.taskId && foundSlice.name !== '其他') {
                                        pieDetailLongPressTimer = setTimeout(() => {
                                            // [v5.8.0] 进入详情页震动反馈
                                            if (typeof Android !== 'undefined' && Android.vibrate) {
                                                Android.vibrate(20);
                                            } else if (navigator.vibrate) {
                                                navigator.vibrate(20);
                                            }
                                            hidePieTooltip();
                                            showTaskHistory(foundSlice.taskId);
                                        }, 2750);
                                    }
                                    // 任务视图"其他"：进入其他任务详情
                                    else if (foundMeta.view === 'task' && foundSlice.name === '其他' && foundSlice.otherTasks && foundSlice.otherTasks.length > 0) {
                                        pieDetailLongPressTimer = setTimeout(() => {
                                            // [v5.8.0] 进入详情页震动反馈
                                            if (typeof Android !== 'undefined' && Android.vibrate) {
                                                Android.vibrate(20);
                                            } else if (navigator.vibrate) {
                                                navigator.vibrate(20);
                                            }
                                            hidePieTooltip();
                                            showOtherTasksDetail(foundSlice.otherTasks, foundMeta.typeKey || 'earn', true);
                                        }, 2750);
                                    }
                                }
                                setPieActiveHighlight(foundContainer, foundMeta, foundSlice);
                                showPieTooltip(foundMeta, foundSlice, evt.clientX, evt.clientY, true);
                                setPieActiveHighlight(foundContainer, foundMeta, foundSlice);
                                showPieTooltip(foundMeta, foundSlice, evt.clientX, evt.clientY, true);
                                pieTooltipCurrentSliceName = foundSlice.name;
                            } else {
                                // 进入中心空白或饼图外部区域
                                clearPieActiveHighlight();
                                pieTooltipCurrentSliceName = null; // 重置当前slice名称
                                // [v5.1.1] 即使在中心白色区域也更新tooltip位置（保持之前的内容，逐渐淡出）
                                const tooltipEl = document.getElementById('pieTooltip');
                                if (tooltipEl && tooltipEl.classList.contains('show')) {
                                    tooltipEl.classList.add('moving');
                                    if (pieTooltipRAFId) cancelAnimationFrame(pieTooltipRAFId);
                                    pieTooltipRAFId = requestAnimationFrame(() => {
                                        const margin = 8;
                                        const rect = tooltipEl.getBoundingClientRect();
                                        let left = evt.clientX - rect.width / 2;
                                        let top = evt.clientY - rect.height - 12;
                                        if (left + rect.width + margin > window.innerWidth) left = window.innerWidth - rect.width - margin;
                                        if (left < margin) left = margin;
                                        if (top < margin) top = evt.clientY + 12;
                                        tooltipEl.style.left = `${left}px`;
                                        tooltipEl.style.top = `${top}px`;
                                        pieTooltipRAFId = null;
                                    });
                                }
                            }
                        } else {
                            const dx = Math.abs(evt.clientX - pieTooltipStartX);
                            const dy = Math.abs(evt.clientY - pieTooltipStartY);
                            if (dx > PIE_SWIPE_THRESHOLD || dy > PIE_SWIPE_THRESHOLD) {
                                clearTimeout(pieTooltipLongPressTimer);
                                clearTimeout(pieDetailLongPressTimer);
                                pieTooltipPointerId = null;
                                pieDetailProgressPlanned = false;
                                stopPieDetailProgress();
                                clearPieActiveHighlight();
                                if (pieTooltipRAFId) cancelAnimationFrame(pieTooltipRAFId);
                                pieTooltipRAFId = null;
                                // [v5.1.1] 滑动取消时移除touchmove阻断器，恢复正常滚动
                                if (pieTooltipTouchMoveBlocker) {
                                    window.removeEventListener('touchmove', pieTooltipTouchMoveBlocker, { passive: false, capture: true });
                                    pieTooltipTouchMoveBlocker = null;
                                }
                                window.removeEventListener('pointermove', pieTooltipMoveHandler, true);
                                window.removeEventListener('pointerup', pieTooltipEndHandler, true);
                                window.removeEventListener('pointercancel', pieTooltipEndHandler, true);
                                pieTooltipMoveHandler = null;
                                pieTooltipEndHandler = null;
                            }
                        }
                    };

                    const endHandler = (evt) => {
                        if (pieTooltipPointerId !== null && evt.pointerId !== pieTooltipPointerId) return;
                        const wasLongPress = pieTooltipLongPressActive || pieTooltipLongPressCooldown;
                        clearTimeout(pieTooltipLongPressTimer);
                        clearTimeout(pieDetailLongPressTimer);
                        pieTooltipPointerId = null;
                        pieTooltipLongPressActive = false;
                        pieDetailProgressPlanned = false;
                        clearPieActiveHighlight();
                        // 移除touchmove阻断器
                        if (pieTooltipTouchMoveBlocker) {
                            window.removeEventListener('touchmove', pieTooltipTouchMoveBlocker, { passive: false, capture: true });
                            pieTooltipTouchMoveBlocker = null;
                        }
                        if (pieTooltipRAFId) cancelAnimationFrame(pieTooltipRAFId);
                        pieTooltipRAFId = null;
                        hidePieTooltip();
                        window.removeEventListener('pointermove', pieTooltipMoveHandler, true);
                        window.removeEventListener('pointerup', pieTooltipEndHandler, true);
                        window.removeEventListener('pointercancel', pieTooltipEndHandler, true);
                        pieTooltipMoveHandler = null;
                        pieTooltipEndHandler = null;
                        if (wasLongPress) {
                            setTimeout(() => { pieTooltipLongPressCooldown = false; }, 80);
                        } else {
                            pieTooltipLongPressCooldown = false;
                        }
                        stopPieDetailProgress();
                    };

                    pieTooltipMoveHandler = moveHandler;
                    pieTooltipEndHandler = endHandler;
                    window.addEventListener('pointermove', pieTooltipMoveHandler, { passive: false, capture: true });
                    window.addEventListener('pointerup', pieTooltipEndHandler, true);
                    window.addEventListener('pointercancel', pieTooltipEndHandler, true);

                    pieTooltipLongPressTimer = setTimeout(() => {
                        pieTooltipLongPressActive = true;
                        pieTooltipLongPressCooldown = true;
                        // [v5.8.0] 长按激活震动反馈
                        if (typeof Android !== 'undefined' && Android.vibrate) {
                            Android.vibrate(15);
                        } else if (navigator.vibrate) {
                            navigator.vibrate(15);
                        }
                        // touchmove阻断器已在pointerdown时添加，此处无需重复添加
                        try { container.setPointerCapture(pieTooltipPointerId); } catch(e) {}
                        const slice = getPieSliceAtPoint(container, meta, pieTooltipStartX, pieTooltipStartY);
                        if (slice) {
                            pieTooltipCurrentSliceName = slice.name; // [v5.7.0] 初始化当前slice名称
                            setPieActiveHighlight(container, meta, slice);
                            showPieTooltip(meta, slice, pieTooltipStartX, pieTooltipStartY, false);
                            // 分类视图、任务视图（有taskId或"其他"有otherTasks）都启动进度条
                            const canShowDetail = (meta.view === 'category' && (slice.name !== '其他' || (slice.otherCategories && slice.otherCategories.length > 0))) || 
                                (meta.view === 'task' && slice.taskId) || 
                                (meta.view === 'task' && slice.name === '其他' && slice.otherTasks && slice.otherTasks.length > 0);
                            if (canShowDetail && pieDetailProgressPlanned) {
                                startPieDetailProgress();
                            }
                        }
                    }, 250);

                    // 3秒长按进入详情（分类、任务历史或"其他"详情）
                    const initialSlice = getPieSliceAtPoint(container, meta, e.clientX, e.clientY);
                    if (initialSlice) {
                        if (meta.view === 'category' && initialSlice.name === '其他' && initialSlice.otherCategories && initialSlice.otherCategories.length > 0) {
                            pieDetailLongPressTimer = setTimeout(() => {
                                // [v5.8.0] 进入详情页震动反馈
                                if (typeof Android !== 'undefined' && Android.vibrate) {
                                    Android.vibrate(20);
                                } else if (navigator.vibrate) {
                                    navigator.vibrate(20);
                                }
                                hidePieTooltip();
                                showOtherCategoriesDetail(initialSlice.otherCategories, meta.typeKey || 'earn', true);
                            }, 3000);
                        } else if (meta.view === 'category') {
                            pieDetailLongPressTimer = setTimeout(() => {
                                // [v5.8.0] 进入详情页震动反馈
                                if (typeof Android !== 'undefined' && Android.vibrate) {
                                    Android.vibrate(20);
                                } else if (navigator.vibrate) {
                                    navigator.vibrate(20);
                                }
                                hidePieTooltip();
                                showCategoryDetail(initialSlice.name, meta.typeKey || 'earn', true);
                            }, 3000);
                        } else if (meta.view === 'task' && initialSlice.taskId && initialSlice.name !== '其他') {
                            pieDetailLongPressTimer = setTimeout(() => {
                                // [v5.8.0] 进入详情页震动反馈
                                if (typeof Android !== 'undefined' && Android.vibrate) {
                                    Android.vibrate(20);
                                } else if (navigator.vibrate) {
                                    navigator.vibrate(20);
                                }
                                hidePieTooltip();
                                showTaskHistory(initialSlice.taskId);
                            }, 3000);
                        } else if (meta.view === 'task' && initialSlice.name === '其他' && initialSlice.otherTasks && initialSlice.otherTasks.length > 0) {
                            pieDetailLongPressTimer = setTimeout(() => {
                                // [v5.8.0] 进入详情页震动反馈
                                if (typeof Android !== 'undefined' && Android.vibrate) {
                                    Android.vibrate(20);
                                } else if (navigator.vibrate) {
                                    navigator.vibrate(20);
                                }
                                hidePieTooltip();
                                showOtherTasksDetail(initialSlice.otherTasks, meta.typeKey || 'earn', true);
                            }, 3000);
                        }
                    }
                };

                container.addEventListener('pointerdown', pointerDownHandler);

                container.addEventListener('click', (evt) => {
                    const slice = getPieSliceAtPoint(container, meta, evt.clientX, evt.clientY);
                    if (!slice) return;
                    hidePieTooltip();
                    stopPieDetailProgress();
                    // 分类视图：进入分类详情 / 其他分类详情
                    if (meta.view === 'category' && slice.name === '其他' && slice.otherCategories && slice.otherCategories.length > 0) {
                        showOtherCategoriesDetail(slice.otherCategories, meta.typeKey || 'earn');
                    } else if (meta.view === 'category') {
                        showCategoryDetail(slice.name, meta.typeKey || 'earn');
                    }
                    // 任务视图：进入任务历史（非"其他"且有taskId）
                    else if (meta.view === 'task' && slice.taskId && slice.name !== '其他') {
                        showTaskHistory(slice.taskId);
                    }
                    // 任务视图"其他"：进入其他任务详情
                    else if (meta.view === 'task' && slice.name === '其他' && slice.otherTasks && slice.otherTasks.length > 0) {
                        showOtherTasksDetail(slice.otherTasks, meta.typeKey || 'earn');
                    }
                });
            });
        }

        // [v5.1.1] 时间流图长按弹窗交互（仅7天周期内生效）
        let flowTooltipPointerId = null;
        let flowTooltipLongPressTimer = null;
        let flowTooltipLongPressActive = false;
        let flowTooltipLongPressCooldown = false;
        let flowTooltipTouchMoveBlocker = null;
        let flowTooltipMoveHandler = null;
        let flowTooltipEndHandler = null;
        let flowTooltipRAFId = null;
        let flowTooltipCurrentCategory = null;
        const FLOW_SWIPE_THRESHOLD = 12;

        function hideFlowTooltip() {
            const tooltipEl = document.getElementById('flowTooltip');
            if (!tooltipEl) return;
            tooltipEl.classList.remove('show', 'moving');
            if (flowTooltipRAFId) cancelAnimationFrame(flowTooltipRAFId);
            flowTooltipRAFId = null;
            flowTooltipCurrentCategory = null;
        }

        function showFlowTooltip(meta, clientX, clientY, isMoving) {
            const tooltipEl = document.getElementById('flowTooltip');
            if (!tooltipEl) return;

            // [v5.8.0] 显示任务明细和日期
            const taskDetailsHtml = meta.taskDetails && meta.taskDetails.length > 0 
                ? meta.taskDetails.map(td => 
                    `<div class="trend-tooltip-row" style="font-size:0.8rem;">
                        <span style="max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(td.name)}${td.count > 1 ? ` ×${td.count}` : ''}</span>
                        <span>${formatTime(td.duration)}</span>
                    </div>`
                ).join('') 
                : '';
            
            const datesHtml = meta.dates && meta.dates.length > 0
                ? `<div style="font-size:0.75rem;opacity:0.7;margin-top:6px;padding-top:6px;border-top:1px solid rgba(128,128,128,0.2);">
                    📅 ${meta.dates.map(d => {
                        const [y, m, day] = d.split('-');
                        return `${parseInt(m)}/${parseInt(day)}`;
                    }).join('、')}
                </div>`
                : '';

            const html = `<span class="trend-tooltip-title" style="display:flex;align-items:center;gap:6px;">
                    <span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:${meta.color};"></span>
                    ${escapeHtml(meta.category)}
                </span>
                <div class="trend-tooltip-list">
                    <div class="trend-tooltip-row"><span>占比</span><span>${meta.percent}%</span></div>
                    <div class="trend-tooltip-row"><span>${meta.typeLabel}</span><span>${formatTime(meta.duration)}</span></div>
                </div>
                ${taskDetailsHtml ? `<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(128,128,128,0.2);">${taskDetailsHtml}</div>` : ''}
                ${datesHtml}`;

            const categoryChanged = flowTooltipCurrentCategory !== meta.category;
            if (!isMoving || categoryChanged) {
                tooltipEl.innerHTML = `<div class="trend-tooltip-content">${html}</div>`;
                flowTooltipCurrentCategory = meta.category;
            }
            tooltipEl.classList.add('show');
            tooltipEl.classList.toggle('moving', !!isMoving);

            const applyPosition = () => {
                const margin = 8;
                const rect = tooltipEl.getBoundingClientRect();
                let left = clientX - rect.width / 2;
                let top = clientY - rect.height - 12;
                if (left + rect.width + margin > window.innerWidth) left = window.innerWidth - rect.width - margin;
                if (left < margin) left = margin;
                if (top < margin) top = clientY + 12;
                tooltipEl.style.left = `${left}px`;
                tooltipEl.style.top = `${top}px`;
            };

            if (isMoving) {
                if (flowTooltipRAFId) cancelAnimationFrame(flowTooltipRAFId);
                flowTooltipRAFId = requestAnimationFrame(() => {
                    applyPosition();
                    flowTooltipRAFId = null;
                });
            } else {
                applyPosition();
            }
        }

        function getFlowSegmentAtPoint(clientX, clientY) {
            const segments = document.querySelectorAll('.flow-bar-segment[data-flow-meta]');
            for (const seg of segments) {
                const rect = seg.getBoundingClientRect();
                if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                    try {
                        return JSON.parse(decodeURIComponent(seg.getAttribute('data-flow-meta')));
                    } catch(e) {}
                }
            }
            return null;
        }

        function initFlowTooltips() {
            const tooltipEl = document.getElementById('flowTooltip');
            if (!tooltipEl) return;
            hideFlowTooltip();

            const segments = document.querySelectorAll('.flow-bar-segment[data-flow-meta]');
            segments.forEach(segment => {
                const pointerDownHandler = (e) => {
                    if (e.pointerType === 'mouse') return;
                    clearTimeout(flowTooltipLongPressTimer);
                    flowTooltipPointerId = e.pointerId;
                    flowTooltipLongPressActive = false;
                    flowTooltipLongPressCooldown = false;
                    const startX = e.clientX;
                    const startY = e.clientY;

                    // 立即添加touchmove阻断器
                    if (flowTooltipTouchMoveBlocker) {
                        window.removeEventListener('touchmove', flowTooltipTouchMoveBlocker, { passive: false, capture: true });
                    }
                    flowTooltipTouchMoveBlocker = (ev) => { ev.preventDefault(); };
                    window.addEventListener('touchmove', flowTooltipTouchMoveBlocker, { passive: false, capture: true });

                    const moveHandler = (evt) => {
                        if (evt.pointerId !== flowTooltipPointerId) return;
                        if (flowTooltipLongPressActive) {
                            evt.preventDefault();
                            evt.stopPropagation();
                            const foundMeta = getFlowSegmentAtPoint(evt.clientX, evt.clientY);
                            if (foundMeta) {
                                showFlowTooltip(foundMeta, evt.clientX, evt.clientY, true);
                            } else {
                                // 在空白区域也更新位置
                                if (tooltipEl.classList.contains('show')) {
                                    tooltipEl.classList.add('moving');
                                    if (flowTooltipRAFId) cancelAnimationFrame(flowTooltipRAFId);
                                    flowTooltipRAFId = requestAnimationFrame(() => {
                                        const margin = 8;
                                        const rect = tooltipEl.getBoundingClientRect();
                                        let left = evt.clientX - rect.width / 2;
                                        let top = evt.clientY - rect.height - 12;
                                        if (left + rect.width + margin > window.innerWidth) left = window.innerWidth - rect.width - margin;
                                        if (left < margin) left = margin;
                                        if (top < margin) top = evt.clientY + 12;
                                        tooltipEl.style.left = `${left}px`;
                                        tooltipEl.style.top = `${top}px`;
                                        flowTooltipRAFId = null;
                                    });
                                }
                            }
                        } else {
                            const dx = Math.abs(evt.clientX - startX);
                            const dy = Math.abs(evt.clientY - startY);
                            if (dx > FLOW_SWIPE_THRESHOLD || dy > FLOW_SWIPE_THRESHOLD) {
                                clearTimeout(flowTooltipLongPressTimer);
                                flowTooltipPointerId = null;
                                if (flowTooltipRAFId) cancelAnimationFrame(flowTooltipRAFId);
                                flowTooltipRAFId = null;
                                if (flowTooltipTouchMoveBlocker) {
                                    window.removeEventListener('touchmove', flowTooltipTouchMoveBlocker, { passive: false, capture: true });
                                    flowTooltipTouchMoveBlocker = null;
                                }
                                window.removeEventListener('pointermove', flowTooltipMoveHandler, true);
                                window.removeEventListener('pointerup', flowTooltipEndHandler, true);
                                window.removeEventListener('pointercancel', flowTooltipEndHandler, true);
                                flowTooltipMoveHandler = null;
                                flowTooltipEndHandler = null;
                            }
                        }
                    };

                    const endHandler = (evt) => {
                        if (flowTooltipPointerId !== null && evt.pointerId !== flowTooltipPointerId) return;
                        const wasLongPress = flowTooltipLongPressActive || flowTooltipLongPressCooldown;
                        clearTimeout(flowTooltipLongPressTimer);
                        flowTooltipPointerId = null;
                        flowTooltipLongPressActive = false;
                        if (flowTooltipTouchMoveBlocker) {
                            window.removeEventListener('touchmove', flowTooltipTouchMoveBlocker, { passive: false, capture: true });
                            flowTooltipTouchMoveBlocker = null;
                        }
                        if (flowTooltipRAFId) cancelAnimationFrame(flowTooltipRAFId);
                        flowTooltipRAFId = null;
                        hideFlowTooltip();
                        window.removeEventListener('pointermove', flowTooltipMoveHandler, true);
                        window.removeEventListener('pointerup', flowTooltipEndHandler, true);
                        window.removeEventListener('pointercancel', flowTooltipEndHandler, true);
                        flowTooltipMoveHandler = null;
                        flowTooltipEndHandler = null;
                        if (wasLongPress) {
                            setTimeout(() => { flowTooltipLongPressCooldown = false; }, 80);
                        } else {
                            flowTooltipLongPressCooldown = false;
                        }
                    };

                    flowTooltipMoveHandler = moveHandler;
                    flowTooltipEndHandler = endHandler;
                    window.addEventListener('pointermove', flowTooltipMoveHandler, { passive: false, capture: true });
                    window.addEventListener('pointerup', flowTooltipEndHandler, true);
                    window.addEventListener('pointercancel', flowTooltipEndHandler, true);

                    flowTooltipLongPressTimer = setTimeout(() => {
                        flowTooltipLongPressActive = true;
                        flowTooltipLongPressCooldown = true;
                        try { segment.setPointerCapture(flowTooltipPointerId); } catch(e) {}
                        const meta = getFlowSegmentAtPoint(startX, startY);
                        if (meta) {
                            showFlowTooltip(meta, startX, startY, false);
                        }
                    }, 250);
                };

                segment.addEventListener('pointerdown', pointerDownHandler);
            });
        }

        function renderTaskCards(taskList) {
            const todayStr = getLocalDateString(new Date()); 
            return taskList.map(task => {
                const safeTaskName = escapeHtml(task.name);
                const safeCategory = escapeHtml(task.category);
                const runningTask = runningTasks.get(task.id);
                const isRunning = !!runningTask;
                const color = categoryColors.get(task.category) || '#666';
                const badgeGradient = getBadgeGradient(color);
                const habitClass = task.isHabit ? 'is-habit' : '';
                const highlightClass = highlightedHabits.has(task.id) ? 'highlight-incomplete' : ''; // [v4.4.0] Add highlight class
                const habitStyle = task.isHabit ? `style="--habit-color: ${color}"` : '';
                
                // [v5.6.0] 开启自动补录的任务禁用手动补录
                const canBackdate = ['continuous', 'continuous_target', 'continuous_redeem', 'reward', 'instant_redeem'].includes(task.type);
                // [v5.6.0] 根据是否开启自动补录显示不同菜单项
                const hasAutoDetect = task.appPackage && task.autoDetect;
                let backdateMenuItem = '';
                if (canBackdate) {
                    if (hasAutoDetect) {
                        // 开启自动补录：显示手动触发按钮
                        backdateMenuItem = `<div class="task-card-menu-item" onclick="event.stopPropagation(); runAutoDetectForTask('${task.id}')">🤖 补录</div>`;
                    } else {
                        // 未开启自动补录：显示手动补录按钮
                        backdateMenuItem = `<div class="task-card-menu-item" onclick="event.stopPropagation(); showBackdateModal('${task.id}')">📆 补录</div>`;
                    }
                }

                const isMenuOpen = task.id === activeMenuTaskId;
                const menuClass = isMenuOpen ? 'task-card-menu show' : 'task-card-menu';
                const menuDiv = `<div class="${menuClass}"> 
                                    <div class="task-card-menu-item" onclick="editTask(tasks.find(t => t.id === '${task.id}'))">✏️ 编辑</div>
                                    <div class="task-card-menu-item" onclick="showTaskHistory('${task.id}')">📋 历史</div>
                                    ${backdateMenuItem}
                                </div>`;
                const titleRow = `<div class="task-row title-row">
                                    <div class="task-name" title="${safeTaskName}">${safeTaskName}</div>
                                    <!-- [v6.2.4-Fix] 改用 div 替代 button 以彻底根除原生样式干扰 -->
                                    <div class="more-btn" role="button" tabindex="0" onclick="toggleTaskMenu(event)">...</div>
                                    ${menuDiv}
                                </div>`; 
                                
                // [v5.1.0] 分类标签渐变（左深右浅）
                const categoryGradient = getCategoryGradient(color); // 标签：左深右浅
                let statusDetails = `<span class="task-category" style="--category-gradient: ${categoryGradient}; background: ${categoryGradient};">${safeCategory}</span>`; 
                
                if (task.isHabit) {
                    const periodInfoToday = getHabitPeriodInfo(task, transactions, new Date());
                    const targetCount = periodInfoToday.targetCount || 1; 
                    const dailyLimit = task.habitDetails.dailyLimit || 1;
                    // [v4.8.5] 修复：达标任务仅统计真正达标的记录
                    const completionsToday = transactions.filter(t => {
                        const isSameTask = t.taskId === task.id;
                        const isToday = getLocalDateString(t.timestamp) === todayStr;
                        const isEarn = t.type === 'earn';
                        if (!isSameTask || !isToday || !isEarn) return false;
                        // 如果是达标任务，必须满足时长要求或有达标标记
                        if (task.type === 'continuous_target') {
                            return t.amount >= task.targetTime || t.isStreakAdvancement;
                        }
                        return true;
                    }).length;
                    
                    const isTargetAchieved = periodInfoToday.currentCount >= targetCount;
                    const isDailyLimitReached = completionsToday >= dailyLimit;
                    
                    const unitMap = { daily: '天', weekly: '周', monthly: '月' };
                    const periodText = unitMap[task.habitDetails.period] || '次';
                    
                    // [v4.8.7 Logic] 习惯卡片状态显示重构
                    const isAbstinence = task.habitDetails.type === 'abstinence';
                    
                    // Priority 1: Daily Limit Reached? (仅针对养成类)
                    if (!isAbstinence && isDailyLimitReached) {
                        statusDetails += ` <span class="task-completion-count text-positive">今日已完成 ✅</span>`;
                    }
                    // Priority 2: Period Target Met? (仅针对养成类，戒除类不显示"已达标")
                    else if (!isAbstinence && isTargetAchieved) {
                        if (task.type === 'continuous_target') {
                            if (completionsToday > 0) {
                                statusDetails += ` <span class="task-completion-count text-positive">已达标✅连续${task.habitDetails.streak || 0}${periodText}</span>`;
                            } else {
                                statusDetails += ` <span class="task-completion-count">已连续 ${task.habitDetails.streak || 0} ${periodText}</span>`;
                            }
                        } else {
                            statusDetails += ` <span class="task-completion-count text-positive">已达标✅连续${task.habitDetails.streak || 0}${periodText}</span>`;
                        }
                    }
                    // Priority 3: Default / Abstinence Logic
                    else {
                        // [v4.8.7 Fix] 戒除任务专属显示逻辑
                        if (isAbstinence) {
                            const used = periodInfoToday.currentCount;
                            const limit = targetCount;
                            
                            if (used > limit) {
                                // 超额状态
                                statusDetails += ` <span class="task-completion-count text-negative" style="font-weight:bold;">已超额 (${used}/${limit}) ❌</span>`;
                            } else if (used === limit) {
                                // 临界状态
                                statusDetails += ` <span class="task-completion-count" style="color:var(--color-warning); font-weight:bold;">额度已用尽 (${used}/${limit}) </span>`;
                            } else {
                                // 正常状态
                                statusDetails += ` <span class="task-completion-count">已用额度: ${used}/${limit}</span>`;
                            }
                        } else {
                            // 养成任务普通状态
                            const isDailyBroken = task.habitDetails.period === 'daily' && task.habitDetails.isBroken && completionsToday === 0;
                            
                            if (isDailyBroken) {
                                statusDetails += ` <span class="task-completion-count text-negative">昨日已中断</span>`;
                            } else if ((task.habitDetails.streak || 0) > 0 && completionsToday === 0) {
                                statusDetails += ` <span class="task-completion-count">已连续 ${task.habitDetails.streak} ${periodText}</span>`;
                            } else {
                                statusDetails += ` <span class="task-completion-count">已完成 ${periodInfoToday.currentCount}/${targetCount} 次</span>`;
                            }
                        }
                    }
                    
                } else if ((task.completionCount || 0) > 0) { 
                    statusDetails += ` <span class="task-completion-count">已完成 ${task.completionCount} 次</span>`; 
                } 
                

                const statusRow = `<div class="task-row"><div class="task-details">${statusDetails}</div></div>`; let paramsText = ''; switch (task.type) { case 'reward': paramsText = `奖励: ${formatTime(task.fixedTime, false)}`; break; case 'continuous': paramsText = `${task.multiplier}倍率`; break; case 'continuous_target': paramsText = `目标${formatTime(task.targetTime, false).replace(/0秒$/, '').trim()}`; break; case 'instant_redeem': paramsText = `消费: ${formatTime(task.consumeTime, false)}`; break; case 'continuous_redeem': paramsText = `${task.multiplier}倍率`; break; } let paramsRow = `<div class="task-row task-parameters">${paramsText}</div>`; let actionRow = ''; let timerBadge = ''; if (isRunning) { const isPaused = runningTask.isPaused; const totalSeconds = Math.floor((runningTask.elapsedTime + (isPaused ? 0 : Date.now() - runningTask.startTime)) / 1000); const pauseResumeBtn = isPaused ? `<button class="task-btn primary" onclick="resumeTask('${task.id}')">继续</button>` : `<button class="task-btn warning" onclick="pauseTask('${task.id}')">暂停</button>`; actionRow = `<div class="task-row task-actions">${pauseResumeBtn}<button class="task-btn secondary" onclick="cancelTask('${task.id}')">取消</button><button class="task-btn danger" onclick="stopTask('${task.id}')">结束</button></div>`; 

                        // [v5.1.0] 运行中徽章放置在参数行，移除进度百分比
                        let timerText = `${formatTime(totalSeconds)}`; 
                        let timerClass = 'task-timer-badge';
                        if (task.type === 'continuous_target') { 
                            if (runningTask.achieved) {
                                timerText += `·✅`; 
                            }
                        } 
                        const pausedBadgeBg = 'linear-gradient(135deg, #b5b5b5, #8a8a8a)';
                        const badgeBg = isPaused ? pausedBadgeBg : badgeGradient;
                        timerBadge = `<span class="${timerClass}" style="background:${badgeBg};">${timerText}</span>`; 
                    paramsRow = `<div class="task-row task-parameters has-timer-badge"><span>${paramsText}</span><span>${timerBadge}</span></div>`;
                
                    } else { let actionButton = ''; switch (task.type) { case 'reward': actionButton = `<button class="task-btn success wide" onclick="completeTask('${task.id}')">完成</button>`; break; case 'instant_redeem': actionButton = `<button class="task-btn danger wide" onclick="redeemTask('${task.id}')">兑换</button>`; break; default: actionButton = `<button class="task-btn primary wide" onclick="startTask(event, '${task.id}')">开始</button>`; break; } actionRow = `<div class="task-row task-actions">${actionButton}</div>`; } 
            
                    // [v4.4.0] 注入 highlightClass; [v5.1.0] 运行中徽章嵌入参数行; [v6.0.0] 添加卡片样式类
                    const cardStyleClass = screenTimeSettings.cardStyle || 'classic';
                    return `<div class="task-card ${cardStyleClass} ${habitClass} ${highlightClass}" ${habitStyle} data-task-id="${task.id}">${titleRow}${statusRow}${paramsRow}${actionRow}</div>`; 
            
            }).join(''); 
        }

        // [v6.4.6] 全局菜单相关
        const globalTaskMenu = document.getElementById('globalTaskMenu');
        
        function toggleTaskMenu(event) { 
            event.stopPropagation(); 
            const card = event.target.closest('.task-card');
            if (!card) return;
            const taskId = card.dataset.taskId;
            if (!taskId) return;

            // 切换状态变量
            if (activeMenuTaskId === taskId) {
                closeGlobalTaskMenu();
                return;
            }
            
            activeMenuTaskId = taskId;
            
            // [v6.4.6] 填充并定位全局菜单
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // 构建菜单内容 - 与旧菜单保持一致，点击后关闭菜单
            const menuItems = [
                `<div class="global-task-menu-item" onclick="closeGlobalTaskMenu(); editTask(tasks.find(t => t.id === '${taskId}'))">✏️ 编辑</div>`,
                `<div class="global-task-menu-item" onclick="closeGlobalTaskMenu(); showTaskHistory('${taskId}')">📋 历史</div>`
            ];
            
            // 补录按钮 - 与旧版一致，支持按次任务/按次消费
            const canBackdate = ['continuous', 'continuous_target', 'continuous_redeem', 'reward', 'instant_redeem'].includes(task.type);
            if (canBackdate) {
                if (task.autoDetect && task.autoDetect.enabled) {
                    menuItems.push(`<div class="global-task-menu-item" onclick="closeGlobalTaskMenu(); runAutoDetectForTask('${taskId}')">🤖 补录</div>`);
                } else {
                    menuItems.push(`<div class="global-task-menu-item" onclick="closeGlobalTaskMenu(); showBackdateModal('${taskId}')">📆 补录</div>`);
                }
            }
            
            globalTaskMenu.innerHTML = menuItems.join('');
            
            // 定位菜单
            const moreBtn = card.querySelector('.more-btn');
            const btnRect = moreBtn.getBoundingClientRect();
            const cardRect = card.getBoundingClientRect();
            
            // 菜单位置：按钮下方，右对齐
            let menuTop = btnRect.bottom + 4;
            let menuRight = window.innerWidth - btnRect.right;
            
            // 计算可用高度：卡片底部 - 按钮底部 - 边距
            const maxHeight = cardRect.bottom - btnRect.bottom - 8;
            
            globalTaskMenu.style.top = menuTop + 'px';
            globalTaskMenu.style.right = menuRight + 'px';
            globalTaskMenu.style.left = 'auto';
            globalTaskMenu.style.maxHeight = Math.max(maxHeight, 100) + 'px';
            globalTaskMenu.classList.add('show');
        }
        
        function closeGlobalTaskMenu() {
            globalTaskMenu.classList.remove('show');
            activeMenuTaskId = null;
        }

        document.addEventListener('click', (event) => { 
            // [v6.4.6] 处理全局菜单关闭
            if (!event.target.closest('.more-btn') && !event.target.closest('.global-task-menu')) {
                closeGlobalTaskMenu();
            }
        });
        
        // [v6.4.6] 滚动时关闭全局菜单 - 监听主滚动容器
        const appScrollContainer = document.querySelector('.app-scroll-container');
        if (appScrollContainer) {
            appScrollContainer.addEventListener('scroll', () => {
                if (activeMenuTaskId) {
                    closeGlobalTaskMenu();
                }
            }, { passive: true });
        }
        
        // [v4.3.8] 修复: Habit Nudge 逻辑移至此
        function updateRunningTimers() { 
            runningTasks.forEach((runningTask, taskId) => { 
                if (runningTask.isPaused) return; 
                const task = tasks.find(t => t.id === taskId); 
                if (task) { 
                    const totalSeconds = Math.floor((runningTask.elapsedTime + Date.now() - runningTask.startTime)) / 1000; 
                    
                    // [v4.7.0] 重构达标提醒逻辑：首次达标检测
                    if (task.type === 'continuous_target' && !runningTask.achieved && totalSeconds >= task.targetTime) { 
                        runningTask.achieved = true; 
                        runningTask.achievedTime = Date.now(); 
                        saveData(); 
                        showNotification('🎯 达标提醒', `任务"${task.name}"已达到目标时间！`, 'achievement'); 
                    }
                    
                    // [v4.7.0] 10分钟超时提醒
                    if (runningTask.achieved && !runningTask.tenMinReminderSent && Date.now() - runningTask.achievedTime >= 600000) {
                        runningTask.tenMinReminderSent = true;
                        saveData();
                        showNotification('⏰ 任务超时提醒', `达标任务已完成超过10分钟，别忘了结束哦！`, 'longRunning');
                    }
                    
                    if (notificationSettings.longRunning && totalSeconds > 0 && totalSeconds > notificationSettings.longRunningThreshold && (totalSeconds % notificationSettings.longRunningThreshold < 1)) {
                        showNotification('⏰ 长时间运行提醒', `任务"${task.name}"已运行${formatTime(totalSeconds)}`, 'longRunning'); 
                    }
                    
                    const timerElements = document.querySelectorAll(`.task-card[data-task-id="${taskId}"] .task-timer-badge`);
                    if (timerElements.length > 0) {
                        let timerText = `${formatTime(totalSeconds)}`;
                        let timerClass = 'task-timer-badge';
                        const colorHex = categoryColors.get(task.category) || '#666';
                        const badgeGradient = getBadgeGradient(colorHex);
                        if (task.type === 'continuous_target') {
                            if (runningTask.achieved) {
                                timerText += `✅`; 
                            }
                        }
                        timerElements.forEach(timerElement => {
                            timerElement.textContent = timerText;
                            timerElement.className = timerClass;
                            timerElement.style.background = badgeGradient;
                        });
                    }
                } 
            });
            
            // [v3.15.0] Daily Habit Nudge Check
            if (!notificationSettings.habitNudgeEnabled) return;
            const now = new Date();
            const todayStr = getLocalDateString(now);
            if (notificationSettings.lastNudgeDate === todayStr) return; // 已检查过
            
            const [nudgeHours, nudgeMinutes] = notificationSettings.habitNudgeTime.split(':').map(Number);
            if (now.getHours() < nudgeHours || (now.getHours() === nudgeHours && now.getMinutes() < nudgeMinutes)) {
                return; // 没到时间
            }

            // [v4.3.8] 关键修复：使用锁防止异步 saveData 循环
            if (isProcessingNudge) return; // 正在处理，跳过

            isProcessingNudge = true; // 设置锁
            notificationSettings.lastNudgeDate = todayStr; // 立即更新内存

            // 保存更改，并在保存完成后（无论成功/失败）释放锁
            saveData().finally(() => {
                isProcessingNudge = false;
            });

            // 检查未完成的习惯（现在移到 saveData 之外）
            // [v4.8.7 Fix] 每日习惯提醒逻辑修复
            const uncompletedHabits = tasks.filter(t => t.isHabit).filter(t => {
                // 1. 获取周期数据 (修复变量解构：使用 targetCount 而非旧版 targetCountInPeriod)
                const { currentCount, targetCount } = getHabitPeriodInfo(t, transactions, new Date());
                
                // For daily habits, check if today's completions meet the target
                if (t.habitDetails.period === 'daily') {
                    const completionsToday = transactions.filter(tx => 
                        tx.taskId === t.id && 
                        tx.type === 'earn' && 
                        getLocalDateString(tx.timestamp) === todayStr
                    ).length;
                    return completionsToday < (targetCount || 1);
                }
                
                // For weekly/monthly habits, check if target has been achieved in the current period
                return currentCount < (targetCount || 1);
            });

            if (uncompletedHabits.length > 0) {
                const title = '🌙 每日习惯提醒';
                const body = `您今天还有 ${uncompletedHabits.length} 个习惯未完成，例如：${uncompletedHabits[0].name}...`;
                showNotification(title, body, 'habitNudge'); 
            }
            
            // [v4.3.8] 已移除末尾多余的 saveData()
        } 
        
        function toggleCategory(category) { collapsedCategories.has(category) ? collapsedCategories.delete(category) : collapsedCategories.add(category); saveData(); updateCategoryTasks(); }
        
        // [v5.0.0] 切换分类内任务的展开/收起状态
        function toggleCategoryTaskExpand(category, event) {
            event.stopPropagation();
            if (expandedTaskCategories.has(category)) {
                expandedTaskCategories.delete(category);
            } else {
                expandedTaskCategories.add(category);
            }
            updateCategoryTasks();
        }
        function updateBalance() { const balanceCard = document.getElementById('balanceCard'); const balanceAmount = document.getElementById('balanceAmount'); balanceAmount.textContent = formatTime(currentBalance); balanceCard.classList.toggle('negative', currentBalance < 0); balanceAmount.style.color = currentBalance < 0 ? 'var(--color-negative)' : (currentBalance < notificationSettings.lowBalanceThreshold ? 'var(--color-warning)' : 'var(--color-primary)'); const todayChanges = dailyChanges[new Date().toDateString()] || { earned: 0, spent: 0 }; document.getElementById('dailyEarned').textContent = formatTime(todayChanges.earned); document.getElementById('dailySpent').textContent = formatTime(todayChanges.spent); if (notificationSettings.lowBalance && currentBalance >= 0 && currentBalance < notificationSettings.lowBalanceThreshold) { const todayKey = getLocalDateString(new Date()); if (notificationSettings.lastLowBalanceAlertDate !== todayKey) { showNotification('⚠️ 余额不足', `当前余额仅剩 ${formatTime(currentBalance)}`, 'lowBalance'); notificationSettings.lastLowBalanceAlertDate = todayKey; saveData(); } } }
// --- Task Creation/Editing Modals ---
        function showTaskModal() { 
            currentEditingTask = null; 
            currentSelectedColor = null; 
            document.getElementById('modalTitle').textContent = '创建新任务'; 
            document.getElementById('submitBtn').textContent = '创建'; 
            document.getElementById('deleteBtn').classList.add('hidden'); 
            document.getElementById('taskForm').reset(); 
            // [v6.4.0] 重置任务类型选择器
            document.getElementById('taskType').value = '';
            document.getElementById('taskTypeTrigger').textContent = '请选择任务类型';
            
            populateAppSuggestions();
            const appInput = document.getElementById('taskAppPackage');
            if (appInput) {
                appInput.value = '';
                delete appInput.dataset.selectedPackage; // [v5.2.0] 清除选中包名
            }
            const appToggle = document.getElementById('isAppLauncherToggle');
            if (appToggle) { appToggle.checked = false; toggleAppLauncherSettings(false); }
            // [v5.3.0] 重置自动检测补录开关
            const autoDetectToggle = document.getElementById('isAutoDetectToggle');
            if (autoDetectToggle) { autoDetectToggle.checked = false; }
            const floatingTimerToggle = document.getElementById('isFloatingTimerToggle');
            if (floatingTimerToggle) floatingTimerToggle.checked = false;
            // [v3.18.0] Reset target count
            document.getElementById('targetCountInPeriod').value = 1; 
            document.getElementById('habitDailyLimit').value = 1; 
            // [v6.4.0] 重置自定义下拉菜单
            selectHabitPeriod('daily');
            updateFormForTaskType(); 
            toggleHabitSettings(false); 
            toggleReminderSettings(false); 
            toggleRecurringReminderVisibility(); 
            document.getElementById('habitRewardsContainer').innerHTML = ''; 
            document.getElementById('taskModal').classList.add('show'); 
        }
        function hideTaskModal() { document.getElementById('taskModal').classList.remove('show'); clearFormErrors(); }
function editTask(task) { 
            if (!task) return;
            currentEditingTask = task; 
            currentSelectedColor = categoryColors.get(task.category); 
            document.getElementById('modalTitle').textContent = '编辑任务'; 
            document.getElementById('submitBtn').textContent = '保存'; 
            document.getElementById('deleteBtn').classList.remove('hidden'); 
            const form = document.getElementById('taskForm'); 
            form.taskName.value = task.name; 
            form.taskCategory.value = task.category; 
            // [v6.4.0] 任务类型回填 - 更新触发器显示和隐藏字段
            document.getElementById('taskType').value = task.type;
            const taskTypeLabels = {
                reward: '按次任务', continuous: '计时任务', continuous_target: '达标任务',
                instant_redeem: '按次消费', continuous_redeem: '计时消费'
            };
            document.getElementById('taskTypeTrigger').textContent = taskTypeLabels[task.type] || '请选择任务类型';
            
            populateAppSuggestions();
            const appToggle = document.getElementById('isAppLauncherToggle');
            const appInput = document.getElementById('taskAppPackage');
            const hasApp = !!task.appPackage;
            if (appToggle) appToggle.checked = hasApp;
            if (appInput) {
                appInput.value = resolveAppInputValue(task.appPackage);
                // [v5.2.0] 保存原始包名用于提交
                if (task.appPackage) {
                    appInput.dataset.selectedPackage = task.appPackage;
                } else {
                    delete appInput.dataset.selectedPackage;
                }
            }
            toggleAppLauncherSettings(hasApp);
            // [v5.3.0] 加载自动检测补录状态
            const autoDetectToggle = document.getElementById('isAutoDetectToggle');
            if (autoDetectToggle) {
                autoDetectToggle.checked = task.autoDetect || false;
            }

            // [v4.11.0] 悬浮窗计时器兼容逻辑
            const floatingTimerToggle = document.getElementById('isFloatingTimerToggle');
            if (floatingTimerToggle) {
                let floatEnabled = false;
                if (task.enableFloatingTimer !== undefined) {
                    floatEnabled = task.enableFloatingTimer;
                } else {
                    floatEnabled = (task.type === 'continuous_target');
                }
                floatingTimerToggle.checked = floatEnabled;
            }
            // [v4.8.2] 读取时将秒转换为分钟
            if (task.fixedTime) form.fixedTime.value = parseFloat((task.fixedTime / 60).toFixed(2)); 
            if (task.consumeTime) form.consumeTime.value = parseFloat((task.consumeTime / 60).toFixed(2)); 
            if (task.multiplier) form.multiplier.value = task.multiplier; 
            if (task.targetTime) form.targetTime.value = parseFloat((task.targetTime / 60).toFixed(2)); 
            if (task.bonusReward) form.bonusReward.value = parseFloat((task.bonusReward / 60).toFixed(2)); 
            
            document.getElementById('isHabitToggle').checked = task.isHabit || false; 
            if (task.isHabit && task.habitDetails) { 
                const periodValue = task.habitDetails.period || 'daily';
                selectHabitPeriod(periodValue);
                
                // [v3.18.0] Load new target count
                document.getElementById('targetCountInPeriod').value = task.habitDetails.targetCountInPeriod || 1; 
                document.getElementById('habitDailyLimit').value = task.habitDetails.dailyLimit || 1; 
                const rewardsContainer = document.getElementById('habitRewardsContainer'); 
                rewardsContainer.innerHTML = ''; 
                (task.habitDetails.rewards || []).forEach(rule => addHabitRewardRule(rule)); 
            } else { 
                document.getElementById('habitRewardsContainer').innerHTML = ''; 
                // [v3.18.0] Reset to default values
                document.getElementById('targetCountInPeriod').value = 1; 
                document.getElementById('habitDailyLimit').value = 1; 
            }
            
            const hasReminder = task.reminderDetails && task.reminderDetails.status === 'pending';
            document.getElementById('isReminderToggle').checked = hasReminder;
            if (hasReminder) {
                const { mode, time, isRecurring } = task.reminderDetails;
                switchReminderMode(mode);
                if (mode === 'absolute') {
                    document.getElementById('reminderDateTime').value = time;
                    document.getElementById('isRecurringReminderToggle').checked = isRecurring || false; 
                } else { // relative
                    document.getElementById('reminderHours').value = Math.floor(time / 3600);
                    document.getElementById('reminderMinutes').value = Math.floor((time % 3600) / 60);
                }
            } else {
                switchReminderMode('absolute'); 
            }

            updateFormForTaskType(); 
            toggleHabitSettings(task.isHabit);
            toggleReminderSettings(hasReminder);
            toggleRecurringReminderVisibility(); 
            
            document.getElementById('taskModal').classList.add('show'); 
        }
        
        /**
         * 删除任务
         * [v5.9.0] 支持事件驱动写入模式
         */
        async function deleteTask() {
            if (!currentEditingTask) return;
            const confirmed = await showConfirm(`确定要删除任务"${currentEditingTask.name}"吗？`, '删除任务');
            if (!confirmed) return;
            
            const taskId = currentEditingTask.id;
            const taskName = currentEditingTask.name;
            
            // [v5.9.0] Phase 4: 事件驱动写入模式
            if (USE_EVENT_SOURCING) {
                const result = await dispatchEvent(EVENT_TYPES.TASK_DELETED, {
                    taskId: taskId,
                    taskName: taskName,
                    deletedAt: new Date().toISOString()
                });
                
                if (!result.success) {
                    // Fallback: 事件写入失败，使用传统方式
                    console.warn('[ES] deleteTask fallback to legacy mode');
                    runningTasks.delete(taskId);
                    tasks = tasks.filter(t => t.id !== taskId);
                    saveData();
                    updateAllUI();
                }
                // dispatchEvent 已处理 UI 更新
            } else {
                // 传统模式（保持原逻辑）
                runningTasks.delete(taskId);
                tasks = tasks.filter(t => t.id !== taskId);
                
                // [v5.8.1] 旁听记录事件
                logEvent(EVENT_TYPES.TASK_DELETED, { taskId, taskName });
                
                saveData();
                updateAllUI();
            }
            
            hideTaskModal();
        }
        function updateFormForTaskType() { 
            const taskType = document.getElementById('taskType').value; 
            const earnTypes = ['reward', 'continuous', 'continuous_target']; 
            const isContinuous = ['continuous', 'continuous_target', 'continuous_redeem'].includes(taskType);
            const colorSelectorContainer = document.getElementById('colorSelectorContainer'); 
            const earnColorSelector = document.getElementById('earnColorSelector'); 
            const spendColorSelector = document.getElementById('spendColorSelector'); 
            const floatingTimerToggle = document.getElementById('floatingTimerToggleContainer');
            
            // 1. 隐藏所有特定类型设置组
            document.querySelectorAll('#taskForm .form-group[id$="Group"]').forEach(el => el.classList.add('hidden')); 
            if (floatingTimerToggle) floatingTimerToggle.classList.toggle('hidden', !isContinuous);
            
            // 2. 颜色选择器逻辑
            if (taskType) { 
                colorSelectorContainer.classList.remove('hidden'); 
                const isEarn = earnTypes.includes(taskType); 
                earnColorSelector.classList.toggle('hidden', !isEarn); 
                spendColorSelector.classList.toggle('hidden', isEarn); 
                renderColorSelectors(currentEditingTask ? categoryColors.get(currentEditingTask.category) : null); 
            } else { 
                colorSelectorContainer.classList.add('hidden'); 
            } 
            
            // 3. 习惯/戒除 开关逻辑
            const habitToggle = document.getElementById('habitToggleContainer'); 
            const canBeHabit = ['reward', 'continuous', 'continuous_target', 'instant_redeem', 'continuous_redeem'].includes(taskType);
            
            if (canBeHabit) { 
                habitToggle.classList.remove('hidden'); 
                
                // === [v4.8.6] 文案与布局动态切换的核心逻辑 ===
                const isSpendType = ['instant_redeem', 'continuous_redeem'].includes(taskType);
                
                // 获取 DOM 元素 (使用 ID，绝对安全)
                const toggleTitle = document.getElementById('habitToggleTitle');
                const toggleDesc = document.getElementById('habitToggleDesc');
                const settingsTitle = document.getElementById('habitSettingsTitle');
                const targetLabel = document.getElementById('targetCountLabel');
                const rewardsLabel = document.getElementById('habitRewardsLabel');
                
                // 获取需要隐藏/显示的容器
                const dailyLimitGroup = document.getElementById('habitDailyLimit')?.closest('.form-group');
                const targetCountInput = document.getElementById('targetCountInPeriod');
                
                if (isSpendType) {
                    // === 戒除模式 ===
                    if (toggleTitle) toggleTitle.textContent = '开启习惯戒除';
                    if (toggleDesc) toggleDesc.textContent = '设定额度，控制消费，获得奖励';
                    if (settingsTitle) settingsTitle.textContent = '习惯戒除设置';
                    if (targetLabel) {
                        targetLabel.textContent = taskType === 'continuous_redeem' 
                            ? '周期时长额度*' 
                            : '周期次数额度*';
                    }
                    // 计时类戒除用 placeholder 提示分钟单位
                    if (targetCountInput) {
                        targetCountInput.placeholder = taskType === 'continuous_redeem' ? '输入分钟数' : '';
                    }
                    if (rewardsLabel) rewardsLabel.textContent = '习惯戒除奖励 (可添加多个)';
                    // 隐藏不必要的设置 (每日上限)
                    if (dailyLimitGroup) dailyLimitGroup.classList.add('hidden');
                } else {
                    // === 养成模式 ===
                    if (toggleTitle) toggleTitle.textContent = '设置为习惯';
                    if (toggleDesc) toggleDesc.textContent = '开启连续打卡和额外奖励';
                    if (settingsTitle) settingsTitle.textContent = '习惯设置';
                    if (targetLabel) targetLabel.textContent = '周期目标次数 *';
                    if (rewardsLabel) rewardsLabel.textContent = '习惯奖励 (可添加多个)';
                    if (targetCountInput) targetCountInput.placeholder = '';
                    // 恢复显示
                    if (dailyLimitGroup) dailyLimitGroup.classList.remove('hidden');
                }
            } else { 
                habitToggle.classList.add('hidden'); 
                document.getElementById('isHabitToggle').checked = false; 
                toggleHabitSettings(false); 
            } 
            
            // 4. 显示特定类型的时间输入框
            switch (taskType) { 
                case 'reward': 
                    document.getElementById('fixedTimeGroup').classList.remove('hidden'); 
                    break; 
                case 'continuous': 
                    document.getElementById('multiplierGroup').classList.remove('hidden'); 
                    break; 
                case 'continuous_target': 
                    ['multiplierGroup', 'targetTimeGroup', 'bonusRewardGroup'].forEach(id => document.getElementById(id).classList.remove('hidden')); 
                    break; 
                case 'instant_redeem': 
                    document.getElementById('consumeTimeGroup').classList.remove('hidden'); 
                    break; 
                case 'continuous_redeem': 
                    document.getElementById('multiplierGroup').classList.remove('hidden'); 
                    break; 
            } 
            
            // 5. 动态修改时间倍率标签
            const multiplierLabel = document.querySelector('#multiplierGroup .form-label');
            if (multiplierLabel) {
                if (taskType === 'continuous_redeem') {
                    multiplierLabel.textContent = '消耗倍率 *';
                } else {
                    multiplierLabel.textContent = '获得倍率 *';
                }
            }
            
            updateCategoryRecommendations(taskType); 
        }
        function toggleHabitSettings(forceState) { 
            const isHabit = typeof forceState === 'boolean' ? forceState : document.getElementById('isHabitToggle').checked; 
            document.getElementById('habitSettingsGroup').classList.toggle('hidden', !isHabit); 
            document.getElementById('habitSettingsGroup').style.marginBottom = isHabit ? '24px' : '0';
            const fixedTimeLabel = document.getElementById('fixedTimeLabel'); 
            if(fixedTimeLabel) fixedTimeLabel.textContent = isHabit ? '基础奖励 (分) *' : '奖励时间 (分) *'; 
            toggleRecurringReminderVisibility(); 
        }
        function toggleReminderSettings(forceState) { 
            const isReminder = typeof forceState === 'boolean' ? forceState : document.getElementById('isReminderToggle').checked; 
            document.getElementById('reminderSettingsGroup').classList.toggle('hidden', !isReminder); 
            toggleRecurringReminderVisibility(); 
        }
        function toggleRecurringReminderVisibility() {
            const container = document.getElementById('recurringReminderToggleContainer');
            const isHabit = document.getElementById('isHabitToggle').checked;
            const isReminder = document.getElementById('isReminderToggle').checked;
            const isAbsoluteMode = document.querySelector('#reminderModeSwitch .active').dataset.mode === 'absolute';
            
            const show = isHabit && isReminder && isAbsoluteMode;
            container.classList.toggle('hidden', !show);
            if (!show) {
                document.getElementById('isRecurringReminderToggle').checked = false;
            }
        }
        
        // [v6.4.0] 任务类型弹窗控制函数
        function showTaskTypeModal() {
            const currentValue = document.getElementById('taskType').value;
            // 更新选中状态
            document.querySelectorAll('#taskTypeModal .task-type-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === currentValue);
            });
            document.getElementById('taskTypeModal').classList.add('show');
        }

        // [v6.5.0] 习惯周期滑块切换（替代下拉框）
        function selectHabitPeriod(periodValue) {
            const periodInput = document.getElementById('habitPeriod');
            if (periodInput) periodInput.value = periodValue;
            document.querySelectorAll('.habit-period-switch button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.period === periodValue);
            });
        }
        
        function hideTaskTypeModal() {
            document.getElementById('taskTypeModal').classList.remove('show');
        }
        
        function selectTaskType(optionEl) {
            const value = optionEl.dataset.value;
            const nameEl = optionEl.querySelector('.task-type-option-name');
            const name = nameEl ? nameEl.textContent : value;
            
            // 更新隐藏字段和触发器
            document.getElementById('taskType').value = value;
            document.getElementById('taskTypeTrigger').textContent = name;
            
            // 更新选中状态
            document.querySelectorAll('#taskTypeModal .task-type-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            optionEl.classList.add('selected');
            
            // 关闭弹窗
            hideTaskTypeModal();
            
            // 触发表单更新
            updateFormForTaskType();
        }
        
        // [v5.2.1] 开启关联应用时申请使用情况访问权限
        async function toggleAppLauncherSettings(forceState) {
            const toggle = document.getElementById('isAppLauncherToggle');
            const isOn = typeof forceState === 'boolean' ? forceState : toggle.checked;
            const group = document.getElementById('appLauncherSettingsGroup');
            
            // 仅在用户手动开启时检查权限（forceState 为布尔值时是程序调用，跳过权限检查）
            if (isOn && typeof forceState !== 'boolean') {
                // 检查权限
                if (typeof Android !== 'undefined' && Android.hasUsageStatsPermission) {
                    if (!Android.hasUsageStatsPermission()) {
                        // 显示权限引导
                        const confirmed = await showConfirm(
                            '关联应用功能需要"使用情况访问权限"来检测应用使用状态。\n\n' +
                            '点击"确定"后，请在列表中找到"时间银行"并开启权限，然后返回应用。',
                            '需要权限'
                        );
                        
                        if (confirmed) {
                            Android.openUsageAccessSettings();
                        }
                        toggle.checked = false;
                        return;
                    }
                }
            }
            
            if (group) group.classList.toggle('hidden', !isOn);
        }
        
        // [v5.3.0] 开启自动检测补录时，自动开启屏幕时间管理
        // [v5.5.2] 增强权限检查，无论屏幕时间管理是否开启都要检查权限
        async function toggleAutoDetect() {
            const toggle = document.getElementById('isAutoDetectToggle');
            if (toggle.checked) {
                // [v5.5.2] 首先检查权限（无论屏幕时间管理是否开启）
                if (typeof Android !== 'undefined' && Android.hasUsageStatsPermission) {
                    if (!Android.hasUsageStatsPermission()) {
                        // 未授权：显示引导并跳转授权页面
                        const confirmed = await showConfirm(
                            '自动检测补录功能需要"使用情况访问权限"来检测应用使用时长。\n\n' +
                            '点击"确定"后，请在列表中找到"时间银行"并开启权限，然后返回应用。',
                            '需要权限'
                        );
                        
                        if (confirmed && typeof Android !== 'undefined' && Android.openUsageAccessSettings) {
                            Android.openUsageAccessSettings();
                        }
                        toggle.checked = false;
                        return;
                    }
                }
                
                // 检查屏幕时间管理是否已开启
                if (!screenTimeSettings.enabled) {
                    const confirmed = await showConfirm(
                        '自动检测补录功能需要开启"屏幕时间管理"。\n\n是否立即开启？',
                        '需要开启屏幕时间管理'
                    );
                    
                    if (confirmed) {
                        // 开启屏幕时间管理
                        screenTimeSettings.enabled = true;
                        if (!screenTimeSettings.enabledDate) {
                            screenTimeSettings.enabledDate = getLocalDateString(new Date());
                        }
                        if (!screenTimeSettings.settledDates) {
                            screenTimeSettings.settledDates = [];
                        }
                        saveScreenTimeSettings();
                        updateScreenTimeCardVisibility();
                        // 更新设置页面的开关状态（如果存在）
                        const screenTimeToggle = document.getElementById('screenTimeToggle');
                        if (screenTimeToggle) {
                            screenTimeToggle.checked = true;
                            document.getElementById('screenTimeSettings').classList.remove('hidden');
                            document.getElementById('screenTimeStatus').textContent = '已启用';
                        }
                        showToast('已开启屏幕时间管理');
                    } else {
                        toggle.checked = false;
                    }
                }
            }
        }
        
        function switchReminderMode(mode) { 
            document.getElementById('reminderAbsoluteMode').classList.toggle('hidden', mode !== 'absolute'); 
            document.getElementById('reminderRelativeMode').classList.toggle('hidden', mode !== 'relative'); 
            document.querySelectorAll('#reminderModeSwitch button').forEach(btn => { btn.classList.toggle('active', btn.dataset.mode === mode); }); 
            toggleRecurringReminderVisibility(); 
        }
        // [v6.4.0] 自定义下拉菜单控制函数
        function toggleDropdown(dropdownId) {
            const dropdown = document.getElementById(dropdownId);
            const isShowing = dropdown.classList.contains('show');
            // 先关闭所有其他下拉菜单
            document.querySelectorAll('.dropdown-menu.show').forEach(d => d.classList.remove('show'));
            // 切换当前下拉菜单
            if (!isShowing) {
                dropdown.classList.add('show');
            }
        }
        
        function selectDropdownItem(item, hiddenInputId, triggerId, dropdownId) {
            const value = item.dataset.value;
            const text = item.textContent;
            // 更新隐藏字段
            document.getElementById(hiddenInputId).value = value;
            // 更新触发器显示文本
            document.getElementById(triggerId).textContent = text;
            // 更新选中状态
            item.closest('.dropdown-menu').querySelectorAll('.dropdown-menu-item').forEach(i => i.classList.remove('selected'));
            item.classList.add('selected');
            // 关闭下拉菜单
            document.getElementById(dropdownId).classList.remove('show');
        }
        
        // 点击外部关闭下拉菜单
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.custom-select-wrapper')) {
                document.querySelectorAll('.dropdown-menu.show').forEach(d => d.classList.remove('show'));
            }
        });
        
        // [v4.8.2] 重写：单位改为"分"，支持递增上限设定
        function addHabitRewardRule(rule = null) {
            const container = document.getElementById('habitRewardsContainer');
            const card = document.createElement('div');
            card.className = 'habit-reward-card';
            
            // [v6.4.0] 确保 type 始终有有效值
            const type = (rule && rule.type && (rule.type === 'fixed' || rule.type === 'incremental')) ? rule.type : 'fixed';
            const start = rule ? rule.start : 1;
            // [v4.8.2] 数据转换：如果是旧数据(秒)，显示时转为分。这里假设传入的rule.value已经是秒，需转分。
            // 新建时 rule 为 null，value 为 ''。
            let displayValue = '';
            if (rule && rule.value) displayValue = parseFloat((rule.value / 60).toFixed(2));
            
            // 上限处理
            const limit = (rule && rule.limit) ? parseFloat((rule.limit / 60).toFixed(2)) : '';
            const hasLimit = !!limit;
            
            card.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <label class="form-label-small">奖励模式</label>
                    <div class="mode-switch reward-type-switch" style="margin-top: 4px;">
                        <button type="button" class="${type === 'fixed' ? 'active' : ''}" data-value="fixed" onclick="switchRewardType(this)">固定奖励</button>
                        <button type="button" class="${type === 'incremental' ? 'active' : ''}" data-value="incremental" onclick="switchRewardType(this)">递增奖励</button>
                    </div>
                    <input type="hidden" class="reward-type" value="${type}">
                </div>
                <div class="reward-grid-row">
                    <div>
                        <label class="form-label-small">🚪 生效门槛</label>
                        <div class="input-with-suffix">
                            <input type="number" class="form-input reward-start" value="${start}" min="1" oninput="updateRewardCardDesc(this)">
                            <span class="input-suffix-text">期</span>
                        </div>
                    </div>
                    <div>
                        <label class="form-label-small">⭐ 奖励时长</label>
                        <div class="input-with-suffix">
                            <input type="number" class="form-input reward-value" placeholder="0" value="${displayValue}" oninput="updateRewardCardDesc(this)">
                            <span class="input-suffix-text">分</span>
                        </div>
                    </div>
                </div>
                <div class="reward-limit-container ${type === 'fixed' ? 'hidden' : ''}" style="margin-top: 8px; background: rgba(0,0,0,0.03); padding: 8px; border-radius: 4px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                        <label class="form-label-small" style="margin:0;">📈 设定递增上限</label>
                        <label class="switch" style="transform: scale(0.8);">
                            <input type="checkbox" class="reward-limit-toggle" ${hasLimit ? 'checked' : ''} onchange="toggleRewardLimitInput(this)">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="limit-input-wrapper ${hasLimit ? '' : 'hidden'}">
                        <div class="input-with-suffix">
                            <input type="number" class="form-input reward-limit-value" placeholder="封顶时长" value="${limit}">
                            <span class="input-suffix-text">分</span>
                        </div>
                    </div>
                </div>
                <div class="reward-card-footer">
                    <span class="reward-desc-text"></span>
                    <button type="button" class="btn-text-danger" onclick="this.closest('.habit-reward-card').remove()">
                        删除
                    </button>
                </div>
            `;
            
            container.appendChild(card);
            
            // 初始化描述文本
            updateRewardCardDesc(card.querySelector('.reward-type'));
        }
        
        // [v6.4.0] 奖励模式滑块切换
        function switchRewardType(btn) {
            const card = btn.closest('.habit-reward-card');
            const switchContainer = btn.closest('.reward-type-switch');
            const hiddenInput = card.querySelector('input.reward-type');
            const value = btn.dataset.value;
            
            // 更新按钮状态
            switchContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // 更新隐藏字段值
            hiddenInput.value = value;
            
            // 控制上限容器显示
            const limitContainer = card.querySelector('.reward-limit-container');
            if (value === 'incremental') {
                limitContainer.classList.remove('hidden');
            } else {
                limitContainer.classList.add('hidden');
            }
            
            // 更新描述
            updateRewardCardDesc(hiddenInput);
        }
        
        // [v4.8.2] 新增辅助函数：控制上限输入框显示（兼容旧调用）
        function toggleRewardLimit(element) {
            const card = element.closest('.habit-reward-card');
            const limitContainer = card.querySelector('.reward-limit-container');
            const type = card.querySelector('.reward-type').value;
            if (type === 'incremental') {
                limitContainer.classList.remove('hidden');
            } else {
                limitContainer.classList.add('hidden');
            }
            updateRewardCardDesc(element);
        }
        
        function toggleRewardLimitInput(checkbox) {
            const wrapper = checkbox.closest('.reward-limit-container').querySelector('.limit-input-wrapper');
            if (checkbox.checked) wrapper.classList.remove('hidden');
            else wrapper.classList.add('hidden');
        }
        
        // [v4.8.2] 重写：单位改为"分"
        function updateRewardCardDesc(element) {
            const card = element.closest('.habit-reward-card');
            if (!card) return;
            const type = card.querySelector('.reward-type').value;
            const start = card.querySelector('.reward-start').value || 'N';
            const value = card.querySelector('.reward-value').value || 'X';
            const descEl = card.querySelector('.reward-desc-text');
            
            if (type === 'fixed') {
                descEl.textContent = `第 ${start} 期起获得 ${value} 分`;
            } else {
                descEl.textContent = `第 ${start} 期起获得 期数 × ${value} 分`;
            }
        }
        function setTimePreset(fieldId, seconds) { document.getElementById(fieldId).value = seconds; }
        function setMultiplierPreset(value) { document.getElementById('multiplier').value = value; }
        
        // [v3.18.0] Updated saveTask to include targetCountInPeriod
        async function saveTask(event) {
            event.preventDefault();
            clearFormErrors();
            let shouldRemindFloatingPermission = false;
            
            const formData = {
                name: document.getElementById('taskName').value.trim(),
                category: document.getElementById('taskCategory').value.trim(),
                type: document.getElementById('taskType').value,
                isHabit: document.getElementById('isHabitToggle').checked,
                enableFloatingTimer: document.getElementById('isFloatingTimerToggle').checked,
            };

            const enableAppLaunch = document.getElementById('isAppLauncherToggle')?.checked || false;
            const appInputRaw = (document.getElementById('taskAppPackage')?.value || '').trim();
            if (enableAppLaunch && appInputRaw) {
                // [v5.2.0] 使用新的 resolveAppPackage 支持动态应用列表
                formData.appPackage = resolveAppPackage(appInputRaw);
                // [v5.3.0] 自动检测补录开关
                formData.autoDetect = document.getElementById('isAutoDetectToggle')?.checked || false;
            } else {
                formData.appPackage = null;
                formData.autoDetect = false;
            }

            let hasError = !formData.name || !formData.category || !formData.type;
            if (!formData.name) showFieldError('taskName', '请输入任务名称');
            if (!formData.category) showFieldError('taskCategory', '请输入任务分类');
            if (!formData.type) showFieldError('taskType', '请选择任务类型');
            
            // [v4.8.2] parseAndValidate允许浮点数，用于分钟单位
            const parseAndValidate = (id, fieldName, isFloat = false) => { const input = document.getElementById(id); const value = isFloat ? parseFloat(input.value) : parseInt(input.value); if (isNaN(value) || value <= 0) { showFieldError(id, `请输入有效的${fieldName}`); hasError = true; } return value; };
            const parseAndValidateOptional = (id, fieldName, isFloat = false) => { const input = document.getElementById(id); if (!input.value) return 0; const value = isFloat ? parseFloat(input.value) : parseInt(input.value); if (isNaN(value) || value < 0) { showFieldError(id, `请输入有效的${fieldName}`); hasError = true; } return value; }
            const getMultiplierOrDefault = () => { const input = document.getElementById('multiplier'); if (!input) return 1; const value = parseFloat(input.value); if (isNaN(value) || value <= 0) { return 1; } return value; };
            
            // [v4.8.2] 保存时将分钟乘以60转换为秒
            switch (formData.type) { case 'reward': formData.fixedTime = Math.round(parseAndValidate('fixedTime', '奖励时间', true) * 60); break; case 'instant_redeem': formData.consumeTime = Math.round(parseAndValidate('consumeTime', '消费时间', true) * 60); break; case 'continuous': case 'continuous_redeem': formData.multiplier = getMultiplierOrDefault(); break; case 'continuous_target': formData.multiplier = getMultiplierOrDefault(); formData.targetTime = Math.round(parseAndValidate('targetTime', '目标时长', true) * 60); formData.bonusReward = Math.round(parseAndValidateOptional('bonusReward', '额外奖励', true) * 60); break; }
            
            if (formData.isHabit) {
                // [v3.18.0] New field: targetCountInPeriod
                const targetCountInPeriod = parseInt(document.getElementById('targetCountInPeriod').value);
                const dailyLimit = parseInt(document.getElementById('habitDailyLimit').value);
                
                // [v3.18.0] Validation
                if (isNaN(targetCountInPeriod) || targetCountInPeriod < 1) {
                    // [v4.0.2] Fix: Use correct ID for error
                    showFieldError('targetCountInPeriod', '周期目标次数必须大于等于1');
                    hasError = true;
                }
                
                formData.habitDetails = { 
                    period: document.getElementById('habitPeriod').value, 
                    // [v3.18.0] Save new field
                    targetCountInPeriod: isNaN(targetCountInPeriod) || targetCountInPeriod < 1 ? 1 : targetCountInPeriod,
                    dailyLimit: isNaN(dailyLimit) || dailyLimit < 1 ? 1 : dailyLimit, 
                    // [v4.9.0] Mark habit type: 'positive' for earning tasks, 'abstinence' for spending tasks
                    type: ['instant_redeem', 'continuous_redeem'].includes(formData.type) ? 'abstinence' : 'positive',
                    // [v4.9.0] Initialize lastSettledDate to prevent duplicate reward settlement
                    lastSettledDate: currentEditingTask?.habitDetails?.lastSettledDate || null,
                    rewards: [] 
                };
                // [v4.8.2] 习惯奖励：将分钟乘以60转换为秒，支持上限设定
                document.querySelectorAll('.habit-reward-card').forEach(ruleEl => { 
                    const type = ruleEl.querySelector('.reward-type').value; 
                    const start = parseInt(ruleEl.querySelector('.reward-start').value); 
                    const valueInMinutes = parseFloat(ruleEl.querySelector('.reward-value').value); 
                    const value = Math.round(valueInMinutes * 60); 
                    
                    // 处理上限
                    let limit = null;
                    if (type === 'incremental') {
                        const limitToggle = ruleEl.querySelector('.reward-limit-toggle');
                        if (limitToggle && limitToggle.checked) {
                            const limitInput = ruleEl.querySelector('.reward-limit-value');
                            if (limitInput && limitInput.value) {
                                limit = Math.round(parseFloat(limitInput.value) * 60);
                            }
                        }
                    }
                    
                    if (!isNaN(start) && start > 0 && !isNaN(value) && value > 0) { 
                        const rule = { type, start, value };
                        if (limit !== null) rule.limit = limit;
                        formData.habitDetails.rewards.push(rule); 
                    } else { 
                        showAlert('习惯奖励规则填写不完整或无效'); 
                        hasError = true; 
                    } 
                });
            }

            if (document.getElementById('isReminderToggle').checked) {
                const mode = document.querySelector('#reminderModeSwitch .active').dataset.mode;
                let timeValue;
                let isRecurring = false; 
                
                if (mode === 'absolute') {
                    timeValue = document.getElementById('reminderDateTime').value;
                    if (!timeValue || new Date(timeValue) <= new Date()) {
                        showAlert('提醒时间必须是未来的一个时间点'); hasError = true;
                    }
                    isRecurring = document.getElementById('isRecurringReminderToggle').checked; 
                } else { // relative
                    const hours = parseInt(document.getElementById('reminderHours').value || '0');
                    const minutes = parseInt(document.getElementById('reminderMinutes').value || '0');
                    timeValue = (hours * 3600) + (minutes * 60);
                    if (timeValue <= 0) {
                        showAlert('倒计时时长必须大于0'); hasError = true;
                    }
                }
                if (!hasError) {
                    formData.reminderDetails = {
                        mode: mode,
                        time: mode === 'absolute' ? timeValue : timeValue,
                        isRecurring: isRecurring, 
                        creationTimestamp: mode === 'relative' ? Date.now() : null,
                        status: 'pending'
                    };
                }
            } else {
                formData.reminderDetails = null;
            }

            if (hasError) return;
            
            // [v6.4.5] 检测是否首次启用戒除习惯，显示奖励显示模式选择弹窗
            const isNewAbstinenceHabit = formData.isHabit && 
                formData.habitDetails?.type === 'abstinence' &&
                formData.habitDetails?.rewards?.length > 0 &&
                !notificationSettings.abstinenceRewardModePrompted;
            
            // 检查是否是编辑现有任务且之前已经是戒除习惯
            const wasAlreadyAbstinence = currentEditingTask?.isHabit && 
                currentEditingTask?.habitDetails?.type === 'abstinence' &&
                currentEditingTask?.habitDetails?.rewards?.length > 0;
            
            if (isNewAbstinenceHabit && !wasAlreadyAbstinence) {
                // 首次启用戒除习惯且有奖励设置，显示模式选择弹窗
                await showAbstinenceRewardModeDialog();
            }
            
            let colorToSet = currentSelectedColor; if (currentEditingTask) { const oldCategory = currentEditingTask.category; if (oldCategory !== formData.category) { if (categoryColors.has(formData.category)) { colorToSet = categoryColors.get(formData.category); } else if (!colorToSet) { colorToSet = getRandomAvailableColor(formData.type); } const oldCategoryInUse = tasks.some(t => t.id !== currentEditingTask.id && t.category === oldCategory); if (!oldCategoryInUse) categoryColors.delete(oldCategory); } } else { if (categoryColors.has(formData.category)) { colorToSet = categoryColors.get(formData.category); } else if (!colorToSet) { colorToSet = getRandomAvailableColor(formData.type); } }
            categoryColors.set(formData.category, colorToSet); 
            
            if (currentEditingTask) { 
                // 保存旧名称以便在需要时更新历史记录
                const _oldTaskName = currentEditingTask.name;
                const renameChanged = formData.name && formData.name !== _oldTaskName;

                if (renameChanged) {
                    const doMerge = await showConfirm('检测到任务名称变更。点击【确定】将同步修改所有历史记录；点击【取消】将放弃保存并返回。', '任务名称变更');
                    if (!doMerge) {
                        // 取消：不保存，保持在编辑界面
                        return;
                    }
                }

                if (currentEditingTask.isHabit && !formData.isHabit) delete currentEditingTask.habitDetails; 
                else if (!currentEditingTask.isHabit && formData.isHabit) { 
                    formData.habitDetails.streak = 0; 
                    formData.habitDetails.lastCompletionDate = null; 
                    formData.habitDetails.isBroken = false; // [v4.0.3] Init property
                } 
                else if (currentEditingTask.isHabit && formData.isHabit) { 
                    formData.habitDetails.streak = currentEditingTask.habitDetails.streak; 
                    formData.habitDetails.lastCompletionDate = currentEditingTask.habitDetails.lastCompletionDate; 
                    formData.habitDetails.isBroken = currentEditingTask.habitDetails.isBroken || false; // [v4.0.3] Preserve property
                } 
                
                // [v5.9.0] Phase 4: 记录变更前后的差异
                const changes = {};
                Object.keys(formData).forEach(key => {
                    if (JSON.stringify(currentEditingTask[key]) !== JSON.stringify(formData[key])) {
                        changes[key] = { from: currentEditingTask[key], to: formData[key] };
                    }
                });
                
                Object.assign(currentEditingTask, formData); 

                // 如果任务名称发生变化且已确认，遍历历史记录同步名称
                if (renameChanged) {
                    try {
                        transactions.forEach(tx => {
                            if (tx.taskId === currentEditingTask.id) {
                                tx.taskName = formData.name;
                                if (tx.description && typeof tx.description === 'string') {
                                    tx.description = tx.description.split(_oldTaskName).join(formData.name);
                                }
                            }
                        });
                    } catch (e) {
                        console.error('Rename merge failed', e);
                    }
                }
                
                // [v5.9.0] Phase 4: 记录任务更新事件
                if (USE_EVENT_SOURCING) {
                    await dispatchEvent(EVENT_TYPES.TASK_UPDATED, {
                        taskId: currentEditingTask.id,
                        taskName: currentEditingTask.name,
                        changes: changes,
                        renamed: renameChanged ? { from: _oldTaskName, to: formData.name } : null
                    }, { skipSnapshot: true }); // 后面统一保存
                } else {
                    // 旁听记录
                    logEvent(EVENT_TYPES.TASK_UPDATED, {
                        taskId: currentEditingTask.id,
                        taskName: currentEditingTask.name,
                        changes: changes,
                        renamed: renameChanged ? { from: _oldTaskName, to: formData.name } : null
                    });
                }
            } else { 
                const newTask = { id: generateId(), ...formData, completionCount: 0, lastUsed: 0 }; 
                if (newTask.isHabit) { 
                    newTask.habitDetails.streak = 0; 
                    newTask.habitDetails.lastCompletionDate = null; 
                    newTask.habitDetails.isBroken = false; // [v4.0.3] Init property
                } 
                
                // [v5.9.0] Phase 4: 事件驱动创建任务
                if (USE_EVENT_SOURCING) {
                    const result = await dispatchEvent(EVENT_TYPES.TASK_CREATED, {
                        taskId: newTask.id,
                        task: newTask
                    }, { skipSnapshot: true }); // 后面统一保存
                    
                    if (!result.success) {
                        // Fallback: 传统方式
                        console.warn('[ES] Task create fallback to legacy mode');
                        tasks.push(newTask);
                    }
                } else {
                    // 传统模式
                    tasks.push(newTask);
                    
                    // [v5.8.1] 旁听记录任务创建事件
                    logEvent(EVENT_TYPES.TASK_CREATED, {
                        taskId: newTask.id,
                        task: newTask
                    });
                }
                
                if (newTask.enableFloatingTimer && notificationSettings.floatingTimer !== false && !notificationSettings.floatingTimerPermissionPrompted && window.Android && window.Android.startFloatingTimer) {
                    notificationSettings.floatingTimerPermissionPrompted = true;
                    shouldRemindFloatingPermission = true;
                }
                maybeCleanupDemoDataOnFirstUse();
            }
            saveData(); updateAllUI(); hideTaskModal(); 
            if (shouldRemindFloatingPermission) {
                showAlert('首次使用悬浮窗计时器需要系统悬浮窗权限，请在系统设置中为本应用开启悬浮窗/画中画权限后再试。');
            }
        }
        
        // [v4.8.5 Fix] 全周期戒除习惯结算核心函数 (修复奖励发放逻辑)
        function checkAbstinenceHabits() {
            const now = new Date();
            let hasUpdates = false; // 标记是否有数据变更

            // 根据周期计算窗口
            const getPeriodWindow = (endDate, period) => {
                let startTime, endTime;
                if (period === 'daily') {
                    const start = new Date(endDate); start.setHours(0, 0, 0, 0);
                    const end = new Date(endDate); end.setHours(23, 59, 59, 999);
                    startTime = start.getTime(); endTime = end.getTime();
                } else if (period === 'weekly') {
                    const end = new Date(endDate); end.setHours(23, 59, 59, 999);
                    const start = new Date(end);
                    start.setDate(end.getDate() - 6);
                    start.setHours(0, 0, 0, 0);
                    startTime = start.getTime(); endTime = end.getTime();
                } else if (period === 'monthly') {
                    const end = new Date(endDate); end.setHours(23, 59, 59, 999);
                    const start = new Date(end.getFullYear(), end.getMonth(), 1);
                    start.setHours(0, 0, 0, 0);
                    startTime = start.getTime(); endTime = end.getTime();
                }
                return { startTime, endTime };
            };

            const getPreviousPeriodEnd = (baseDate, period) => {
                if (period === 'daily') {
                    const yest = new Date(baseDate);
                    yest.setDate(yest.getDate() - 1);
                    return yest;
                } else if (period === 'weekly') {
                    const day = baseDate.getDay();
                    const diffToLastSun = day === 0 ? 7 : day;
                    const lastSun = new Date(baseDate);
                    lastSun.setDate(baseDate.getDate() - diffToLastSun);
                    lastSun.setHours(23, 59, 59, 999);
                    return lastSun;
                } else if (period === 'monthly') {
                    const firstOfThis = new Date(baseDate.getFullYear(), baseDate.getMonth(), 1);
                    return new Date(firstOfThis.getTime() - 1); // 上个月最后一天
                }
                return null;
            };

            const stepToNextPeriodEnd = (endDate, period) => {
                const next = new Date(endDate);
                if (period === 'daily') {
                    next.setDate(next.getDate() + 1);
                } else if (period === 'weekly') {
                    next.setDate(next.getDate() + 7);
                } else if (period === 'monthly') {
                    next.setMonth(next.getMonth() + 1);
                    next.setDate(0); // 设为下个月的第 0 天即本月最后一天
                }
                return next;
            };

            tasks.forEach(task => {
                // 1. 筛选戒除类习惯
                if (!task.isHabit || !task.habitDetails || task.habitDetails.type !== 'abstinence') return;
                const period = task.habitDetails.period;

                // 2. 计算最新可结算周期的结束日（昨天/上周末/上月末）
                const latestEndDate = getPreviousPeriodEnd(now, period);
                if (!latestEndDate) return;
                const latestKey = getLocalDateString(latestEndDate);

                // 首次初始化：只记录结算点，避免错误补发
                if (!task.habitDetails.lastSettledDate) {
                    task.habitDetails.lastSettledDate = latestKey;
                    hasUpdates = true;
                    return;
                }
                // 已经结算到最新周期则跳过
                if (task.habitDetails.lastSettledDate === latestKey) return;

                // 从上次结算之后的下一个周期开始逐个补算，避免漏开 App 导致连胜丢失
                let cursorEndDate = stepToNextPeriodEnd(new Date(task.habitDetails.lastSettledDate), period);
                while (cursorEndDate.getTime() <= latestEndDate.getTime()) {
                    const settlementKey = getLocalDateString(cursorEndDate);
                    const { startTime, endTime } = getPeriodWindow(cursorEndDate, period);

                    // 4. 统计该时间段内的消费
                    const records = transactions.filter(t =>
                        t.taskId === task.id &&
                        (t.type === 'spend' || (!t.type && t.amount < 0)) &&
                        new Date(t.timestamp).getTime() >= startTime &&
                        new Date(t.timestamp).getTime() <= endTime
                    );

                    let totalConsumed = 0;
                    // 消费类习惯：targetCountInPeriod 代表"允许的额度"
                    // instant_redeem 按次数算，continuous_redeem 按时长算
                    if (task.type === 'instant_redeem') {
                        totalConsumed = records.length;
                    } else {
                        // [v6.4.1] 使用 rawSeconds 计算实际使用时间，而不是被倍率和惩罚影响过的 amount
                        // 如果交易有 rawSeconds 字段则使用，否则回退到从 description 解析
                        totalConsumed = records.reduce((sum, t) => {
                            if (typeof t.rawSeconds === 'number') {
                                return sum + t.rawSeconds;
                            }
                            // 回退：对于没有 rawSeconds 的旧记录，从 description 解析实际时长
                            // 格式: "连续消费: 任务名 (1小时5分 × 1.5)" 或 "(35分5秒 × 1)"
                            if (t.description) {
                                // 匹配括号内的时间部分，格式如 "35分5秒" 或 "1小时5分" 或 "1小时35分5秒"
                                const timeMatch = t.description.match(/\((\d+小时)?(\d+分)?(\d+秒)?\s*×/);
                                if (timeMatch) {
                                    let seconds = 0;
                                    if (timeMatch[1]) seconds += parseInt(timeMatch[1]) * 3600;
                                    if (timeMatch[2]) seconds += parseInt(timeMatch[2]) * 60;
                                    if (timeMatch[3]) seconds += parseInt(timeMatch[3]);
                                    if (seconds > 0) return sum + seconds;
                                }
                            }
                            // 最终回退：使用原始 amount（已乘倍率，不准确但比跳过好）
                            return sum + Math.abs(t.amount);
                        }, 0);
                        if (task.type === 'continuous_redeem') {
                            totalConsumed = Math.floor(totalConsumed / 60); // 转换为分钟
                        }
                    }

                    // 5. 判定结果
                    const limit = task.habitDetails.targetCountInPeriod || 0;

                    if (totalConsumed <= limit) {
                        // === 成功逻辑 (独立实现) ===
                        task.habitDetails.streak = (task.habitDetails.streak || 0) + 1;
                        task.habitDetails.isBroken = false;

                        // 计算奖励（严格按照 streak 值，避免连胜丢失时奖励被跳过）
                        const streakNow = task.habitDetails.streak;
                        const rewards = Array.isArray(task.habitDetails.rewards) ? task.habitDetails.rewards : [];
                        const finalReward = rewards.reduce((sum, rule) => {
                            const start = Number(rule.start) || 0;
                            const value = Number(rule.value) || 0;
                            if (streakNow < start || value <= 0) return sum;
                            let ruleReward = rule.type === 'fixed' ? value : value * streakNow;
                            if (rule.limit !== undefined && rule.limit !== null) {
                                const cap = Number(rule.limit);
                                if (!Number.isNaN(cap) && ruleReward > cap) ruleReward = cap;
                            }
                            return sum + ruleReward;
                        }, 0);

                        // 发放奖励
                        if (finalReward > 0) {
                            currentBalance += finalReward;
                            const rewardDate = new Date();
                            updateDailyChanges('earned', finalReward, rewardDate);

                            addTransaction({
                                type: 'earn',
                                taskId: task.id,
                                taskName: task.name,
                                amount: finalReward,
                                description: `戒除挑战成功: ${task.name} (额度 ${totalConsumed}/${limit})`,
                                isStreakAdvancement: true,
                                timestamp: rewardDate.toISOString()
                            });

                            showNotification('🛡️ 戒除挑战成功', `${task.name} 保持在额度内！获得 ${formatTime(finalReward)}`, 'achievement');
                        } else {
                            // 连胜成功但没有奖励规则，记一笔 0 额度供记录
                            addTransaction({
                                type: 'earn',
                                taskId: task.id,
                                taskName: task.name,
                                amount: 0,
                                description: `戒除挑战成功: ${task.name} (额度 ${totalConsumed}/${limit})`,
                                isStreakAdvancement: true,
                                timestamp: new Date().toISOString()
                            });
                        }
                    } else {
                        // === 失败逻辑 ===
                        task.habitDetails.streak = 0;
                        // 失败不发通知
                    }

                    // 6. 标记已结算当前周期并继续补算
                    task.habitDetails.lastSettledDate = settlementKey;
                    hasUpdates = true;

                    // 如已结算到最新周期则停止
                    if (settlementKey === latestKey) break;
                    cursorEndDate = stepToNextPeriodEnd(cursorEndDate, period);
                }
            });

            if (hasUpdates) {
                saveData();
                updateAllUI();
            }
        }
        
        function clearFormErrors() { document.querySelectorAll('.form-input.error, .form-select.error').forEach(el => el.classList.remove('error')); document.querySelectorAll('.error-message.show').forEach(el => el.classList.remove('show')); }
        
        // --- Task Actions ---
        function completeTask(taskId) {
            lastLocalActionTime = Date.now(); // [v4.8.0] 记录本地作業時間
            // [v4.6.0 核心修改] 获取任务对象
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex === -1) return;
            const task = tasks[taskIndex];
            // 2. [v4.6.0 修复] 停止悬浮窗 (必须传入 task.name)
            // [v4.8.2] 仅当任务正在运行时才停止悬浮窗，防止非持续性任务闪现悬浮窗
            if (runningTasks.has(taskId) && window.Android && window.Android.stopFloatingTimer) {
                try {
                    window.Android.stopFloatingTimer(task.name || "");
            } catch (e) {
                console.error("Float stop failed", e);
            }
        }   
            // 3. 原有的完成逻辑
            task.lastUsed = Date.now();
            if (task.isHabit) {
                const todayStr = getLocalDateString(new Date());
                const completionsToday = transactions.filter(t => t.taskId === taskId && getLocalDateString(t.timestamp) === todayStr).length;
                if (completionsToday >= (task.habitDetails.dailyLimit || 1)) {
                    showAlert('已达到此习惯的每日完成上限');
                    return;
                }
                // [v3.18.0] Pass task directly to handle complex habit logic
                // [v4.2.0] Pass referenceDate (today)
                processHabitCompletion(task, task.fixedTime, new Date());
            } else {
                processNormalCompletion(task);
            }
            // 4. 处理提醒状态
            if (task.reminderDetails && task.reminderDetails.status === 'pending' && !task.reminderDetails.isRecurring) {
                task.reminderDetails.status = 'triggered'; 
            }
            saveData();
            updateAllUI();
        }

        function processNormalCompletion(task, earnedTime = task.fixedTime, descriptionDetails = '', referenceDate = new Date(), pauseHistory = []) { // [v5.8.0] 添加 pauseHistory 参数
            const isBackdate = descriptionDetails.includes('补录');
            const transaction = {
                id: generateId(),
                type: 'earn',
                taskId: task.id,
                taskName: task.name,
                amount: earnedTime,
                description: `完成任务: ${task.name}${descriptionDetails}`,
                timestamp: referenceDate.toISOString(),
                pauseHistory: pauseHistory
            };
            
            // [v5.9.0] Phase 4: 事件驱动模式
            if (USE_EVENT_SOURCING) {
                // 事件驱动：通过 dispatchEvent 处理
                dispatchEvent(EVENT_TYPES.TASK_COMPLETED, {
                    taskId: task.id,
                    taskName: task.name,
                    transaction: transaction,
                    isHabit: false,
                    isBackdate: isBackdate
                }, { skipSnapshot: true }); // 调用方会统一保存
                
                // 手动更新本地状态（因为 dispatchEvent 是异步的）
                currentBalance += earnedTime;
                task.completionCount = (task.completionCount || 0) + 1;
                transactions.push(transaction);
                updateDailyChanges('earned', earnedTime, referenceDate);
            } else {
                // 传统模式
                currentBalance += earnedTime; 
                task.completionCount = (task.completionCount || 0) + 1; 
                addTransaction(transaction);
                updateDailyChanges('earned', earnedTime, referenceDate); 
                
                // [v5.8.1] 旁听记录任务完成事件
                logEvent(EVENT_TYPES.TASK_COMPLETED, {
                    taskId: task.id,
                    taskName: task.name,
                    transaction: transaction,
                    isHabit: false,
                    isBackdate: isBackdate
                });
            }
            
            // Only show notification if it's not a backdate
            if (getLocalDateString(referenceDate) === getLocalDateString(new Date())) {
                showNotification('🎉 任务完成', `获得 ${formatTime(earnedTime)} 时间奖励！`, 'achievement');
            }
        }
        
        // [v4.8.7 Fix] 获取习惯周期数据 (修复：计时戒除任务应统计时长而非次数)
        function getHabitPeriodInfo(task, transactionList, referenceDate = new Date()) {
            const period = task.habitDetails.period;
            const targetCount = task.habitDetails.targetCountInPeriod || 1; 
            
            const refDate = new Date(referenceDate);
            refDate.setHours(0, 0, 0, 0); 
            let periodStart, periodEnd;
            if (period === 'daily') {
                periodStart = refDate;
                periodEnd = new Date(refDate);
                periodEnd.setDate(periodEnd.getDate() + 1);
            } else if (period === 'weekly') {
                const day = refDate.getDay(); 
                const diff = day === 0 ? 6 : day - 1; 
                periodStart = new Date(refDate.getTime() - diff * 86400000); 
                periodEnd = new Date(periodStart.getTime() + 7 * 86400000); 
            } else if (period === 'monthly') {
                periodStart = new Date(refDate.getFullYear(), refDate.getMonth(), 1); 
                periodEnd = new Date(refDate.getFullYear(), refDate.getMonth() + 1, 1); 
            } else if (period === 'yearly') {
                periodStart = new Date(refDate.getFullYear(), 0, 1);
                periodEnd = new Date(refDate.getFullYear() + 1, 0, 1);
            } else {
                periodStart = refDate;
                periodEnd = new Date(refDate);
                periodEnd.setDate(periodEnd.getDate() + 1);
            }
        
        const isSpendTask = ['instant_redeem', 'continuous_redeem'].includes(task.type);
        const targetType = isSpendTask ? 'spend' : 'earn';
        // 筛选周期内的有效记录
        const transactionsInPeriod = transactionList.filter(t => {
            if (t.taskId !== task.id) return false;
            const txType = t.type || (t.amount > 0 ? 'earn' : 'spend');
            if (txType !== targetType) return false;
            const txDate = new Date(t.timestamp);
            return txDate >= periodStart && txDate < periodEnd;
        });
        
        let currentCount = 0;
        
        // [v4.8.7] 核心修复：根据任务类型决定统计方式
        // [v6.4.1] 使用 rawSeconds 显示实际使用时间，而不是倍率计算后的 amount
        if (task.type === 'continuous_redeem') {
            // 计时消费：累加实际使用时长（秒），并转换为分钟
            const totalSeconds = transactionsInPeriod.reduce((sum, t) => {
                // 优先使用 rawSeconds（实际使用秒数）
                if (typeof t.rawSeconds === 'number') {
                    return sum + t.rawSeconds;
                }
                // 回退：从 description 解析实际时长
                if (t.description) {
                    const timeMatch = t.description.match(/\((\d+小时)?(\d+分)?(\d+秒)?\s*×/);
                    if (timeMatch) {
                        let seconds = 0;
                        if (timeMatch[1]) seconds += parseInt(timeMatch[1]) * 3600;
                        if (timeMatch[2]) seconds += parseInt(timeMatch[2]) * 60;
                        if (timeMatch[3]) seconds += parseInt(timeMatch[3]);
                        if (seconds > 0) return sum + seconds;
                    }
                }
                // 最终回退：使用 amount（不准确）
                return sum + Math.abs(t.amount);
            }, 0);
            currentCount = Math.floor(totalSeconds / 60);
        } else {
            // 其他（按次消费、普通习惯）：统计次数
            currentCount = transactionsInPeriod.length;
        }
        
        return { periodStart, periodEnd, currentCount, targetCount };
    }
        
        // [v4.2.0] Updated processHabitCompletion to accept a referenceDate
        // [v4.3.0] No longer rebuilds streak. Only checks and advances.
        // [v5.8.0] 添加 pauseHistory 参数
        function processHabitCompletion(task, baseReward, referenceDate, descriptionDetails = '', pauseHistory = []) { 
            const refDateStr = getLocalDateString(referenceDate); 
            const isDaily = task.habitDetails.period === 'daily';

            // 1. Get current period count (X) and target (N) *relative to the referenceDate*
            // We pass ALL transactions so it can find the period correctly.
            const { currentCount, targetCount, periodStart, periodEnd } = getHabitPeriodInfo(task, transactions, referenceDate);
            const nextCount = currentCount + 1; // Count including this completion

            // Check if streak was already advanced in this *specific* period
            const alreadyAdvancedThisPeriod = transactions.some(t => {
                const txDate = new Date(t.timestamp);
                return t.taskId === task.id && t.isStreakAdvancement && txDate >= periodStart && txDate < periodEnd;
            });

            let finalReward = baseReward;
            let bonusDescription = '';
            let isAdvancement = false;
            let notificationTitle = '👍 习惯重复完成';
            let notificationBody = `获得基础奖励 ${formatTime(baseReward)}`;

            // 2. Logic Branching
            if (nextCount < targetCount) {
                // Case 1: Not reached target yet (X < N)
                notificationTitle = '💪 习惯积累中';
                notificationBody = `已完成 ${nextCount}/${targetCount} 次。继续努力！`;
            } else if (nextCount === targetCount && !alreadyAdvancedThisPeriod) {
                // Case 2: Just reached target (X = N) for the first time in this period
                isAdvancement = true; // Mark this transaction as the trigger

                // [v4.3.0] Check streak based on reference date, DO NOT rebuild
                checkHabitStreak(task, referenceDate);
                task.habitDetails.streak = (task.habitDetails.streak || 0) + 1; 
                task.habitDetails.isBroken = false; // [v4.0.3] Clear broken status on advancement
                
                // Calculate bonus reward based on the NEW streak
                let habitBonusReward = 0; 
                task.habitDetails.rewards.forEach(rule => { 
                    if (task.habitDetails.streak >= rule.start) {
                        let ruleReward = (rule.type === 'fixed') ? rule.value : (rule.value * task.habitDetails.streak);
                        // [v4.8.5] 修复：应用递增奖励上限
                        if (rule.limit && ruleReward > rule.limit) {
                            ruleReward = rule.limit;
                        }
                        habitBonusReward += ruleReward; 
                    }
                }); 
                
                finalReward += habitBonusReward; 
                if (habitBonusReward > 0) bonusDescription = ` (含习惯奖励 ${formatTime(habitBonusReward)})`; 
                
                const unitMap = { daily: '天', weekly: '周', monthly: '月' };
                const periodText = unitMap[task.habitDetails.period] || '次';
                notificationTitle = '⭐ 习惯已达标!';
                notificationBody = `连续${task.habitDetails.streak}${periodText}! 获得 ${formatTime(finalReward)} 时间`; 
            } else {
                // Case 3: Target exceeded (X > N) or (X = N and already advanced)
                // Only basic reward, no streak update.
                notificationTitle = '🎉 习惯超额完成';
                notificationBody = `已完成 ${nextCount}/${targetCount} 次 (已达标)。获得基础奖励 ${formatTime(baseReward)}`;
            }
// 3. Update Status and Transactions
            if (isAdvancement) {
                 // Only update the last completion date when an advancement occurs.
                task.habitDetails.lastCompletionDate = refDateStr;
            }
            task.completionCount = (task.completionCount || 0) + 1; // Always increment task total completion count
            currentBalance += finalReward; 
            updateDailyChanges('earned', finalReward, referenceDate);
            
            const isBackdate = descriptionDetails.includes('补录');
            const transaction = {
                id: generateId(),
                type: 'earn', 
                taskId: task.id, 
                taskName: task.name, 
                amount: finalReward, 
                description: `${isBackdate ? '' : '完成习惯: '}${task.name}${descriptionDetails}${bonusDescription}`, 
                isStreakAdvancement: isAdvancement,
                timestamp: referenceDate.toISOString(),
                isBackdate: isBackdate,
                pauseHistory: pauseHistory
            };
            
            // [v5.9.0] Phase 4: 增强事件记录
            if (USE_EVENT_SOURCING) {
                dispatchEvent(EVENT_TYPES.TASK_COMPLETED, {
                    taskId: task.id,
                    taskName: task.name,
                    transaction: transaction,
                    isHabit: true,
                    isBackdate: isBackdate,
                    habitStreak: isAdvancement ? {
                        newStreak: task.habitDetails.streak,
                        period: task.habitDetails.period
                    } : null
                }, { skipSnapshot: true, skipUI: true });
                
                // 手动添加交易（dispatchEvent 是异步的）
                transactions.push(transaction);
            } else {
                // 传统模式
                addTransaction(transaction);
                
                // [v5.8.1] 旁听记录
                logEvent(EVENT_TYPES.TASK_COMPLETED, {
                    taskId: task.id,
                    taskName: task.name,
                    transaction: transaction,
                    isHabit: true,
                    isBackdate: isBackdate,
                    habitStreak: isAdvancement ? {
                        newStreak: task.habitDetails.streak,
                        period: task.habitDetails.period
                    } : null
                });
            }
            
            // Only show notification if it's not a backdate
            if (getLocalDateString(referenceDate) === getLocalDateString(new Date())) {
                showNotification(notificationTitle, notificationBody, 'achievement');
            }
        }
// [v4.2.0] checkHabitStreak now also sets isBroken status AND accepts a referenceDate
        function checkHabitStreak(task, referenceDate = new Date()) { 
            // [v6.4.1] 跳过戒除类习惯，它们有独立的结算逻辑（checkAbstinenceHabits）
            if (task.habitDetails && task.habitDetails.type === 'abstinence') {
                return;
            }
            
            const { lastCompletionDate, period } = task.habitDetails; 
            if (!lastCompletionDate) { 
                task.habitDetails.streak = 0; 
                task.habitDetails.isBroken = false; // [v4.0.3]
                return; 
            } 
            
            const refDate = new Date(referenceDate); 
            refDate.setHours(0, 0, 0, 0); 
            const lastDate = new Date(lastCompletionDate); 
            lastDate.setHours(0, 0, 0, 0); 
            
            // If the last completion was on or after the reference date, no need to check
            if (lastDate >= refDate) {
                task.habitDetails.isBroken = false;
                return;
            }
            
            let isBroken = false; 
            const diffDays = (refDate - lastDate) / 86400000; 

            // 1. Check if the gap is too large
            if (period === 'daily' && diffDays > 1) {
                isBroken = true;
            } else if (period === 'weekly') {
                // Check if lastDate was in the *previous* week relative to refDate
                const refDay = refDate.getDay() === 0 ? 7 : refDate.getDay(); 
                const startOfThisWeek = new Date(refDate.getTime() - (refDay - 1) * 86400000); 
                const startOfLastWeek = new Date(startOfThisWeek.getTime() - 7 * 86400000);
                
                // If the last completion was before the start of last week
                if (lastDate < startOfLastWeek) {
                    isBroken = true;
                }
            } else if (period === 'monthly') { 
                const refMonth = refDate.getFullYear() * 12 + refDate.getMonth();
                const lastMonth = lastDate.getFullYear() * 12 + lastDate.getMonth();
                
                // If the gap is more than one month
                if (refMonth > lastMonth + 1) {
                    isBroken = true;
                }
            }
            
            if (isBroken) { 
                task.habitDetails.streak = 0; 
                task.habitDetails.isBroken = true; // [v4.0.3] Set broken status
                // [v4.8.5] 静默处理：不再推送“习惯中断”通知
            } else {
                task.habitDetails.isBroken = false; // [v4.0.3] Ensure not broken
            }
        }

        function startTask(event, taskId) { 
            lastLocalActionTime = Date.now(); // [v4.8.0] 记录本地作業時間
            // [v6.4.4] 关键：立即设置保存保护时间，防止 LiveQuery 在保存完成前覆盖状态
            lastSuccessfulSaveTime = Date.now();
            const task = tasks.find(t => t.id === taskId); 
            if (!task) return; 
            if (event && event.target.closest('.recent-tasks-grid') === null) { task.lastUsed = Date.now(); }
            const runningData = { startTime: Date.now(), elapsedTime: 0, isPaused: false, achieved: false, achievedTime: 0, tenMinReminderSent: false, pauseHistory: [] };
            runningTasks.set(taskId, runningData); // [v5.8.0] 添加 pauseHistory
            
            // [v6.5.0] 多表模式：同步到云端 RunningTask 表
            if (USE_MULTI_TABLE && isLoggedIn()) {
                DAL.startTask(taskId, runningData).catch(e => {
                    console.error('[startTask] DAL.startTask failed:', e);
                });
            }
            
            // [v5.9.0] Phase 4: 事件驱动模式
            if (USE_EVENT_SOURCING) {
                dispatchEvent(EVENT_TYPES.TASK_STARTED, {
                    taskId: taskId,
                    taskName: task.name,
                    taskType: task.type,
                        startTime: Date.now()
                    }, { skipSnapshot: true, skipUI: true });
                } else {
                    // [v5.8.1] 旁听记录任务开始事件
                    logEvent(EVENT_TYPES.TASK_STARTED, {
                        taskId: taskId,
                        taskName: task.name,
                        taskType: task.type
                    });
                }
                
                saveData(); 
                updateAllUI(); 
                showNotification('▶️ 任务开始', `开始执行任务: ${task.name}`, 'achievement'); 

            if (task.appPackage && window.Android && window.Android.launchApp) {
                try { window.Android.launchApp(task.appPackage); } catch (e) { console.error('launchApp failed', e); }
            }
            
            // [v4.11.0] 启动悬浮窗：尊重全局开关且需任务单独开启
            let enableFloatingTimer = false;
            if (task.enableFloatingTimer !== undefined) {
                enableFloatingTimer = task.enableFloatingTimer;
            } else {
                enableFloatingTimer = (task.type === 'continuous_target');
            }

            if (enableFloatingTimer && notificationSettings.floatingTimer !== false && window.Android && window.Android.startFloatingTimer) {
                let duration = 0;
                if (task.type === 'continuous_target') {
                    duration = task.targetTime || 0;
                } else {
                    duration = 0; // 普通计时/消费类走正计时
                }

                const colorHex = categoryColors.get(task.category) || '#667eea';

                try {
                    window.Android.startFloatingTimer(task.name, duration, colorHex);
                } catch(e) { console.error(e); }
            }

            // [v4.8.8] 调用安卓原生闹钟 (严格校验版)
            if (window.Android && window.Android.scheduleAlarm) {
                let duration = 0;
                
                // [Fix] 严格根据任务类型读取时间，防止脏数据(如fixedTime:1)干扰达标任务
                if (task.type === 'reward' || task.type === 'instant_redeem') {
                    duration = task.fixedTime || task.consumeTime || 0;
                } else if (['continuous', 'continuous_target', 'continuous_redeem'].includes(task.type)) {
                    // 达标任务只认 targetTime，普通计时任务闹钟设为 0 (不响铃) 或根据需求
                    if (task.type === 'continuous_target') duration = task.targetTime;
                    else duration = 0; // 纯计时任务通常不需要固定时间的闹钟
                }
                
                // 仅针对有明确目标时长的任务设置闹钟
                if (duration > 0) {
                    const alarmTitle = "⏰ 任务完成";
                    const alarmBody = `任务 "${task.name}" 目标时间已达成！`;
                    window.Android.scheduleAlarm(alarmTitle, alarmBody, duration * 1000);
                }
            }
        }
        
        function pauseTask(taskId) { 
            lastLocalActionTime = Date.now(); // [v4.8.0] 记录本地作業時間
            const r = runningTasks.get(taskId); 
            if (!r || r.isPaused) return; 
            r.elapsedTime += Date.now() - r.startTime; 
            r.isPaused = true; 
            if (!r.pauseHistory) r.pauseHistory = []; 
            r.pauseHistory.push({ pauseStart: Date.now() }); 
            
            const task = tasks.find(t => t.id === taskId);
            
            // [v5.9.0] Phase 4: 事件驱动模式
            if (USE_EVENT_SOURCING) {
                dispatchEvent(EVENT_TYPES.TASK_PAUSED, {
                    taskId: taskId,
                    taskName: task?.name,
                    elapsedTime: r.elapsedTime,
                    pauseTime: Date.now()
                }, { skipSnapshot: true, skipUI: true });
            } else {
                // [v5.8.1] 旁听记录暂停事件
                logEvent(EVENT_TYPES.TASK_PAUSED, {
                    taskId: taskId,
                    taskName: task?.name,
                    elapsedTime: r.elapsedTime
                });
            }
            
            // [v5.8.1] 暂停悬浮窗计时器
            if (task && window.Android && window.Android.pauseFloatingTimer) {
                try { window.Android.pauseFloatingTimer(task.name); } catch(e) { console.error(e); }
            }
            
            // [v6.5.0] 多表模式：同步暂停状态到云端
            if (USE_MULTI_TABLE && isLoggedIn()) {
                DAL.updateRunningTask(taskId, r).catch(e => {
                    console.error('[pauseTask] DAL.updateRunningTask failed:', e);
                });
            }
            
            saveData(); 
            updateRecentTasks(); 
            updateCategoryTasks(); 
        }
        
        function resumeTask(taskId) { 
            lastLocalActionTime = Date.now(); // [v4.8.0] 记录本地作業時間
            const r = runningTasks.get(taskId); 
            if (!r || !r.isPaused) return; 
            if (r.pauseHistory && r.pauseHistory.length > 0) { 
                const last = r.pauseHistory[r.pauseHistory.length - 1]; 
                if (!last.pauseEnd) last.pauseEnd = Date.now(); 
            } 
            r.startTime = Date.now(); 
            r.isPaused = false; 
            
            const task = tasks.find(t => t.id === taskId);
            
            // [v5.9.0] Phase 4: 事件驱动模式
            if (USE_EVENT_SOURCING) {
                dispatchEvent(EVENT_TYPES.TASK_RESUMED, {
                    taskId: taskId,
                    taskName: task?.name,
                    elapsedTime: r.elapsedTime,
                    resumeTime: Date.now()
                }, { skipSnapshot: true, skipUI: true });
            } else {
                // [v5.8.1] 旁听记录恢复事件
                logEvent(EVENT_TYPES.TASK_RESUMED, {
                    taskId: taskId,
                    taskName: task?.name,
                    elapsedTime: r.elapsedTime
                });
            }
            
            // [v5.8.1] 恢复悬浮窗计时器
            if (task && window.Android && window.Android.resumeFloatingTimer) {
                try { window.Android.resumeFloatingTimer(task.name); } catch(e) { console.error(e); }
            }
            
            // [v6.5.0] 多表模式：同步恢复状态到云端
            if (USE_MULTI_TABLE && isLoggedIn()) {
                DAL.updateRunningTask(taskId, r).catch(e => {
                    console.error('[resumeTask] DAL.updateRunningTask failed:', e);
                });
            }
            
            saveData(); 
            updateRecentTasks(); 
            updateCategoryTasks(); 
        }
        
        function cancelTask(taskId) { 
            // [v6.4.6] 立即设置保存保护时间，防止 LiveQuery 在保存完成前覆盖状态
            lastSuccessfulSaveTime = Date.now();
            // [v4.7.0 核心修改] 先获取任务对象，才能拿到名字
            const task = tasks.find(t => t.id === taskId);
            const r = runningTasks.get(taskId);
            const elapsedTime = r ? (r.elapsedTime + (r.isPaused ? 0 : Date.now() - r.startTime)) : 0;
            
            // [v5.9.0] Phase 4: 事件驱动模式
            if (USE_EVENT_SOURCING) {
                dispatchEvent(EVENT_TYPES.TASK_CANCELLED, {
                    taskId: taskId,
                    taskName: task?.name,
                    elapsedTime: elapsedTime,
                    cancelTime: Date.now()
                }, { skipSnapshot: true, skipUI: true });
            } else {
                // [v5.8.1] 旁听记录取消事件
                logEvent(EVENT_TYPES.TASK_CANCELLED, {
                    taskId: taskId,
                    taskName: task?.name,
                    elapsedTime: elapsedTime
                });
            }
            
            // 停止悬浮窗：传入 task.name
            if (task && window.Android && window.Android.stopFloatingTimer) {
                try {
                    window.Android.stopFloatingTimer(task.name);
                } catch(e) { console.error(e); }
            }
            
            runningTasks.delete(taskId); 
            
            // [v6.5.0] 多表模式：同步删除云端 RunningTask 记录
            if (USE_MULTI_TABLE && isLoggedIn()) {
                DAL.stopTask(taskId).catch(e => {
                    console.error('[cancelTask] DAL.stopTask failed:', e);
                });
            }
            
            saveData(); 
            updateRecentTasks(); 
            updateCategoryTasks(); 
        }

        function stopTask(taskId) {
            lastLocalActionTime = Date.now(); // [v4.8.0] 记录本地作業時間
            // [v6.4.4] 关键：立即设置保存保护时间，防止 LiveQuery 在保存完成前覆盖状态
            lastSuccessfulSaveTime = Date.now();
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            const runningTask = runningTasks.get(taskId);
            if (taskIndex === -1 || !runningTask) return;
            const task = tasks[taskIndex];
            const stopEventTime = new Date();

            // [v4.7.0 核心修改] 停止悬浮窗：必须传入 task.name
            if (window.Android && window.Android.stopFloatingTimer) {
                try {
                    window.Android.stopFloatingTimer(task.name); 
                } catch(e) { console.error("Float stop failed", e); }
            }

            const totalSeconds = Math.floor((runningTask.elapsedTime + (runningTask.isPaused ? 0 : Date.now() - runningTask.startTime)) / 1000);
            const pauseHistory = runningTask.pauseHistory || []; // [v5.8.0] 保存暂停历史
            
            // ... (保留这一行及之后的代码不要动)
            // runningTasks.delete(taskId);
            runningTasks.delete(taskId);
            task.lastUsed = Date.now();
            
            if (totalSeconds > 0) {
                if (['continuous', 'continuous_target'].includes(task.type)) {
                    let baseEarnedTime = Math.floor(totalSeconds * task.multiplier);
                    let earnedTimeDescription = ` (${formatTime(totalSeconds)} × ${task.multiplier})`;
                    const targetMet = task.type === 'continuous_target' && (runningTask.achieved || totalSeconds >= task.targetTime);
                    
                    if (targetMet) {
                        baseEarnedTime += task.bonusReward;
                        if (task.bonusReward > 0) earnedTimeDescription += ` + ${formatTime(task.bonusReward)} 达标奖励`;
                    }
                    
                    if (task.isHabit) {
                        const todayStr = getLocalDateString(new Date());
                        const completionsToday = transactions.filter(t => t.taskId === taskId && getLocalDateString(t.timestamp) === todayStr).length;
                        if (completionsToday >= (task.habitDetails.dailyLimit || 1)) {
                            showAlert('已达到此习惯的每日完成上限');
                        } else {
                            // [v4.5.4] FIX: Only process as a habit *advancement* if the target was met
                            if (task.type === 'continuous_target' && !targetMet) {
                                // Target not met, but it's a habit. Grant base time, but do not advance streak.
                                processNormalCompletion(task, baseEarnedTime, earnedTimeDescription, stopEventTime, pauseHistory);
                            } else {
                                // Is 'continuous' habit, or 'continuous_target' habit that *was* met
                                processHabitCompletion(task, baseEarnedTime, stopEventTime, earnedTimeDescription, pauseHistory);
                            }
                        }
                    } else {
                        processNormalCompletion(task, baseEarnedTime, earnedTimeDescription, stopEventTime, pauseHistory);
                    }
                    // 记录停止事件供冲突检测
                    if (USE_EVENT_SOURCING) {
                        dispatchEvent(EVENT_TYPES.TASK_STOPPED, {
                            taskId: task.id,
                            taskName: task.name,
                            taskType: task.type,
                            elapsedSeconds: totalSeconds,
                            earnedAmount: baseEarnedTime,
                            targetMet: targetMet,
                            pauseHistory: pauseHistory
                        }, { skipSnapshot: true, skipUI: true });
                    } else {
                        logEvent(EVENT_TYPES.TASK_STOPPED, {
                            taskId: task.id,
                            taskName: task.name,
                            taskType: task.type,
                            elapsedSeconds: totalSeconds,
                            earnedAmount: baseEarnedTime,
                            targetMet: targetMet,
                            pauseHistory: pauseHistory
                        });
                        recordLocalEvent(EVENT_TYPES.TASK_STOPPED, {
                            taskId: task.id,
                            taskName: task.name,
                            taskType: task.type,
                            elapsedSeconds: totalSeconds,
                            earnedAmount: baseEarnedTime,
                            targetMet: targetMet
                        }, stopEventTime.toISOString());
                    }
                } else if (task.type === 'continuous_redeem') {
                    const isPenalty = currentBalance < 0;
                    const baseSpentTime = Math.floor(totalSeconds * task.multiplier);
                    const finalSpentTime = isPenalty ? Math.floor(baseSpentTime * 1.2) : baseSpentTime;
                    let description = `连续消费: ${task.name} (${formatTime(totalSeconds)} × ${task.multiplier})`;
                    if (isPenalty) description += ` (余额不足, 1.2倍消耗)`;
                    currentBalance -= finalSpentTime;
                    task.completionCount = (task.completionCount || 0) + 1;
                    const tx = { type: 'spend', taskId: task.id, taskName: task.name, amount: finalSpentTime, description: description, pauseHistory: pauseHistory, rawSeconds: totalSeconds, timestamp: stopEventTime.toISOString() }; // [v5.8.0] 添加 pauseHistory, [v6.4.1] 添加 rawSeconds 用于戒除习惯统计
                    addTransaction(tx);
                    updateDailyChanges('spent', finalSpentTime);
                    showNotification('💸 任务消费', `消费 ${formatTime(finalSpentTime)} 时间`, 'achievement');
                    // 记录停止事件供冲突检测
                    if (USE_EVENT_SOURCING) {
                        dispatchEvent(EVENT_TYPES.TASK_STOPPED, {
                            taskId: task.id,
                            taskName: task.name,
                            taskType: task.type,
                            elapsedSeconds: totalSeconds,
                            spentAmount: finalSpentTime,
                            isPenalty: isPenalty,
                            pauseHistory: pauseHistory
                        }, { skipSnapshot: true, skipUI: true });
                    } else {
                        logEvent(EVENT_TYPES.TASK_STOPPED, {
                            taskId: task.id,
                            taskName: task.name,
                            taskType: task.type,
                            elapsedSeconds: totalSeconds,
                            spentAmount: finalSpentTime,
                            isPenalty: isPenalty,
                            pauseHistory: pauseHistory
                        });
                        recordLocalEvent(EVENT_TYPES.TASK_STOPPED, {
                            taskId: task.id,
                            taskName: task.name,
                            taskType: task.type,
                            elapsedSeconds: totalSeconds,
                            spentAmount: finalSpentTime,
                            isPenalty: isPenalty
                        }, stopEventTime.toISOString());
                    }
                }
            }
            
            if (task.reminderDetails && task.reminderDetails.status === 'pending' && !task.reminderDetails.isRecurring) {
                task.reminderDetails.status = 'triggered'; 
            }
            
            // [v6.5.0] 多表模式：同步删除云端 RunningTask 记录
            if (USE_MULTI_TABLE && isLoggedIn()) {
                DAL.stopTask(taskId).catch(e => {
                    console.error('[stopTask] DAL.stopTask failed:', e);
                });
            }
            
            saveData();
            // 结束即备份，避免网络冲突导致丢单
            try { localStorage.setItem('timeBankData_backup', localStorage.getItem('timeBankData') || ""); } catch (e) { console.warn('[stopTask] backup failed', e); }
            updateAllUI();
        }
        
        async function redeemTask(taskId) { 
            lastLocalActionTime = Date.now(); // [v4.8.0] 记录本地作業時間
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex === -1) return;
            const task = tasks[taskIndex];

            const isPenalty = currentBalance < 0;
            const baseCost = task.consumeTime;
            const finalCost = isPenalty ? Math.floor(baseCost * 1.2) : baseCost;
            let description = `兑换项目: ${task.name}`;
            
            const confirmMessage = `确定要消费 ${formatTime(finalCost)}${isPenalty ? ' (含1.2倍惩罚)' : ''} 兑换"${task.name}"吗？${isPenalty ? '\n(当前余额为负)' : ''}`;
            
            if (!await showConfirm(confirmMessage, '兑换确认')) return; 
            if (task.appPackage && window.Android && window.Android.launchApp) {
                try { window.Android.launchApp(task.appPackage); } catch (e) { console.error('launchApp failed', e); }
            }
            
            if (isPenalty) description += ` (余额不足, 1.2倍消耗)`;

            currentBalance -= finalCost; 
            task.completionCount = (task.completionCount || 0) + 1; 
            task.lastUsed = Date.now(); 
            addTransaction({ type: 'spend', taskId: task.id, taskName: task.name, amount: finalCost, description: description }); 
            updateDailyChanges('spent', finalCost); 
            
            if (task.reminderDetails && task.reminderDetails.status === 'pending' && !task.reminderDetails.isRecurring) {
                task.reminderDetails.status = 'triggered'; 
            }
            
            saveData(); 
            updateAllUI(); 
            showNotification('🎁 兑换成功', `成功兑换: ${task.name}`, 'achievement');
        }
        
        // --- History Modal and Undo ---
        
        // [v5.5.2] 获取补录类型信息（图标和标签）
        // 🤖 自动补录：系统自动检测并补录漏记录
        // 🔧 自动修正：系统自动检测并修正多记录
        // 📆 手动补录：用户手动补录过往记录
        function getBackdateTypeInfo(transaction) {
            if (!transaction.isBackdate && !transaction.isAutoDetected) {
                return { icon: '', label: '' };
            }
            if (transaction.isAutoDetected) {
                if (transaction.autoDetectType === 'correction') {
                    // 系统自动修正多记录
                    return { icon: '🔧', label: '自动修正' };
                } else {
                    // 系统自动补录漏记录
                    return { icon: '🤖', label: '自动补录' };
                }
            }
            // 用户手动补录
            return { icon: '📆', label: '手动补录' };
        }
        
        // [v4.5.1] Reworked showTaskHistory to initialize views
        function showTaskHistory(taskId) { 
            const task = tasks.find(t => t.id === taskId); 
            if (!task) return; 
            currentHistoryTask = task; 
            
            // [v4.5.0] Reset states
            currentHistoryView = 'list';
            currentHistoryCalendarDate = new Date();
            currentHistorySelectedDate = null; // [v5.1.0] Reset selected date filter
            
            document.getElementById('historyModalTitle').textContent = `${task.name} - 历史记录`; 
            
            // Render list view by default
            const listContainer = document.getElementById('historyContentList'); 
            const taskTransactions = transactions
                .filter(t => t.taskId === taskId && !t.undone)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); 

            // 屏幕时间有独立卡片，不在任务历史中展示
            if (task.type === 'screen_time') {
                listContainer.innerHTML = '<div class="empty-message">屏幕时间使用专属卡片展示，不在任务历史中显示</div>';
            } else if (taskTransactions.length === 0) {
                listContainer.innerHTML = '<div class="empty-message">暂无历史记录</div>'; 
            } else { 
                listContainer.innerHTML = taskTransactions.map(transaction => { 
                    const isPositive = transaction.type === 'earn' || (!transaction.type && transaction.amount > 0);
                    const amount = Math.abs(transaction.amount);

                    // 使用统一解析规则，分离标题与详情
                    const parsed = parseTransactionDescription(transaction);
                    let title = parsed.title;
                    const detail = parsed.detail;
                    const hasWarning = parsed.warning;

                    // [v5.8.0] 新图标组合逻辑：
                    // ⚠️ 警告（余额不足）> ⭐ 习惯奖励 > 🎯 达标 > 🤖/🔧/📆 补录类型
                    // 自动补录用🤖，自动修正用🔧，手动补录用📆
                    let iconPrefix = '';
                    if (hasWarning) iconPrefix += '⚠️';
                    if (parsed.hasHabitBonus) iconPrefix += '⭐';
                    if (parsed.isTarget && parsed.icon === '🎯') iconPrefix += '🎯';
                    // 使用 parsed.icon 来区分自动补录(🤖)、自动修正(🔧)、手动补录(📆)
                    if (parsed.icon === '🤖' || parsed.icon === '🔧') {
                        iconPrefix += parsed.icon;
                    } else if (parsed.isBackdate) {
                        iconPrefix += '📆';
                    }
                    if (iconPrefix) iconPrefix += ' ';
                    title = iconPrefix + title;

                    const dateTimeStr = formatDateTime(transaction.timestamp);
                    
                    return `<div class="history-item" id="history-item-${transaction.id}">
                                <div class="history-info" title="${transaction.description}">
                                    <div class="history-description">
                                        <div class="desc-line-1">${title}</div>
                                        ${detail ? `<div class="desc-line-2">${detail}</div>` : ''}
                                    </div>
                                    <div class="history-time">${dateTimeStr}</div>
                                </div>
                                <div class="history-amount-wrapper">
                                    <div class="history-amount ${isPositive ? 'positive' : 'negative'}">${isPositive ? '+' : '-'}${formatTime(amount)}</div>
                                </div>
                                <button class="undo-btn" onclick="undoTransaction('${transaction.id}')" title="撤回此条记录">撤回</button>
                            </div>`; 
                }).join(''); 
            }
            
            // [v5.1.0] Render both calendar and list views (combined view)
            renderTaskActivityCalendar();
            
            document.getElementById('historyModal').classList.add('show'); 
        }

        // [v4.5.1] New function to render the task-specific activity calendar
        function renderTaskActivityCalendar() {
            const container = document.getElementById('historyContentCalendar');
            if (!currentHistoryTask) {
                container.innerHTML = '<div class="empty-message">错误：未找到任务</div>';
                return;
            }

            const task = currentHistoryTask;
            
            // [v4.5.0] 性能优化: 仅筛选一次
            const taskTransactions = transactions.filter(t => t.taskId === task.id && !t.undone);

            // 1. 聚合数据
            const dailyData = new Map();
            const isCountBased = ['reward', 'instant_redeem'].includes(task.type);
            const isEarn = ['reward', 'continuous', 'continuous_target'].includes(task.type);
            
            taskTransactions.forEach(t => {
                const localDateStr = getLocalDateString(t.timestamp);
                if (!dailyData.has(localDateStr)) {
                    dailyData.set(localDateStr, { count: 0, amount: 0 });
                }
                const dayData = dailyData.get(localDateStr);
                dayData.count++;
                dayData.amount += t.amount;
            });

            // 2. 准备日历
            const year = currentHistoryCalendarDate.getFullYear();
            const month = currentHistoryCalendarDate.getMonth();
            const firstDayOfMonth = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();

            // 3. 渲染导航
            let navHTML = `<div class="report-header" style="margin-bottom: var(--space-lg);">
                <h2 class="report-title" style="font-size: 1rem;">${year}年 ${month + 1}月</h2>
                <div class="heatmap-nav">
                    <button id="taskCalPrevMonth" onclick="navigateTaskCalendar(-1)">&lt;</button>
                    <button id="taskCalNextMonth" onclick="navigateTaskCalendar(1)">&gt;</button>
                </div>
            </div>`;
            
            // 4. 渲染网格
            let gridHTML = `<div class="heatmap-grid-wrapper">
                <div class="heatmap-weekdays">
                    <span>日</span><span>一</span><span>二</span><span>三</span><span>四</span><span>五</span><span>六</span>
                </div>
                <div class="heatmap-grid">`;
            
            for (let i = 0; i < firstDayOfMonth; i++) {
                gridHTML += `<div class="heatmap-spacer"></div>`;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const currentDate = new Date(year, month, day);
                const localDateStr = getLocalDateString(currentDate);
                const data = dailyData.get(localDateStr);
                
                let colorClass = '';
                let title = `${localDateStr}`;

                if (data) {
                    if (isCountBased) {
                        // 阈值: 1, 2, 3+
                        if (isEarn) {
                            if (data.count === 1) colorClass = 'task-cal-green-1';
                            else if (data.count === 2) colorClass = 'task-cal-green-2';
                            else if (data.count >= 3) colorClass = 'task-cal-green-3';
                        } else {
                            if (data.count === 1) colorClass = 'task-cal-red-1';
                            else if (data.count === 2) colorClass = 'task-cal-red-2';
                            else if (data.count >= 3) colorClass = 'task-cal-red-3';
                        }
                        title += `: 完成 ${data.count} 次`;
                    } else {
                        // 阈值: <1h (0-3599s), 1-3h (3600-10800s), >3h (10801s+)
                        if (isEarn) {
                            if (data.amount > 0 && data.amount < 3600) colorClass = 'task-cal-green-1';
                            else if (data.amount >= 3600 && data.amount <= 10800) colorClass = 'task-cal-green-2';
                            else if (data.amount > 10800) colorClass = 'task-cal-green-3';
                        } else {
                            if (data.amount > 0 && data.amount < 3600) colorClass = 'task-cal-red-1';
                            else if (data.amount >= 3600 && data.amount <= 10800) colorClass = 'task-cal-red-2';
                            else if (data.amount > 10800) colorClass = 'task-cal-red-3';
                        }
                        title += `: 累计 ${formatTime(data.amount)}`;
                    }
                }

                gridHTML += `<div class="heatmap-day" title="${title}" onclick="filterHistoryByDate('${localDateStr}')" style="cursor: pointer;">
                                <div class="heatmap-day-content ${colorClass}">${day}</div>
                             </div>`;
            }
            gridHTML += `</div></div>`;
            
            // 5. 渲染动态图例
            let legendHTML = `<div class="heatmap-legend">`;
            const colorPrefix = isEarn ? 'task-cal-green' : 'task-cal-red';
            const labels = isCountBased 
                ? ['1次', '2次', '3+次'] 
                : ['<1小时', '1-3小时', '>3小时'];
            
            legendHTML += `<div class="legend-item"><div class="legend-box ${colorPrefix}-1"></div> <span>${labels[0]}</span></div>`;
            legendHTML += `<div class="legend-item"><div class="legend-box ${colorPrefix}-2"></div> <span>${labels[1]}</span></div>`;
            legendHTML += `<div class="legend-item"><div class="legend-box ${colorPrefix}-3"></div> <span>${labels[2]}</span></div>`;
            legendHTML += `</div>`;
            
            // 组合并渲染
            container.innerHTML = navHTML + gridHTML + legendHTML;
            
            // 禁用 "Next" 按钮（如果是在当月）
            const nextMonth = new Date(year, month + 1, 1);
            document.getElementById('taskCalNextMonth').disabled = nextMonth > new Date();
        }

        // [v4.5.0] New function to navigate the task calendar
        function navigateTaskCalendar(offset) {
            currentHistoryCalendarDate.setMonth(currentHistoryCalendarDate.getMonth() + offset);
            renderTaskActivityCalendar();
        }

        // [v5.1.0] State for selected date filter
        let currentHistorySelectedDate = null;

        // [v5.1.0] Filter history list by clicked date
        function filterHistoryByDate(dateStr) {
            if (!currentHistoryTask) return;
            const listContainer = document.getElementById('historyContentList');
            const listHeader = document.querySelector('.history-list-header');
            
            // Toggle: click same date again to show all
            if (currentHistorySelectedDate === dateStr) {
                currentHistorySelectedDate = null;
                if (listHeader) listHeader.innerHTML = '历史记录';
            } else {
                currentHistorySelectedDate = dateStr;
                if (listHeader) listHeader.innerHTML = `历史记录 <span style="font-weight: normal; font-size: 0.8rem; color: var(--text-color-light);">(筛选: ${dateStr}) <span onclick="filterHistoryByDate('${dateStr}')" style="cursor: pointer; color: var(--color-primary);">[显示全部]</span></span>`;
            }
            
            // Re-render list with filter
            const taskId = currentHistoryTask.id;
            let taskTransactions = transactions
                .filter(t => t.taskId === taskId && !t.undone)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            if (currentHistorySelectedDate) {
                taskTransactions = taskTransactions.filter(t => getLocalDateString(t.timestamp) === currentHistorySelectedDate);
            }
            
            if (taskTransactions.length === 0) {
                listContainer.innerHTML = '<div class="empty-message">当天无记录</div>';
            } else {
                listContainer.innerHTML = taskTransactions.map(transaction => {
                    const isPositive = transaction.type === 'earn' || (!transaction.type && transaction.amount > 0);
                    const amount = Math.abs(transaction.amount);

                    // 使用统一解析规则，分离标题与详情
                    const parsed = parseTransactionDescription(transaction);
                    let title = parsed.title;
                    const detail = parsed.detail;
                    const hasWarning = parsed.warning;

                    // [v5.8.0] 图标逻辑修复：自动补录用🤖，自动修正用🔧，手动补录用📆
                    let iconPrefix = '';
                    if (hasWarning) iconPrefix += '⚠️';
                    if (parsed.hasHabitBonus) iconPrefix += '⭐';
                    if (parsed.isTarget && parsed.icon === '🎯') iconPrefix += '🎯';
                    if (parsed.icon === '🤖' || parsed.icon === '🔧') {
                        iconPrefix += parsed.icon;
                    } else if (parsed.isBackdate) {
                        iconPrefix += '📆';
                    }
                    if (iconPrefix) iconPrefix += ' ';
                    title = iconPrefix + title;

                    const dateTimeStr = formatDateTime(transaction.timestamp);
                    
                    return `<div class="history-item" id="history-item-${transaction.id}">
                                <div class="history-info" title="${transaction.description}">
                                    <div class="history-description">
                                        <div class="desc-line-1">${title}</div>
                                        ${detail ? `<div class="desc-line-2">${detail}</div>` : ''}
                                    </div>
                                    <div class="history-time">${dateTimeStr}</div>
                                </div>
                                <div class="history-amount-wrapper">
                                    <div class="history-amount ${isPositive ? 'positive' : 'negative'}">${isPositive ? '+' : '-'}${formatTime(amount)}</div>
                                </div>
                                <button class="undo-btn" onclick="undoTransaction('${transaction.id}')" title="撤回此条记录">撤回</button>
                            </div>`;
                }).join('');
            }
            
            // Highlight selected day in calendar
            document.querySelectorAll('#historyContentCalendar .heatmap-day').forEach(el => {
                el.classList.remove('selected');
            });
            if (currentHistorySelectedDate) {
                document.querySelectorAll('#historyContentCalendar .heatmap-day').forEach(el => {
                    if (el.getAttribute('title')?.startsWith(currentHistorySelectedDate)) {
                        el.classList.add('selected');
                    }
                });
            }
        }

// [v4.3.0] Modified undoTransaction to call rebuildHabitStreak
// [v5.9.0] Phase 4: 支持事件驱动写入模式
async function undoTransaction(transactionId) { 
    const transactionIndex = transactions.findIndex(t => t.id === transactionId); 
    if (transactionIndex === -1) return; 
    const transaction = transactions[transactionIndex]; 
    if (!await showConfirm(`确定要撤回这条记录吗？\n\n描述: ${transaction.description}\n金额: ${transaction.type === 'earn' ? '+' : '-'}${formatTime(transaction.amount)}\n\n此操作将影响总余额、每日统计和任务完成次数，且无法恢复。`, '撤回记录')) return; 
    
    const task = tasks.find(t => t.id === transaction.taskId);
    
    // [v5.9.0] Phase 4: 事件驱动模式
    if (USE_EVENT_SOURCING) {
        const result = await dispatchEvent(EVENT_TYPES.TRANSACTION_UNDONE, {
            undoneTransactionId: transactionId,
            taskId: transaction.taskId,
            taskName: transaction.taskName,
            amount: transaction.amount,
            type: transaction.type,
            originalTimestamp: transaction.timestamp,
            reversalTransaction: {
                id: generateId(),
                type: transaction.type === 'earn' ? 'spend' : 'earn',
                taskId: transaction.taskId,
                taskName: transaction.taskName,
                amount: transaction.amount,
                description: `撤回: ${transaction.description}`,
                timestamp: new Date().toISOString(),
                isReversal: true
            }
        });
        
        if (!result.success) {
            // Fallback to legacy mode
            console.warn('[ES] undoTransaction fallback to legacy mode');
            performLegacyUndo(transaction, transactionIndex, task);
        }
    } else {
        // 传统模式
        // [v5.8.1] 旁听记录撤回事件
        logEvent(EVENT_TYPES.TRANSACTION_UNDONE, {
            targetTransactionId: transactionId,
            taskId: transaction.taskId,
            taskName: transaction.taskName,
            amount: transaction.amount,
            type: transaction.type,
            originalTimestamp: transaction.timestamp
        });
        
        performLegacyUndo(transaction, transactionIndex, task);
    }
    
    // [v4.5.0] Refresh history view if it's open
    if (task && currentHistoryTask && currentHistoryTask.id === task.id) {
        if (currentHistoryView === 'list') {
            const historyItemElement = document.getElementById(`history-item-${transactionId}`); 
            if (historyItemElement) { 
                historyItemElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease'; 
                historyItemElement.style.opacity = '0'; 
                historyItemElement.style.transform = 'translateX(20px)'; 
                setTimeout(() => { 
                    historyItemElement.remove(); 
                    if (!document.getElementById('historyContentList').querySelector('.history-item')) {
                        document.getElementById('historyContentList').innerHTML = '<div class="empty-message">暂无历史记录</div>'; 
                    }
                }, 300); 
            }
        } else {
            // Refresh calendar view
            renderTaskActivityCalendar();
        }
    }
    
    showNotification('↩️ 操作已撤回', `成功撤回记录: ${transaction.taskName}`, 'achievement'); 
}

// [v5.9.0] 传统撤回逻辑提取为独立函数
function performLegacyUndo(transaction, transactionIndex, task) {
    if (transaction.type === 'earn') { 
        currentBalance -= transaction.amount; 
        updateDailyChanges('earned', -transaction.amount, new Date(transaction.timestamp)); 
    } else { 
        currentBalance += transaction.amount; 
        updateDailyChanges('spent', -transaction.amount, new Date(transaction.timestamp)); 
    } 
    
    if (task) { 
        if (task.completionCount > 0) task.completionCount--; 
    } 
    
    transactions.splice(transactionIndex, 1); 
    
    // [v4.3.0] If it was a habit, trigger a full rebuild
    if (task && task.isHabit && task.type === 'reward') {
        rebuildHabitStreak(task);
    }
    
    saveData(); 
    updateAllUI(); 
}
        function hideHistoryModal() { document.getElementById('historyModal').classList.remove('show'); currentHistoryTask = null; }
// --- Backdate Modal ---
        // [v4.2.0] Updated showBackdateModal to support 'count' mode
        function showBackdateModal(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            currentBackdateTaskId = taskId;
            document.getElementById('backdateTaskName').textContent = task.name;
            document.getElementById('backdateTaskId').value = taskId;
            
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            document.getElementById('backdateDate').value = `${yyyy}-${mm}-${dd}`;
            document.getElementById('backdateDate').max = `${yyyy}-${mm}-${dd}`;
            
            // Reset forms
            document.getElementById('backdateHours').value = '';
            document.getElementById('backdateMinutes').value = '';
            document.getElementById('backdateCount').value = '1';
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const currentTime = `${hours}:${minutes}`;
            document.getElementById('backdateStartTime').value = currentTime;
            document.getElementById('backdateEndTime').value = currentTime;
            
            clearFormErrors();
            
            // [v4.2.0] Auto-select mode based on task type
            const isDurationTask = ['continuous', 'continuous_target', 'continuous_redeem'].includes(task.type);
            
            document.getElementById('backdateModeSwitchContainer').classList.toggle('hidden', !isDurationTask);
            document.getElementById('backdateDurationMode').classList.toggle('hidden', isDurationTask);
            document.getElementById('backdateRangeMode').classList.toggle('hidden', isDurationTask);
            document.getElementById('backdateCountMode').classList.toggle('hidden', isDurationTask);

            if (isDurationTask) {
                switchBackdateMode('duration');
            } else {
                // It's 'reward' or 'instant_redeem', force 'count' mode
                currentBackdateMode = 'count';
                document.getElementById('backdateDurationMode').classList.add('hidden');
                document.getElementById('backdateRangeMode').classList.add('hidden');
                document.getElementById('backdateCountMode').classList.remove('hidden');
            }
            
            document.getElementById('backdateModal').classList.add('show');
        }

        function hideBackdateModal() { document.getElementById('backdateModal').classList.remove('show'); currentBackdateTaskId = null; }
        
        // [v5.6.0] 手动检测补录功能已删除，改用自动补录系统
        
        // [v4.2.0] switchBackdateMode now only handles duration/range
        function switchBackdateMode(mode) {
            currentBackdateMode = mode;
            document.getElementById('backdateDurationMode').classList.toggle('hidden', mode !== 'duration');
            document.getElementById('backdateRangeMode').classList.toggle('hidden', mode === 'duration');
            document.querySelectorAll('#backdateModal .mode-switch button').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === mode));
            clearFormErrors();
        }
        
        // [v4.3.0] Reworked saveBackdate to NOT call processHabitCompletion, calls rebuildHabitStreak instead
        async function saveBackdate(event) {
            event.preventDefault(); clearFormErrors();
            const taskId = document.getElementById('backdateTaskId').value;
            const task = tasks.find(t => t.id === taskId);
            if (!task) { showAlert('发生错误：找不到任务'); return; }
            
            const dateStr = document.getElementById('backdateDate').value;
            if (!dateStr) { showAlert('请选择补记日期'); return; }

            // [v4.5.4] FIX: Use real time if backdating for "today"
            let backdateTimestamp;
            const todayStr = getLocalDateString(new Date());

            if (dateStr === todayStr) {
                backdateTimestamp = new Date(); // Use current time
            } else {
                // Set the timestamp to noon on the selected date to avoid timezone issues
                const [year, month, day] = dateStr.split('-').map(Number);
                backdateTimestamp = new Date(year, month - 1, day, 12, 0, 0); 
            }

            let hasError = false;
            let totalSeconds = 0;
            let completionCount = 0;
            
            if (currentBackdateMode === 'count') {
                completionCount = parseInt(document.getElementById('backdateCount').value);
                if (isNaN(completionCount) || completionCount < 1) {
                    showFieldError('backdateCount', '补录次数必须大于0'); hasError = true;
                }
            } else if (currentBackdateMode === 'duration') {
                const hours = parseInt(document.getElementById('backdateHours').value || '0');
                const minutes = parseInt(document.getElementById('backdateMinutes').value || '0');
                if (isNaN(hours) || hours < 0 || isNaN(minutes) || minutes < 0 || minutes > 59) {
                    showFieldError('backdateDuration', '请输入有效的小时和分钟'); hasError = true;
                } else {
                    totalSeconds = (hours * 3600) + (minutes * 60);
                    if (totalSeconds <= 0) { showFieldError('backdateDuration', '总时长必须大于0'); hasError = true; }
                }
                completionCount = 1; // Duration tasks are always 1 completion
            } else { // range mode
                const startTimeStr = document.getElementById('backdateStartTime').value;
                const endTimeStr = document.getElementById('backdateEndTime').value;
                if (!startTimeStr || !endTimeStr) {
                    if (!startTimeStr) showFieldError('backdateStartTime', '请输入开始时间');
                    if (!endTimeStr) showFieldError('backdateEndTime', '请输入结束时间');
                    hasError = true;
                } else {
                    const startDateTime = new Date(`${dateStr}T${startTimeStr}`);
                    const endDateTime = new Date(`${dateStr}T${endTimeStr}`);
                    if (endDateTime <= startDateTime) { showFieldError('backdateEndTime', '结束时间必须晚于开始时间'); hasError = true; } 
                    else { totalSeconds = (endDateTime - startDateTime) / 1000; }
                }
                completionCount = 1; // Range tasks are always 1 completion
            }
            
            if (hasError) return;
            
            let totalAmountEarned = 0;
            let totalAmountSpent = 0;
            let didHabitBackdate = false;
            
            // --- Start processing loop ---
            for (let i = 0; i < completionCount; i++) {
                let amount = 0;
                let transactionType = '';
                let description = `补录: ${task.name}`;

                // --- Handle Habit Daily Limit Check ---
                if (task.isHabit) {
                    const dailyLimit = task.habitDetails.dailyLimit || 1;
                    // Get completions *on that day*, including ones we just added in this loop
                    const completionsOnBackdate = transactions.filter(t => 
                        t.taskId === taskId && 
                        t.type === 'earn' && 
                        getLocalDateString(t.timestamp) === dateStr
                    ).length;
                    
                    if (completionsOnBackdate >= dailyLimit) {
                        showAlert(`补录失败：任务 "${task.name}" 在 ${dateStr} 的每日上限为 ${dailyLimit} 次，无法继续添加。`);
                        hasError = true;
                        break; // Stop the loop
                    }
                }

                // --- Calculate Amount and Type ---
                if (task.type === 'reward') {
                    transactionType = 'earn';
                    amount = task.fixedTime;
                    
                    if (task.isHabit) {
                        // [v4.3.0] This is the core logic change.
                        // We DO NOT call processHabitCompletion.
                        // We just add a simple transaction. The rebuild will handle the streak.
                        didHabitBackdate = true;
                        description += ' (补录)';
                    }
                    
                } else if (task.type === 'instant_redeem') {
                    transactionType = 'spend';
                    amount = task.consumeTime;
                    const netChangeSinceThen = transactions
                        .filter(t => new Date(t.timestamp) > backdateTimestamp)
                        .reduce((sum, t) => sum + (t.type === 'earn' ? t.amount : -t.amount), 0);
                    const historicalBalance = currentBalance - netChangeSinceThen;
                    const isPenalty = historicalBalance < 0;
                    
                    if (isPenalty) {
                        amount = Math.floor(amount * 1.2);
                        description += ` (历史余额不足, 1.2倍消耗)`;
                    }

                } else if (['continuous', 'continuous_target'].includes(task.type)) {
                    transactionType = 'earn';
                    amount = Math.floor(totalSeconds * task.multiplier);
                    description += ` (${formatTime(totalSeconds)} × ${task.multiplier})`;
                    if (task.type === 'continuous_target' && totalSeconds >= task.targetTime && task.bonusReward > 0) {
                        amount += task.bonusReward;
                         description += ` + ${formatTime(task.bonusReward)} 达标奖励`;
                    }
                    // [v5.7.0] 修复：continuous/continuous_target 类型的习惯任务补录也需要触发 rebuildHabitStreak
                    if (task.isHabit) {
                        didHabitBackdate = true;
                    }

                } else if (task.type === 'continuous_redeem') {
                    transactionType = 'spend';
                    const netChangeSinceThen = transactions
                        .filter(t => new Date(t.timestamp) > backdateTimestamp)
                        .reduce((sum, t) => sum + (t.type === 'earn' ? t.amount : -t.amount), 0);
                    const historicalBalance = currentBalance - netChangeSinceThen;
                    const isPenalty = historicalBalance < 0;

                    amount = Math.floor(totalSeconds * task.multiplier);
                    if (isPenalty) {
                        amount = Math.floor(amount * 1.2);
                        description += ` (${formatTime(totalSeconds)} × ${task.multiplier}) (历史余额不足, 1.2倍消耗)`;
                    } else {
                        description += ` (${formatTime(totalSeconds)} × ${task.multiplier})`;
                    }
                }
                
                if (amount <= 0 && !didHabitBackdate) { 
                    showAlert('计算出的时间量为0，无法补录'); hasError = true; break; 
                }
                
                // --- Add Transaction (for non-habit reward tasks) ---
                addTransaction({ 
                    type: transactionType, 
                    taskId: task.id, 
                    taskName: task.name, 
                    amount: amount, 
                    description: description, 
                    timestamp: backdateTimestamp.toISOString(),
                    isBackdate: true,
                    isStreakAdvancement: false // [v4.3.0] ALWAYS false, rebuild will set it
                });
                
                if (transactionType === 'earn') { currentBalance += amount; totalAmountEarned += amount; updateDailyChanges('earned', amount, backdateTimestamp); } 
                else { currentBalance -= amount; totalAmountSpent += amount; updateDailyChanges('spent', amount, backdateTimestamp); }
                task.completionCount = (task.completionCount || 0) + 1;
            }
            // --- End processing loop ---

            // [v4.3.0] Trigger rebuild AFTER all transactions are added
            if (didHabitBackdate) {
                rebuildHabitStreak(task);
            }

            if (hasError) {
                // If we hit an error (like daily limit), we still save changes made up to that point
                saveData(); updateAllUI();
                return;
            }
            
            saveData(); updateAllUI(); hideBackdateModal();
            let notifyMsg = `成功为 ${dateStr} 
                            补录 ${task.name}`;
            if (completionCount > 1) notifyMsg += ` ${completionCount} 次`;
            if (totalAmountEarned > 0) notifyMsg += ` (获得 ${formatTime(totalAmountEarned)})`;
            if (totalAmountSpent > 0) notifyMsg += ` (消费 ${formatTime(totalAmountSpent)})`;
            showNotification('📆 补录成功', notifyMsg, 'achievement');
        }
// [v4.3.0] New Function: Rebuilds habit streak from scratch based on transaction history
// [v4.3.1] Fix: Corrected date parsing to be timezone-safe
function rebuildHabitStreak(task) {
    if (!task || !task.isHabit) return;

    console.log(`Rebuilding streak for: ${task.name}`);

    // 1. Get all relevant transactions, sorted oldest-to-newest
    const taskTransactions = transactions
        .filter(t => t.taskId === task.id && t.type === 'earn')
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

    // 2. Reset all streak advancement markers for this task
    transactions.forEach(t => {
        if (t.taskId === task.id) {
            t.isStreakAdvancement = false;
        }
    });

    // 3. Iterate and rebuild
    let newStreak = 0;
    let lastAdvancementDateStr = null; // The date (YYYY-MM-DD) of the last period that advanced the streak
    let lastAdvancementTransactionId = null;

    const { period, targetCountInPeriod } = task.habitDetails;
    const targetCount = targetCountInPeriod || 1;

    // Group transactions by their period
    const periods = new Map(); // Key: periodStartDateStr, Value: { count: number, lastTx: transaction }
    
    for (const tx of taskTransactions) {
        const txDate = new Date(tx.timestamp);
        
        // [v4.3.0] Get the *start* date of the period this tx belongs to
        let periodStartDate;
        if (period === 'daily') {
            periodStartDate = new Date(txDate.getFullYear(), txDate.getMonth(), txDate.getDate());
        } else if (period === 'weekly') {
            const day = txDate.getDay(); // 0 (Sun) to 6 (Sat)
            const diff = day === 0 ? 6 : day - 1; // Days since Monday (0 if Mon, 6 if Sun)
            periodStartDate = new Date(txDate.getTime() - diff * 86400000);
            periodStartDate.setHours(0, 0, 0, 0);
        } else { // monthly
            periodStartDate = new Date(txDate.getFullYear(), txDate.getMonth(), 1);
        }
        
        const periodKey = getLocalDateString(periodStartDate);
        
        if (!periods.has(periodKey)) {
            periods.set(periodKey, { count: 0, firstTxDate: txDate, advancementTx: null });
        }
        
        const periodData = periods.get(periodKey);
        periodData.count++;
        
        // If this transaction is the one that meets the target, mark it
        if (periodData.count === targetCount) {
            periodData.advancementTx = tx;
        }
    }

    // Now iterate through the periods *in order*
    const sortedPeriodKeys = Array.from(periods.keys()).sort();
    
    // [v5.8.1] 记录需要补发的习惯奖励总额
    let totalBonusAwarded = 0;

    for (const periodKey of sortedPeriodKeys) {
        const periodData = periods.get(periodKey);
        
        // Check if this period met the target
        if (periodData.count >= targetCount) {
            const currentPeriodDate = new Date(periodData.firstTxDate);
            currentPeriodDate.setHours(0, 0, 0, 0);

            if (lastAdvancementDateStr) {
                // Check if this period is consecutive
                // [v4.3.1] Fix: Use timezone-safe date constructor
                const [y, m, d] = lastAdvancementDateStr.split('-').map(Number);
                const lastDate = new Date(y, m - 1, d); // Creates local midnight
                
                const diffDays = (currentPeriodDate - lastDate) / 86400000;
                let isConsecutive = false;

                if (period === 'daily') {
                    isConsecutive = (diffDays === 1);
                } else if (period === 'weekly') {
                    isConsecutive = (diffDays === 7);
                } else if (period === 'monthly') {
                    const lastMonth = lastDate.getFullYear() * 12 + lastDate.getMonth();
                    const currentMonth = currentPeriodDate.getFullYear() * 12 + currentPeriodDate.getMonth();
                    isConsecutive = (currentMonth === lastMonth + 1);
                }
                
                if (isConsecutive) {
                    newStreak++;
                } else {
                    newStreak = 1; // Streak broken, reset to 1
                }
            } else {
                newStreak = 1; // First ever advancement
            }
            
            lastAdvancementDateStr = getLocalDateString(currentPeriodDate);
            
            // Mark the transaction that caused the advancement
            if (periodData.advancementTx) {
                periodData.advancementTx.isStreakAdvancement = true;
                lastAdvancementTransactionId = periodData.advancementTx.id;
                
                // [v5.8.1] 核心修复：计算并补发习惯奖励
                // 计算当前 streak 对应的习惯奖励
                let habitBonusReward = 0;
                if (task.habitDetails.rewards && task.habitDetails.rewards.length > 0) {
                    task.habitDetails.rewards.forEach(rule => {
                        if (newStreak >= rule.start) {
                            let ruleReward = (rule.type === 'fixed') ? rule.value : (rule.value * newStreak);
                            // 应用递增奖励上限
                            if (rule.limit && ruleReward > rule.limit) {
                                ruleReward = rule.limit;
                            }
                            habitBonusReward += ruleReward;
                        }
                    });
                }
                
                // 检查该交易是否已包含习惯奖励
                const tx = periodData.advancementTx;
                const baseReward = task.fixedTime || (task.type === 'continuous' || task.type === 'continuous_target' ? tx.amount : 0);
                
                // 如果交易描述中没有"习惯奖励"字样，说明需要补发
                if (habitBonusReward > 0 && !tx.description.includes('习惯奖励')) {
                    const oldAmount = tx.amount;
                    tx.amount = oldAmount + habitBonusReward;
                    tx.description += ` (含习惯奖励 ${formatTime(habitBonusReward)})`;
                    
                    // 更新余额和每日统计
                    currentBalance += habitBonusReward;
                    updateDailyChanges('earned', habitBonusReward, new Date(tx.timestamp));
                    totalBonusAwarded += habitBonusReward;
                    
                    console.log(`🎁 补发习惯奖励: ${task.name} 第${newStreak}次连续, +${formatTime(habitBonusReward)}`);
                }
            }
        }
    }
    
    // [v5.8.1] 如果有补发奖励，显示通知
    if (totalBonusAwarded > 0) {
        showNotification('🎁 习惯奖励补发', `${task.name} 补发习惯连续奖励 ${formatTime(totalBonusAwarded)}`, 'achievement');
    }
    
    // 4. Apply new state
    task.habitDetails.streak = newStreak;
    
    // Find the actual timestamp of the last advancement
    if (lastAdvancementTransactionId) {
        const lastTx = transactions.find(t => t.id === lastAdvancementTransactionId);
        if (lastTx) {
            task.habitDetails.lastCompletionDate = getLocalDateString(lastTx.timestamp);
        } else {
            task.habitDetails.lastCompletionDate = null; // Should not happen
        }
    } else {
        task.habitDetails.lastCompletionDate = null;
    }

    // 5. Set UI status
    // Check streak against "today" to set isBroken flag for UI
    checkHabitStreak(task, new Date());
    console.log(`Rebuild complete. New streak: ${newStreak}, Last advancement: ${task.habitDetails.lastCompletionDate}`);
}
// --- SCRIPT BLOCK 2/3 END --- </script>
<script> // --- SCRIPT BLOCK 3/3 START ---
        // [v4.5.5] 修复: 优化高亮逻辑
        function highlightIncompleteHabits() {
            clearTimeout(highlightTimer);
            highlightedHabits.clear();
            let incompleteCount = 0;
            const todayStr = getLocalDateString(new Date()); // [v4.5.5] Get today's date

            tasks.forEach(task => {
                if (task.isHabit) {
                    // [v4.4.0] 仅检查“获得”类习惯，因为“消费”类习惯没有完成/连续的概念
                    if (['reward', 'continuous', 'continuous_target'].includes(task.type)) {
                        const { currentCount, targetCount } = getHabitPeriodInfo(task, transactions, new Date());
                        
                        // [v4.5.5] 检查: 1. 周期未达标
                        if (currentCount < targetCount) {
                            
                            // [v4.5.5] 检查: 2. 今日未达上限
                            const dailyLimit = task.habitDetails.dailyLimit || 1;
                            const completionsToday = transactions.filter(t => t.taskId === task.id && getLocalDateString(t.timestamp) === todayStr).length;

                            if (completionsToday < dailyLimit) {
                                highlightedHabits.add(task.id); // 存储到状态中
                                incompleteCount++;
                            }
                        }
                    }
                }
            });
            
            updateAllUI(); // 触发重绘，让高亮生效
            
            if (incompleteCount > 0) {
                 showNotification('✨ 已高亮', `共 ${incompleteCount} 个未完成习惯已标红`, 'achievement');
            } else {
                 showNotification('👍 全部完成', '所有习惯均已完成！', 'achievement');
            }

            // 30 分钟后清空状态并重绘
            highlightTimer = setTimeout(() => {
                highlightedHabits.clear();
                updateAllUI(); // 再次重绘，移除高亮
                showNotification('⏰ 提醒', '习惯高亮已自动取消', 'achievement');
            }, 1800000); // 30 分钟
        }

        // --- Data Handling ---
        function addTransaction(transaction) { 
            transaction.timestamp = transaction.timestamp || new Date().toISOString(); 
            transaction.id = Date.now().toString() + Math.random().toString(36).substr(2, 9); 
            // [v3.18.0] isStreakAdvancement is optional
            transaction.isStreakAdvancement = transaction.isStreakAdvancement || false;
            transactions.unshift(transaction); 
            // [v4.2.0] Re-sort transactions after adding, vital for backdating
            transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); 
        }
        function updateDailyChanges(type, amount, date = new Date()) { const dateString = date.toDateString(); if (!dailyChanges[dateString]) dailyChanges[dateString] = { earned: 0, spent: 0 }; dailyChanges[dateString][type] += amount; }
        
        // --- Reports Tab ---
        function setupReportEventListeners() { 
            document.getElementById('heatmapPrevMonth').addEventListener('click', () => navigateHeatmap(-1)); 
            document.getElementById('heatmapNextMonth').addEventListener('click', () => navigateHeatmap(1)); 
        }
        function updateAllReports() { 
            updateActivityHeatmap(); 
            updateAnalysisDashboard(); 
            updateDetailedDataTable(); 
            updateTrendChart(); 
        }

        // [v5.2.0] 获取 transaction 的分类（支持系统任务）
        // [v5.10.0] 支持屏幕时间的自定义分类
        function getTransactionCategory(t) {
            // 系统任务处理
            if (t.isSystem) {
                // [v5.10.0] 屏幕时间支持自定义分类
                if (t.systemType === 'screen-time') {
                    // 优先使用交易记录中保存的分类
                    if (t.category) return t.category;
                    // 其次使用当前设置
                    if (t.type === 'earn' && screenTimeSettings.earnCategory) {
                        return screenTimeSettings.earnCategory;
                    }
                    if (t.type === 'spend' && screenTimeSettings.spendCategory) {
                        return screenTimeSettings.spendCategory;
                    }
                }
                return SYSTEM_CATEGORY;
            }
            // 普通任务从 tasks 数组查找
            const task = tasks.find(tsk => tsk.id === t.taskId);
            return task ? task.category : '未知';
        }

        // [v5.2.0] 安全获取分类颜色（支持系统分类）
        function getCategoryColorSafe(category) {
            if (category === SYSTEM_CATEGORY) {
                return SYSTEM_CATEGORY_COLOR;
            }
            return categoryColors.get(category) || '#888';
        }

        function getFilteredTransactions(period, sortBy = 'desc') { 
            let filtered = transactions.filter(t => !t.undone);
            if (period !== 'all') {
                const now = new Date(); 
                let startDate; 
                if (period === '1d') startDate = new Date(new Date().setDate(now.getDate() - 1)); 
                else if (period === '3d') startDate = new Date(new Date().setDate(now.getDate() - 3)); 
                else if (period === '7d') startDate = new Date(new Date().setDate(now.getDate() - 7)); 
                else if (period === '30d') startDate = new Date(new Date().setDate(now.getDate() - 30)); 
                filtered = filtered.filter(t => new Date(t.timestamp) >= startDate);
            }
            filtered.sort((a, b) => (sortBy === 'asc' ? new Date(a.timestamp) - new Date(b.timestamp) : new Date(b.timestamp) - new Date(a.timestamp)));
            return filtered; 
        }
        
        // [v5.8.0] 格式化时间为 HH:MM
        function formatTimeHM(date) {
            const d = new Date(date);
            return d.getHours().toString().padStart(2, '0') + ':' + d.getMinutes().toString().padStart(2, '0');
        }

        // [v5.8.0] 从交易描述中提取真实时长（倍率换算前）
        function extractRealDurationFromTransaction(t, task) {
            // 尝试从 description 中解析 "(时长 × 倍率)" 格式
            if (t.description) {
                const match = t.description.match(/\(([^)]+)\s*×\s*[\d.]+\)/);
                if (match) {
                    const realSeconds = parseDurationTextToSeconds(match[1]);
                    if (realSeconds > 0) return realSeconds;
                }
            }
            
            // 如果解析失败，尝试通过任务倍率反推
            if (task && task.multiplier && task.multiplier > 0) {
                // 连续类任务：amount = 真实时长 × 倍率
                if (['continuous', 'continuous_target', 'continuous_redeem'].includes(task.type)) {
                    return Math.abs(t.amount) / task.multiplier;
                }
            }
            
            // 其他情况（奖励任务、即时消费等）：amount 就是真实时长
            return Math.abs(t.amount);
        }

        // [v5.8.0] 多天连续时间流图状态
        let multiDayFlowState = {
            currentDate: null,   // 当前显示的日期
            oldestDate: null,    // 最早加载的日期
            newestDate: null,    // 最新加载的日期
            isLoading: false     // 防止重复加载
        };

        // [v5.8.0] 获取多天时间段数据（不截断跨午夜任务）
        function getMultiDayFlowSlots(endDate, days) {
            const slots = [];
            const SHORT_PAUSE_THRESHOLD = 10 * 60 * 1000;
            const processedTransactions = new Set(); // 防止重复处理
            
            // 计算日期范围
            const startDate = new Date(endDate);
            startDate.setDate(startDate.getDate() - days + 1);
            startDate.setHours(0, 0, 0, 0);
            const endDateTime = new Date(endDate);
            endDateTime.setHours(23, 59, 59, 999);
            
            // 获取范围内所有交易（包括开始时间可能在范围外的跨天任务）
            // 扩展搜索范围：往前多搜1天以捕获跨午夜任务
            const searchStart = new Date(startDate);
            searchStart.setDate(searchStart.getDate() - 1);
            
            transactions.filter(t => {
                if (t.undone) return false;
                const tDate = new Date(t.timestamp);
                // 交易结束时间在搜索范围内
                return tDate >= searchStart && tDate <= endDateTime;
            }).forEach(t => {
                if (processedTransactions.has(t.id)) return;
                processedTransactions.add(t.id);
                
                const task = tasks.find(tsk => tsk.id === t.taskId);
                if (!task && !t.isSystem) return;
                if (t.isSystem) return;
                if (t.description && (t.description.startsWith('自动补录:') || t.description.startsWith('自动修正:'))) return;
                
                const endTime = new Date(t.timestamp);
                const realDurationSeconds = extractRealDurationFromTransaction(t, task);
                const taskStartTime = new Date(endTime.getTime() - realDurationSeconds * 1000);
                
                // 检查任务是否与显示范围有交集
                if (endTime < startDate || taskStartTime > endDateTime) return;
                
                const color = getCategoryColorSafe(getTransactionCategory(t));
                const taskName = task?.name || '未知任务';
                const isSpend = task && ['instant_redeem', 'continuous_redeem'].includes(task.type);
                
                // 处理暂停历史
                if (t.pauseHistory && t.pauseHistory.length > 0) {
                    const significantPauses = t.pauseHistory.filter(p => 
                        p.pauseEnd && (p.pauseEnd - p.pauseStart) >= SHORT_PAUSE_THRESHOLD
                    );
                    
                    if (significantPauses.length === 0) {
                        addMultiDaySlot(slots, t, taskStartTime, endTime, taskName, color, isSpend, 'only', null, null, startDate, endDateTime);
                    } else {
                        let currentStart = taskStartTime;
                        const totalSegments = significantPauses.length + 1;
                        
                        for (let i = 0; i < significantPauses.length; i++) {
                            const pause = significantPauses[i];
                            const pauseStart = new Date(pause.pauseStart);
                            const pauseEnd = new Date(pause.pauseEnd);
                            const segmentType = i === 0 ? 'first' : 'middle';
                            
                            if (pauseStart > currentStart) {
                                addMultiDaySlot(slots, t, currentStart, pauseStart, taskName, color, isSpend, segmentType,
                                    null, formatTimeHM(pauseStart), startDate, endDateTime, i, totalSegments, pause.pauseStart, pause.pauseEnd);
                            }
                            currentStart = pauseEnd;
                        }
                        
                        if (currentStart < endTime) {
                            const lastPause = significantPauses[significantPauses.length - 1];
                            addMultiDaySlot(slots, t, currentStart, endTime, taskName, color, isSpend, 'last',
                                formatTimeHM(new Date(lastPause.pauseEnd)), null, startDate, endDateTime, significantPauses.length, totalSegments);
                        }
                    }
                } else {
                    addMultiDaySlot(slots, t, taskStartTime, endTime, taskName, color, isSpend, 'only', null, null, startDate, endDateTime);
                }
            });
            
            return slots.sort((a, b) => a.start - b.start);
        }
        
        // 辅助函数：添加多天时间段（不截断）
        function addMultiDaySlot(slots, t, startTime, endTime, taskName, color, isSpend, segmentType, resumeTime, pauseTime, rangeStart, rangeEnd, segmentIndex = 0, totalSegments = 1, pauseStartTs = null, pauseEndTs = null) {
            // 裁剪到显示范围（但不按天截断）
            let slotStart = new Date(Math.max(startTime.getTime(), rangeStart.getTime()));
            let slotEnd = new Date(Math.min(endTime.getTime(), rangeEnd.getTime()));
            
            if (slotEnd <= slotStart) return;
            
            // 原始任务完整时长（用于判断是否显示时间标签）
            const originalDurationMinutes = (endTime - startTime) / (60 * 1000);
            
            slots.push({
                id: t.id + (segmentIndex > 0 ? '_seg' + segmentIndex : ''),
                taskId: t.taskId,
                transactionId: t.id,
                start: slotStart,
                end: slotEnd,
                originalStart: startTime, // 保留原始时间用于显示
                originalEnd: endTime,
                durationSeconds: Math.abs(t.amount),
                realDurationSeconds: (slotEnd - slotStart) / 1000,
                durationMinutes: originalDurationMinutes, // 使用原始时长判断显示
                taskName,
                color,
                isSpend,
                segmentType,
                segmentIndex,
                totalSegments,
                resumeTime,
                pauseTime,
                pauseStartTs,
                pauseEndTs
            });
        }

        // [v5.8.0] 获取当天时间段数据
        function getFlowTimeSlots(date) {
            const dateStr = getLocalDateString(date);
            const slots = [];
            const SHORT_PAUSE_THRESHOLD = 10 * 60 * 1000; // 10分钟阈值
            
            transactions.filter(t => !t.undone && getLocalDateString(t.timestamp) === dateStr)
                .forEach(t => {
                    const task = tasks.find(tsk => tsk.id === t.taskId);
                    const isSpend = task && ['instant_redeem', 'continuous_redeem'].includes(task.type);
                    // 排除系统任务和无任务关联的交易（如时间调整）
                    if (!task && !t.isSystem) return;
                    // 排除系统任务
                    if (t.isSystem) return;
                    // 排除自动补录的漏记和多记
                    if (t.description && (t.description.startsWith('自动补录:') || t.description.startsWith('自动修正:'))) return;
                    
                    const endTime = new Date(t.timestamp);
                    const realDurationSeconds = extractRealDurationFromTransaction(t, task);
                    let taskStartTime = new Date(endTime.getTime() - realDurationSeconds * 1000);
                    
                    const color = getCategoryColorSafe(getTransactionCategory(t));
                    const taskName = task?.name || (t.isSystem ? '系统任务' : '未知任务');
                    
                    // [v5.8.0] 如果有 pauseHistory，构建活动段和暂停区间
                    if (t.pauseHistory && t.pauseHistory.length > 0) {
                        // 先过滤/合并短暂停（<10分钟）
                        const significantPauses = [];
                        for (const pause of t.pauseHistory) {
                            if (!pause.pauseEnd) continue; // 跳过未结束的暂停
                            const pauseDuration = pause.pauseEnd - pause.pauseStart;
                            if (pauseDuration >= SHORT_PAUSE_THRESHOLD) {
                                significantPauses.push(pause);
                            }
                        }
                        
                        if (significantPauses.length === 0) {
                            // 所有暂停都<10分钟，视为连续任务
                            addSingleSlot(slots, t, taskStartTime, endTime, taskName, color, isSpend, dateStr, date, 'only', null, null);
                        } else {
                            // 有显著暂停，拆分为多段
                            let currentStart = taskStartTime;
                            const totalSegments = significantPauses.length + 1;
                            
                            for (let i = 0; i < significantPauses.length; i++) {
                                const pause = significantPauses[i];
                                const pauseStart = new Date(pause.pauseStart);
                                const pauseEnd = new Date(pause.pauseEnd);
                                const segmentType = i === 0 ? 'first' : 'middle';
                                
                                // 添加活动段
                                if (pauseStart > currentStart) {
                                    addSingleSlot(slots, t, currentStart, pauseStart, taskName, color, isSpend, dateStr, date, segmentType, 
                                        null, formatTimeHM(new Date(pause.pauseStart)), i, totalSegments, pause.pauseStart, pauseEnd.getTime());
                                }
                                currentStart = pauseEnd;
                            }
                            
                            // 最后一段
                            if (currentStart < endTime) {
                                const lastPause = significantPauses[significantPauses.length - 1];
                                addSingleSlot(slots, t, currentStart, endTime, taskName, color, isSpend, dateStr, date, 'last',
                                    formatTimeHM(new Date(lastPause.pauseEnd)), null, significantPauses.length, totalSegments, null, null);
                            }
                        }
                    } else {
                        // 无暂停历史，单独一段
                        addSingleSlot(slots, t, taskStartTime, endTime, taskName, color, isSpend, dateStr, date, 'only', null, null);
                    }
                });
            
            return slots.sort((a, b) => a.start - b.start);
        }
        
        // 辅助函数：添加单个时间段
        function addSingleSlot(slots, t, startTime, endTime, taskName, color, isSpend, dateStr, date, segmentType, resumeTime, pauseTime, segmentIndex = 0, totalSegments = 1, pauseStartTs = null, pauseEndTs = null) {
            const startDateStr = getLocalDateString(startTime);
            const endDateStr = getLocalDateString(endTime);
            
            // 跨天处理
            if (startDateStr !== dateStr && endDateStr !== dateStr) return; // 不在当天
            
            let slotStart = startTime;
            let slotEnd = endTime;
            
            if (startDateStr !== dateStr) {
                slotStart = new Date(date);
                slotStart.setHours(0, 0, 0, 0);
            }
            if (endDateStr !== dateStr) {
                slotEnd = new Date(date);
                slotEnd.setHours(23, 59, 59, 999);
            }
            
            if (slotEnd <= slotStart) return;
            
            // 原始任务完整时长（用于判断是否显示时间标签）
            const originalDurationMinutes = (endTime - startTime) / (60 * 1000);
            
            slots.push({
                id: t.id + (segmentIndex > 0 ? '_seg' + segmentIndex : ''),
                taskId: t.taskId,
                transactionId: t.id,
                start: slotStart,
                end: slotEnd,
                durationSeconds: Math.abs(t.amount),
                realDurationSeconds: (slotEnd - slotStart) / 1000,
                durationMinutes: originalDurationMinutes, // 使用原始时长判断显示
                taskName,
                color,
                isSpend,
                segmentType,    // 'only', 'first', 'middle', 'last'
                segmentIndex,
                totalSegments,
                resumeTime,     // 继续时间（用于middle/last段顶部）
                pauseTime,      // 暂停时间（用于first/middle段底部）
                pauseStartTs,   // 暂停开始时间戳（用于列占用）
                pauseEndTs      // 暂停结束时间戳（用于列占用）
            });
        }

        // [v5.8.0] 分配列（固定3列，暂停区间保护，时长排序，超3条忽略）
        function assignFlowColumns(slots) {
            const MAX_COLS = 3;
            // 每列维护占用区间列表 [{start, end}, ...]
            const columnOccupied = [[], [], []];
            
            // 辅助函数：检查时间段是否与列的占用区间重叠
            function isOverlapping(colIndex, start, end) {
                return columnOccupied[colIndex].some(interval => 
                    !(end.getTime() <= interval.start || start.getTime() >= interval.end)
                );
            }
            
            // 辅助函数：添加占用区间
            function addOccupied(colIndex, start, end) {
                columnOccupied[colIndex].push({ start: start.getTime(), end: end.getTime() });
            }
            
            // 1. 按开始时间排序，同开始时间按时长降序
            slots.sort((a, b) => {
                const startDiff = a.start - b.start;
                if (startDiff !== 0) return startDiff;
                return b.durationMinutes - a.durationMinutes; // 时长大的优先
            });
            
            // 2. 分配列
            const assignedSlots = [];
            slots.forEach(slot => {
                // 计算此slot的完整占用区间（包括暂停虚线区域）
                let occupyEnd = slot.end;
                if (slot.pauseEndTs && slot.segmentType !== 'last') {
                    occupyEnd = new Date(slot.pauseEndTs);
                }
                
                // 找到可用列
                let assigned = false;
                for (let col = 0; col < MAX_COLS; col++) {
                    if (!isOverlapping(col, slot.start, occupyEnd)) {
                        slot.column = col;
                        addOccupied(col, slot.start, occupyEnd);
                        assigned = true;
                        assignedSlots.push(slot);
                        break;
                    }
                }
                
                // 所有列都被占用，忽略此slot
                if (!assigned) {
                    slot.column = -1; // 标记为被忽略
                }
            });
            
            // 过滤掉被忽略的slots
            slots.length = 0;
            assignedSlots.forEach(s => slots.push(s));
            
            // 重新按开始时间排序（恢复显示顺序）
            slots.sort((a, b) => a.start - b.start);
            
            return 3; // 固定返回3列
        }

        // [v5.8.0] 找出同一任务的暂停-继续连接（仅同一transactionId内的段）
        function findFlowPauseConnections(slots) {
            const connections = [];
            const transactionSlots = new Map();
            
            slots.forEach(slot => {
                if (!slot.transactionId) return;
                if (!transactionSlots.has(slot.transactionId)) {
                    transactionSlots.set(slot.transactionId, []);
                }
                transactionSlots.get(slot.transactionId).push(slot);
            });
            
            transactionSlots.forEach((slotList) => {
                if (slotList.length < 2) return;
                slotList.sort((a, b) => a.start - b.start);
                for (let i = 0; i < slotList.length - 1; i++) {
                    connections.push({
                        from: slotList[i],
                        to: slotList[i + 1],
                        color: slotList[i].color
                    });
                }
            });
            
            return connections;
        }

        function navigateHeatmap(offset) { reportState.heatmapDate.setMonth(reportState.heatmapDate.getMonth() + offset); updateActivityHeatmap(); }
        function updateActivityHeatmap() { 
            const container = document.getElementById('heatmapGrid'); 
            const legendContainer = document.getElementById('heatmapLegend'); 
            const label = document.getElementById('heatmapMonthLabel'); 
            const dailyData = new Map(); 
            transactions.filter(t => !t.undone).forEach(t => { 
                const localDateStr = getLocalDateString(t.timestamp); 
                if (!dailyData.has(localDateStr)) { 
                    dailyData.set(localDateStr, { earned: 0, spent: 0, count: 0 }); 
                } 
                const dayData = dailyData.get(localDateStr);
                dayData.count++;
                if (t.type) { 
                    const typeKey = t.type === 'earn' ? 'earned' : 'spent'; 
                    dayData[typeKey] += t.amount; 
                } else { 
                    if (t.amount > 0) dayData.earned += t.amount; 
                    else dayData.spent += Math.abs(t.amount); 
                } 
            }); 
            const year = reportState.heatmapDate.getFullYear(); 
            const month = reportState.heatmapDate.getMonth(); 
            label.textContent = `${year}年 ${month + 1}月`; 
            const firstDayOfMonth = new Date(year, month, 1).getDay(); 
            const daysInMonth = new Date(year, month + 1, 0).getDate(); 
            let html = ''; 
            for(let i = 0; i < firstDayOfMonth; i++) { 
                html += `<div class="heatmap-spacer"></div>`; 
            } 
            for (let day = 1; day <= daysInMonth; day++) { 
                const currentDate = new Date(year, month, day); 
                const localDateStr = getLocalDateString(currentDate); 
                const data = dailyData.get(localDateStr); 
                let colorClass = ''; 
                let tooltipContent = '';
                
                if (data) { 
                    const net = data.earned - data.spent; 
                    colorClass = getHeatmapColorClass(net);
                    const netClass = net > 0 ? 'positive' : (net < 0 ? 'negative' : '');
                    const netSign = net > 0 ? '+' : '';
                    tooltipContent = `<div class="heatmap-tooltip-date">${localDateStr}</div>` +
                        `<div class="heatmap-tooltip-net ${netClass}">${netSign}${formatTime(net)}</div>` +
                        `<div class="heatmap-tooltip-stats">获得 ${formatTime(data.earned)}</div>` +
                        `<div class="heatmap-tooltip-stats">消费 ${formatTime(data.spent)}</div>` +
                        `<div class="heatmap-tooltip-stats">${data.count} 条记录</div>` +
                        `<div class="heatmap-tooltip-hint">长按 3 秒自动查看详情</div>` +
                        `<div class="heatmap-tooltip-progress"></div>`;
                } else {
                    tooltipContent = `<div class="heatmap-tooltip-date">${localDateStr}</div>` +
                        `<div class="heatmap-tooltip-stats" style="opacity:0.7">暂无活动记录</div>`;
                }
                
                const encodedTooltip = encodeURIComponent(tooltipContent);
                html += `<div class="heatmap-day" data-date="${localDateStr}" data-tooltip="${encodedTooltip}"><div class="heatmap-day-content ${colorClass}">${day}</div></div>`; 
            } 
            container.innerHTML = html; 
            const nextMonth = new Date(year, month + 1, 1); 
            document.getElementById('heatmapNextMonth').disabled = nextMonth > new Date(); 
            legendContainer.innerHTML = `减少 <div class="legend-item"><div class="legend-box" style="background-color: #ffcdd2;"></div><div class="legend-box" style="background-color: #e57373;"></div><div class="legend-box" style="background-color: #f44336;"></div></div> | <div class="legend-item"><div class="legend-box" style="background-color: #9be9a8;"></div><div class="legend-box" style="background-color: #40c463;"></div><div class="legend-box" style="background-color: #216e39;"></div></div> 增加`; 
            // 初始化长按交互
            initHeatmapTooltips();
        }
        
        // [v5.6.0] 将“1小时30分45秒/30分/45秒/1h30m”解析为秒
        function parseDurationTextToSeconds(text) {
            if (!text) return 0;
            let total = 0;
            const h = text.match(/(\d+)\s*(小时|时|h)/i);
            const m = text.match(/(\d+)\s*(分钟|分|m)/i);
            const s = text.match(/(\d+)\s*(秒|s)/i);
            if (h) total += parseInt(h[1], 10) * 3600;
            if (m) total += parseInt(m[1], 10) * 60;
            if (s) total += parseInt(s[1], 10);
            return total;
        }

        // [v5.6.0] 解析交易描述，分离标题和详情
        // [v5.7.0] 新增 isBackdate, isTarget, hasHabitBonus 标记
        function parseTransactionDescription(transaction) {
            const desc = transaction.description;
            let title = '';
            let detail = '';
            let icon = ''; // 主图标
            let warning = false; // 是否有负余额警告
            let isBackdate = false; // 是否为手动补录
            let isTarget = false; // 是否为达标任务
            let hasHabitBonus = false; // 是否包含习惯奖励
            
            // 检测通用标记
            isBackdate = desc.startsWith('补录:');
            isTarget = desc.includes('达标奖励');
            hasHabitBonus = desc.includes('含习惯奖励');
            
            // 屏幕时间特殊处理
            // 格式: 📱 屏幕时间: 4小时29分钟/6小时 (奖励1小时31分钟)
            if (desc.startsWith('📱')) {
                const match = desc.match(/📱\s*屏幕时间:\s*(.+?)\/(.+?)\s*\((奖励|超出)(.+?)\)/);
                if (match) {
                    title = '屏幕时间';
                    const used = match[1].trim();
                    const limit = match[2].trim();
                    const isReward = match[3] === '奖励';
                    const diff = match[4].trim();
                    // 仅显示限额与已用，避免计算结果过长
                    detail = `${used} / ${limit}`;
                } else {
                    title = desc.replace('📱', '').replace('屏幕时间:', '').trim();
                }
                return { title, detail, icon: '📱', warning, isBackdate, isTarget, hasHabitBonus };
            }
            
            // 自动补录: 任务名 (漏记X分钟, ×任务倍率×惩罚倍率) 或 (漏记X分钟, ×惩罚倍率)
            if (desc.startsWith('自动补录:')) {
                // 先尝试匹配新格式: (漏记X分钟, ×任务倍率×惩罚倍率惩罚)
                let match = desc.match(/^自动补录:\s*(.+?)\s*\(漏记(\d+)分钟,\s*[×x]([\d.]+)[×x]([\d.]+)惩罚\)/);
                let taskMultiplier = 1, penaltyMultiplier = 1, minutes = 0;
                if (match) {
                    title = match[1].trim();
                    minutes = parseInt(match[2]);
                    taskMultiplier = parseFloat(match[3]);
                    penaltyMultiplier = parseFloat(match[4]);
                } else {
                    // 尝试匹配旧格式: (漏记X分钟, ×惩罚倍率惩罚)
                    match = desc.match(/^自动补录:\s*(.+?)\s*\(漏记(\d+)分钟,\s*[×x]([\d.]+)惩罚\)/);
                    if (match) {
                        title = match[1].trim();
                        minutes = parseInt(match[2]);
                        penaltyMultiplier = parseFloat(match[3]);
                    }
                }
                if (match) {
                    const result = Math.round(minutes * taskMultiplier * penaltyMultiplier);
                    if (taskMultiplier !== 1) {
                        detail = `漏记${minutes}分 × ${taskMultiplier} × ${penaltyMultiplier} = ${result}分`;
                    } else {
                        detail = `漏记${minutes}分 × ${penaltyMultiplier} = ${result}分`;
                    }
                } else {
                    // fallback: 尝试简单提取任务名
                    const simpleMatch = desc.match(/^自动补录:\s*(.+?)(?:\s*\(|$)/);
                    title = simpleMatch ? simpleMatch[1].trim() : desc.replace('自动补录:', '').trim();
                    // 提取括号内容作为详情
                    const bracketMatch = desc.match(/\(([^)]+)\)/);
                    if (bracketMatch) detail = bracketMatch[1];
                }
                return { title, detail, icon: '🤖', warning, isBackdate: true, isTarget, hasHabitBonus };
            }
            
            // 自动修正: 任务名 (多记录X分钟, ×任务倍率×惩罚倍率返还/扣减) 或 (多记录X分钟, ×惩罚倍率返还/扣减)
            // earn多记 → 扣减(×1.2)，spend多记 → 返还(×0.8)
            if (desc.startsWith('自动修正:')) {
                // 先尝试匹配新格式: (多记录X分钟, ×任务倍率×惩罚倍率返还/扣减)
                let match = desc.match(/^自动修正:\s*(.+?)\s*\(多记录(\d+)分钟,\s*[×x]([\d.]+)[×x]([\d.]+)(返还|扣减)\)/);
                let taskMultiplier = 1, penaltyMultiplier = 1, minutes = 0, actionLabel = '';
                if (match) {
                    title = match[1].trim();
                    minutes = parseInt(match[2]);
                    taskMultiplier = parseFloat(match[3]);
                    penaltyMultiplier = parseFloat(match[4]);
                    actionLabel = match[5] === '扣减' ? '撤回' : '返还';
                } else {
                    // 尝试匹配旧格式: (多记录X分钟, ×惩罚倍率返还/扣减)
                    match = desc.match(/^自动修正:\s*(.+?)\s*\(多记录(\d+)分钟,\s*[×x]([\d.]+)(返还|扣减)\)/);
                    if (match) {
                        title = match[1].trim();
                        minutes = parseInt(match[2]);
                        penaltyMultiplier = parseFloat(match[3]);
                        actionLabel = match[4] === '扣减' ? '撤回' : '返还';
                    }
                }
                if (match) {
                    const result = Math.round(minutes * taskMultiplier * penaltyMultiplier);
                    if (taskMultiplier !== 1) {
                        detail = `多记${minutes}分 × ${taskMultiplier} × ${penaltyMultiplier} = ${result}分${actionLabel}`;
                    } else {
                        detail = `多记${minutes}分 × ${penaltyMultiplier} = ${result}分${actionLabel}`;
                    }
                } else {
                    // fallback: 尝试简单提取任务名
                    const simpleMatch = desc.match(/^自动修正:\s*(.+?)(?:\s*\(|$)/);
                    title = simpleMatch ? simpleMatch[1].trim() : desc.replace('自动修正:', '').trim();
                    // 提取括号内容作为详情
                    const bracketMatch = desc.match(/\(([^)]+)\)/);
                    if (bracketMatch) detail = bracketMatch[1];
                }
                return { title, detail, icon: '🔧', warning, isBackdate: false, isTarget, hasHabitBonus };
            }
            
            // 达标任务（包含"达标奖励"）+ 可能有习惯奖励
            // 例如: "完成习惯: 腿部拉伸 (30分6秒 × 1) + 15分 达标奖励"
            // 例如: "补录: 腿部拉伸 (38分 × 1) + 15分 达标奖励"
            // 例如: "完成习惯: 腿部拉伸 (30分45秒 × 1) + 15分 达标奖励 (含习惯奖励 30分)"
            if (desc.includes('达标奖励')) {
                const match = desc.match(/^[^:]+:\s*(.+?)\s*\(([^)]+)\)\s*\+\s*(.+?)\s*达标奖励(?:\s*\(含习惯奖励\s*(.+?)\))?/);
                if (match) {
                    title = match[1].trim();
                    const timeDetail = match[2].trim();
                    const targetBonus = match[3] ? match[3].trim() : '';
                    const habitBonus = match[4] ? match[4].trim() : '';
                    detail = timeDetail;
                    if (targetBonus) detail += ` +达标${targetBonus}`;
                    if (habitBonus) detail += ` +习惯${habitBonus}`;
                    // [v5.7.0] 主图标固定为达标图标，补录状态通过 isBackdate 传递
                    icon = '🎯';
                }
                return { title, detail, icon, warning, isBackdate, isTarget: true, hasHabitBonus };
            }
            
            // 习惯任务（含习惯奖励但无达标）
            // 例如: "完成习惯: 晚上刷牙 (含习惯奖励 30分)"
            if (desc.includes('含习惯奖励')) {
                const match = desc.match(/^[^:]+:\s*(.+?)\s*\(含习惯奖励\s*(.+?)\)/);
                if (match) {
                    title = match[1].trim();
                    const habitBonusText = match[2].trim();
                    // 计算基础奖励 = 总秒数 - 习惯奖励秒数
                    const habitSeconds = parseDurationTextToSeconds(habitBonusText);
                    const baseSeconds = Math.max(transaction.amount - habitSeconds, 0);
                    detail = `${formatTime(baseSeconds)} +习惯${habitBonusText}`;
                }
                return { title, detail, icon, warning, isBackdate, isTarget, hasHabitBonus: true };
            }
            
            // 普通习惯（无任何奖励）或 reward 类型
            // 例如: "完成习惯: 哑铃站姿弯举"
            // 例如: "完成任务: 阅读30分钟"
            if (desc.startsWith('完成习惯:') || desc.startsWith('完成任务:')) {
                const match = desc.match(/^[^:]+:\s*(.+?)(?:\s*\(|$)/);
                if (match) {
                    title = match[1].trim();
                    // 检查是否有括号内容（如时间×倍率）
                    const bracketMatch = desc.match(/\(([^)]+)\)/);
                    if (bracketMatch) {
                        detail = bracketMatch[1].trim();
                    } else {
                        // 无括号，显示获得的时间
                        detail = formatTime(transaction.amount);
                    }
                }
                return { title, detail, icon, warning, isBackdate, isTarget, hasHabitBonus };
            }
            
            // 检测负余额惩罚
            const hasPenalty = desc.includes('余额不足') || desc.includes('历史余额不足');
            if (hasPenalty) warning = true;
            
            // 通用格式: "前缀: 任务名 (详情1) (详情2)..."
            // 例如: "完成任务: 腿部拉伸 (30分6秒 × 1.0)"
            // 例如: "补录: 看视频 (30分 × 1.0) (历史余额不足, 1.2倍消耗)"
            // 例如: "兑换项目: 涩涩 (余额不足, 1.2倍消耗)"
            const mainMatch = desc.match(/^([^:]+):\s*(.+)$/);
            if (mainMatch) {
                const prefix = mainMatch[1].trim(); // 完成任务、补录、兑换项目等
                let rest = mainMatch[2].trim();
                
                // 提取所有括号内容
                const bracketMatches = rest.match(/\([^)]+\)/g) || [];
                // 任务名是括号之前的部分
                const taskName = rest.replace(/\s*\([^)]+\)/g, '').trim();
                
                title = taskName;
                
                // 合并括号内容作为详情
                if (bracketMatches.length > 0) {
                    // 去掉括号
                    let details = bracketMatches.map(b => b.slice(1, -1));
                    
                    // 检查是否有负余额惩罚：(时间 × 倍率) + (余额不足, 1.2倍消耗)
                    const timeMatch = details[0] ? details[0].match(/^(.+?)\s*[×x]\s*([\d.]+)$/) : null;
                    const penaltyMatch = details.find(d => d.includes('余额不足') || d.includes('历史余额不足'));
                    
                    if (timeMatch && penaltyMatch) {
                        // 合并为: 时间 × 倍率 × 1.2
                        const penaltyMultiplier = penaltyMatch.match(/([\d.]+)倍/);
                        const penalty = penaltyMultiplier ? penaltyMultiplier[1] : '1.2';
                        detail = `${timeMatch[1]} × ${timeMatch[2]} × ${penalty}`;
                    } else if (penaltyMatch && details.length === 1) {
                        // 只有惩罚信息（兑换类型）：用 transaction.amount 计算原始时长
                        const penaltyMultiplier = penaltyMatch.match(/([\d.]+)倍/);
                        const penalty = penaltyMultiplier ? parseFloat(penaltyMultiplier[1]) : 1.2;
                        // 原始时长 = 实际消耗 / 惩罚倍率
                        const originalAmount = Math.round(transaction.amount / penalty);
                        detail = `${formatTime(originalAmount)} × ${penalty}`;
                    } else {
                        // 普通情况，用 · 连接
                        detail = details.join(' · ')
                            .replace(/历史余额不足,\s*/g, '')
                            .replace(/余额不足,\s*/g, '')
                            .replace(/[\d.]+倍消耗/g, '')
                            .replace(/含习惯奖励\s*/g, '+奖励')
                            .trim();
                        // 清理多余的 · 
                        detail = detail.replace(/\s*·\s*$/g, '').replace(/^\s*·\s*/g, '');
                    }
                }
            } else {
                // 无前缀格式，直接使用
                title = desc;
            }
            
            return { title, detail, icon, warning, isBackdate, isTarget, hasHabitBonus };
        }

        // [原版] 活动日历的每日详情（交易列表版）
        function showDayDetails(localDateStr) { 
            const modal = document.getElementById('dayDetailModal'); 
            modal.classList.remove('flow-mode'); // [v6.3.3] 退出流图模式
            const title = document.getElementById('dayDetailModalTitle'); 
            const content = document.getElementById('dayDetailContent'); 
            
            // [v5.8.0] 清除可能残留的滚动事件处理器（时间流图设置的）
            content.onscroll = null;
            
            // [v6.3.3] 增加切回时间流图的按钮
            title.innerHTML = `
                <div style="display:flex; align-items:center;">
                     <button class="view-switch-btn" onclick="event.stopPropagation();showDayFlowChart('${localDateStr}')" title="切换到时间流图">⇄</button>
                     <span>${localDateStr} 详情</span>
                </div>
            `;
            // title.textContent = `${localDateStr} 详情`; 
            
            const dayTransactions = transactions.filter(t => !t.undone && getLocalDateString(t.timestamp) === localDateStr).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));  
            if (dayTransactions.length === 0) { 
                content.innerHTML = '<div class="empty-message">本日无活动记录</div>'; 
                modal.classList.add('show'); 
                return; 
            } 
            const dailyEarned = dayTransactions.reduce((sum, t) => sum + (t.type === 'earn' ? t.amount : (!t.type && t.amount > 0 ? t.amount : 0)), 0); 
            const dailySpent = dayTransactions.reduce((sum, t) => sum + (t.type === 'spend' ? t.amount : (!t.type && t.amount < 0 ? Math.abs(t.amount) : 0)), 0); 
            const dailyNet = dailyEarned - dailySpent; 
            const netClass = dailyNet > 0 ? 'positive' : (dailyNet < 0 ? 'negative' : ''); 
            const netSign = dailyNet > 0 ? '+' : (dailyNet < 0 ? '' : ''); 
            let summaryHtml = `<div class="day-detail-summary">
                                <div class="day-detail-net ${netClass}">净值: ${netSign}${formatTime(dailyNet)}</div>
                                <div class="day-detail-stats">
                                    <span>获得: <span class="positive">${formatTime(dailyEarned)}</span></span> | 
                                    <span>消费: <span class="negative">${formatTime(dailySpent)}</span></span>
                                </div>
                            </div>`; 
            let listHtml = dayTransactions.map(transaction => { 
                const isPositive = transaction.type === 'earn' || (!transaction.type && transaction.amount > 0); 
                const amount = Math.abs(transaction.amount); 
                const parsed = parseTransactionDescription(transaction);
                let descLine1 = parsed.title;
                let descLine2 = parsed.detail;
                const hasWarning = parsed.warning;
                // [v5.8.0] 图标逻辑修复：自动补录用🤖，自动修正用🔧，手动补录用📆
                let iconPrefix = '';
                if (hasWarning) iconPrefix += '⚠️';
                if (parsed.hasHabitBonus) iconPrefix += '⭐';
                if (parsed.isTarget && parsed.icon === '🎯') iconPrefix += '🎯';
                if (parsed.icon === '🤖' || parsed.icon === '🔧') {
                    iconPrefix += parsed.icon;
                } else if (parsed.isBackdate) {
                    iconPrefix += '📆';
                }
                if (iconPrefix) iconPrefix += ' ';
                descLine1 = iconPrefix + descLine1;
                const timeStr = new Date(transaction.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                return `<div class="history-item">
                            <div class="history-info" title="${transaction.description}">
                                <div class="history-description">
                                    <div class="desc-line-1">${descLine1}</div> 
                                    ${descLine2 ? `<div class="desc-line-2">${descLine2}</div>` : ''}
                                </div>
                                <div class="history-time">${timeStr}</div>
                            </div>
                            <div class="history-amount-wrapper">
                                <div class="history-amount ${isPositive ? 'positive' : 'negative'}">${isPositive ? '+' : '-'}${formatTime(amount)}</div>
                            </div>
                        </div>`; 
            }).join(''); 
            content.innerHTML = summaryHtml + listHtml; 
            modal.classList.add('show');
            content.scrollTop = 0; 
        }

        // [v5.8.0] 时间余额卡片的时间流图版每日详情
        function showDayFlowChart(localDateStr) { 
            const modal = document.getElementById('dayDetailModal'); 
            modal.classList.add('flow-mode'); // [v6.3.3] 进入流图模式
            const title = document.getElementById('dayDetailModalTitle'); 
            const content = document.getElementById('dayDetailContent'); 
            
            // 初始化状态 - 默认显示3天（选中日期往前2天，往后到今天结束）
            const targetDate = new Date(localDateStr);
            const today = new Date();
            multiDayFlowState.currentDate = new Date(targetDate);
            // 设置newestDate为今天结束，确保加载今天的全部时间（包括未来时段）
            multiDayFlowState.newestDate = new Date(today);
            multiDayFlowState.newestDate.setHours(23, 59, 59, 999);
            multiDayFlowState.oldestDate = new Date(targetDate);
            multiDayFlowState.oldestDate.setDate(multiDayFlowState.oldestDate.getDate() - 2);
            multiDayFlowState.isLoading = false;
            
            // 设置标题：左侧"时间流图"，右侧单日日期导航
            updateFlowDetailTitle();
            
            // 渲染内容
            renderMultiDayFlowContent(content, multiDayFlowState.oldestDate, multiDayFlowState.newestDate);
            
            modal.classList.add('show');
            
            // 滚动到当前时间线位置，使其在视口底部1/3处
            setTimeout(() => {
                const timeIndicator = content.querySelector('.current-time-indicator');
                if (timeIndicator) {
                    const topPx = parseInt(timeIndicator.style.getPropertyValue('--top-px')) || 0;
                    const viewportHeight = content.clientHeight;
                    // 让当前时间线在底部1/3位置，即滚动到 topPx - 2/3视口高度
                    content.scrollTop = Math.max(0, topPx - viewportHeight * 2 / 3);
                } else {
                    content.scrollTop = content.scrollHeight;
                }
            }, 100);
            
            // 添加滚动监听（滚动到顶部自动加载更早日期）
            content.onscroll = handleFlowDetailScroll;
        }
        
        // [v5.8.0] 处理滚动加载更早日期
        function handleFlowDetailScroll() {
            const content = document.getElementById('dayDetailContent');
            if (!content || multiDayFlowState.isLoading) return;
            
            // 滚动到顶部附近时加载更早的3天
            if (content.scrollTop < 50) {
                multiDayFlowState.isLoading = true;
                
                const oldScrollHeight = content.scrollHeight;
                const oldScrollTop = content.scrollTop;
                
                // 往前扩展3天
                multiDayFlowState.oldestDate.setDate(multiDayFlowState.oldestDate.getDate() - 3);
                
                renderMultiDayFlowContent(content, multiDayFlowState.oldestDate, multiDayFlowState.newestDate);
                
                // 保持视觉位置
                requestAnimationFrame(() => {
                    const newScrollHeight = content.scrollHeight;
                    content.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
                    multiDayFlowState.isLoading = false;
                });
            }
        }
        
        // [v5.8.0] 更新时间流图详情标题（显示单日日期）
        function updateFlowDetailTitle() {
            const title = document.getElementById('dayDetailModalTitle');
            const today = getLocalDateString(new Date());
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = getLocalDateString(yesterday);
            const currentStr = getLocalDateString(multiDayFlowState.currentDate);
            const isCurrentToday = currentStr === today;
            
            // 单日日期显示：今天、昨天、或MM-DD格式
            let displayDate;
            if (currentStr === today) {
                displayDate = '今天';
            } else if (currentStr === yesterdayStr) {
                displayDate = '昨天';
            } else {
                displayDate = currentStr.slice(5); // MM-DD格式
            }
            
            // 检查是否隐藏说明按钮
            const hideInfoBtn = localStorage.getItem('flowChartInfoHidden') === 'true';
            const infoBtnStyle = hideInfoBtn ? 'style="display:none"' : '';
            
            title.innerHTML = `
                <div class="flow-detail-header">
                    <div class="flow-detail-title-group">
                        <button class="view-switch-btn" onclick="event.stopPropagation();switchToListView()" title="切换到列表详情">⇄</button>
                        <span class="flow-detail-title">时间流图</span>
                    </div>
                    <div class="flow-date-nav">
                        <button onclick="navigateFlowDetail(-1)" title="前一天">&lt;</button>
                        <span class="flow-detail-date">${displayDate}</span>
                        <button onclick="navigateFlowDetail(1)" ${isCurrentToday ? 'disabled' : ''} title="后一天">&gt;</button>
                    </div>
                </div>
            `;
        }
        
        // [v6.3.3] 切换到列表视图（今日详情）
        function switchToListView() {
             const dateStr = getLocalDateString(multiDayFlowState.currentDate);
             showDayDetails(dateStr);
        }
        
        // [v5.8.0] 日期导航（切换当前显示日期，同时调整加载范围）+ 滑动动画
        function navigateFlowDetail(delta) {
            const content = document.getElementById('dayDetailContent');
            const wrapper = content.querySelector('.multi-day-flow-wrapper');
            const today = new Date();
            today.setHours(23, 59, 59, 999);
            
            // 滑动动画：先滑出
            if (wrapper) {
                wrapper.classList.add(delta > 0 ? 'slide-left' : 'slide-right');
            }
            
            setTimeout(() => {
                // 切换当前日期
                multiDayFlowState.currentDate.setDate(multiDayFlowState.currentDate.getDate() + delta);
                
                // 不能超过今天
                if (multiDayFlowState.currentDate > today) {
                    multiDayFlowState.currentDate = new Date(today);
                }
                
                // 更新显示范围：以新的当前日期为基准，往前2天，往后到今天结束
                multiDayFlowState.newestDate = new Date(today);
                multiDayFlowState.newestDate.setHours(23, 59, 59, 999);
                multiDayFlowState.oldestDate = new Date(multiDayFlowState.currentDate);
                multiDayFlowState.oldestDate.setDate(multiDayFlowState.oldestDate.getDate() - 2);
                
                updateFlowDetailTitle();
                renderMultiDayFlowContent(content, multiDayFlowState.oldestDate, multiDayFlowState.newestDate);
                
                // 滑动动画：滑入（从反方向滑入）
                const newWrapper = content.querySelector('.multi-day-flow-wrapper');
                if (newWrapper) {
                    newWrapper.classList.add(delta > 0 ? 'slide-right' : 'slide-left');
                    // 强制reflow后移除class，触发过渡动画
                    newWrapper.offsetHeight;
                    newWrapper.classList.remove('slide-left', 'slide-right');
                }
                
                // 滚动到目标日期的0点位置
                setTimeout(() => {
                    const targetDateStr = getLocalDateString(multiDayFlowState.currentDate);
                    const targetLine = content.querySelector(`.hour-line[data-date="${targetDateStr}"]`);
                    if (targetLine) {
                        const topPx = parseInt(targetLine.style.getPropertyValue('--top-px')) || 0;
                        content.scrollTop = topPx;
                    } else {
                        content.scrollTop = content.scrollHeight;
                    }
                }, 50);
            }, 150); // 等待滑出动画完成
        }
        
        // [v5.8.0] 渲染多天时间流图内容
        function renderMultiDayFlowContent(container, startDate, endDate) {
            const days = Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000)) + 1;
            const slots = getMultiDayFlowSlots(endDate, days);
            
            // 计算统计
            let earned = 0, spent = 0;
            const countedTransactions = new Set();
            slots.forEach(slot => {
                if (countedTransactions.has(slot.transactionId)) return;
                countedTransactions.add(slot.transactionId);
                if (slot.isSpend) spent += slot.durationSeconds;
                else earned += slot.durationSeconds;
            });
            
            // 空状态
            if (slots.length === 0) {
                container.innerHTML = `
                    <div class="multi-day-flow-wrapper">
                        <div class="empty-message" style="text-align:center;padding:40px;color:var(--text-color-light)">无活动记录</div>
                    </div>
                `;
                return;
            }
            
            // 分配列
            assignFlowColumns(slots);
            
            // 找暂停连接
            const connections = findFlowPauseConnections(slots);
            
            // 计算时间范围（跨多天）
            const minTime = new Date(Math.min(...slots.map(s => s.start.getTime())));
            let maxTime = new Date(Math.max(...slots.map(s => s.end.getTime())));
            
            // [修复] 确保 maxTime 至少包含当前时间，这样才能显示今天的剩余时间和当前时间线
            const now = new Date();
            if (now > maxTime) {
                maxTime = now;
            }
            
            // 计算网格参数
            const PX_PER_HOUR = 51;
            const startHour = minTime.getHours();
            const startDay = new Date(minTime);
            startDay.setHours(0, 0, 0, 0);
            
            // 计算总小时数（从最早slot开始到最晚slot结束）
            const totalMs = maxTime - minTime;
            const totalHours = Math.ceil(totalMs / (60 * 60 * 1000)) + 2; // 加2小时边距
            
            // 基准时间点（网格起始）
            const gridStartTime = new Date(minTime);
            gridStartTime.setMinutes(0, 0, 0);
            gridStartTime.setHours(gridStartTime.getHours() - 1); // 提前1小时
            
            function timeToPx(date) {
                const diffMs = date.getTime() - gridStartTime.getTime();
                const diffHours = diffMs / (60 * 60 * 1000);
                return diffHours * PX_PER_HOUR;
            }
            
            const totalGridHeight = totalHours * PX_PER_HOUR;
            
            // [v5.8.0] 构建刻度小时列表：0-8点折叠为一行，8点后每小时一行
            const displayHours = [];
            let gridStartHour = gridStartTime.getHours();
            let currentTime = new Date(gridStartTime);
            let h = 0;
            while (h < totalHours) {
                const hourNum = (gridStartHour + h) % 24;
                const dayOffset = Math.floor((gridStartHour + h) / 24);
                const hourTime = new Date(gridStartTime.getTime() + h * 60 * 60 * 1000);
                
                if (hourNum < 8) {
                    // 0-8点区间：折叠为一行
                    const hoursUntil8 = 8 - hourNum;
                    const spanHours = Math.min(hoursUntil8, totalHours - h);
                    // 0点显示日期，其他显示00:00
                    const label = hourNum === 0 ? `${hourTime.getMonth()+1}/${hourTime.getDate()}` : '00:00';
                    displayHours.push({ hour: hourNum, span: spanHours, label, time: hourTime, isNewDay: hourNum === 0 });
                    h += spanHours;
                } else {
                    // 8点及以后：每小时一行
                    const label = hourNum.toString().padStart(2, '0') + ':00';
                    displayHours.push({ hour: hourNum, span: 1, label, time: hourTime, isNewDay: false });
                    h++;
                }
            }
            
            // 计算折叠后的总高度
            let foldedHeight = 0;
            displayHours.forEach(item => {
                if (item.hour < 8) {
                    foldedHeight += PX_PER_HOUR; // 0-8点区间固定一行高度
                } else {
                    foldedHeight += PX_PER_HOUR;
                }
            });
            
            // 构建小时到像素的映射
            function timeToPxFolded(date) {
                const targetMs = date.getTime();
                let accPx = 0;
                for (const item of displayHours) {
                    const itemStartMs = item.time.getTime();
                    const itemEndMs = itemStartMs + item.span * 60 * 60 * 1000;
                    if (targetMs < itemStartMs) return accPx;
                    if (targetMs <= itemEndMs) {
                        const fraction = (targetMs - itemStartMs) / (item.span * 60 * 60 * 1000);
                        return accPx + fraction * PX_PER_HOUR;
                    }
                    accPx += PX_PER_HOUR;
                }
                return accPx;
            }
            
            let html = `
                <div class="multi-day-flow-wrapper" id="multiDayFlowWrapper">
                    <div class="multi-day-flow-grid" style="height:${foldedHeight}px">
            `;
            
            // 小时刻度线
            html += '<div class="hour-lines">';
            let currentPx = 0;
            for (const item of displayHours) {
                const classes = item.isNewDay ? 'new-day' : '';
                const dateAttr = item.isNewDay ? `data-date="${item.time.getFullYear()}-${String(item.time.getMonth()+1).padStart(2,'0')}-${String(item.time.getDate()).padStart(2,'0')}"` : '';
                html += `<div class="hour-line ${classes}" ${dateAttr} style="--top-px:${currentPx}px;--height-px:${PX_PER_HOUR}px"><span>${item.label}</span></div>`;
                currentPx += PX_PER_HOUR;
            }
            html += '</div>';
            
            // 当前时间指示线（now已在上面定义）
            if (now >= gridStartTime && now <= new Date(gridStartTime.getTime() + totalHours * 60 * 60 * 1000)) {
                const nowPx = timeToPxFolded(now);
                html += `<div class="current-time-indicator" style="--top-px:${nowPx}px"><div class="current-time-ball"></div><div class="current-time-line"></div></div>`;
            }
            
            // 暂停虚线连接
            // [v6.4.6] 修复：虚线应从色块的实际渲染底部开始，考虑最小高度28px
            html += '<div class="pause-connections">';
            connections.forEach(conn => {
                const fromTopPx = timeToPxFolded(conn.from.start);
                const fromEndPx = timeToPxFolded(conn.from.end);
                // 考虑最小高度28px，计算实际渲染的底部位置
                const fromBlockHeight = Math.max(28, fromEndPx - fromTopPx);
                const fromBlockBottomPx = fromTopPx + fromBlockHeight;
                
                const toStartPx = timeToPxFolded(conn.to.start);
                const heightPx = toStartPx - fromBlockBottomPx;
                if (heightPx > 0) {
                    html += `<div class="pause-line" style="--col:${conn.from.column};--top-px:${fromBlockBottomPx}px;--height-px:${heightPx}px;--line-color:${conn.color}"></div>`;
                }
            });
            html += '</div>';
            
            // 任务条块
            html += '<div class="task-blocks">';
            slots.forEach(slot => {
                const topPx = timeToPxFolded(slot.start);
                const bottomPx = timeToPxFolded(slot.end);
                const heightPx = Math.max(28, bottomPx - topPx);
                const segType = slot.segmentType || 'only';
                const durationMins = slot.durationMinutes;
                
                // [v5.8.0] 时长判断：涉及0-8点压缩区间的任务需要更高时长要求
                const startHour = slot.start.getHours();
                const endHour = slot.end.getHours();
                const involvesCompressedZone = startHour < 8 || endHour < 8 || (startHour > endHour); // 跨午夜也算
                const showTimeThreshold = involvesCompressedZone ? 240 : 60; // 压缩区间4小时，普通1小时
                const showTime = durationMins >= showTimeThreshold;
                const allowWrap = durationMins >= 45;
                const showDuration = durationMins >= 180;
                const nameClass = allowWrap ? 'task-block-name allow-wrap' : 'task-block-name';
                const durationText = showDuration ? `<div class="task-block-duration">${formatTime(Math.round(slot.realDurationSeconds))}</div>` : '';
                
                let blockContent = '';
                if (segType === 'only') {
                    if (showTime) {
                        blockContent = `
                            <div class="task-block-time-top">${formatTimeHM(slot.start)}</div>
                            <div class="task-block-content"><div class="${nameClass}">${escapeHtml(slot.taskName)}</div>${durationText}</div>
                            <div class="task-block-time-bottom">${formatTimeHM(slot.end)}</div>
                        `;
                    } else {
                        blockContent = `<div class="task-block-content"><div class="${nameClass}">${escapeHtml(slot.taskName)}</div>${durationText}</div>`;
                    }
                } else if (segType === 'first') {
                    if (showTime) {
                        blockContent = `
                            <div class="task-block-time-top">${formatTimeHM(slot.start)}</div>
                            <div class="task-block-content"><div class="${nameClass}">${escapeHtml(slot.taskName)}</div>${durationText}</div>
                            <div class="task-block-time-bottom">${slot.pauseTime ? '暂停 ' + slot.pauseTime : formatTimeHM(slot.end)}</div>
                        `;
                    } else {
                        blockContent = `<div class="task-block-content"><div class="${nameClass}">${escapeHtml(slot.taskName)}</div>${durationText}</div>`;
                    }
                } else if (segType === 'middle') {
                    if (showTime) {
                        blockContent = `
                            <div class="task-block-time-top">${slot.resumeTime ? '继续 ' + slot.resumeTime : formatTimeHM(slot.start)}</div>
                            <div class="task-block-content">${durationText}</div>
                            <div class="task-block-time-bottom">${slot.pauseTime ? '暂停 ' + slot.pauseTime : formatTimeHM(slot.end)}</div>
                        `;
                    } else {
                        blockContent = `<div class="task-block-content">${durationText}</div>`;
                    }
                } else if (segType === 'last') {
                    if (showTime) {
                        blockContent = `
                            <div class="task-block-time-top">${slot.resumeTime ? '继续 ' + slot.resumeTime : formatTimeHM(slot.start)}</div>
                            <div class="task-block-content"><div class="${nameClass}">${escapeHtml(slot.taskName)}</div>${durationText}</div>
                            <div class="task-block-time-bottom">${formatTimeHM(slot.end)}</div>
                        `;
                    } else {
                        blockContent = `<div class="task-block-content"><div class="${nameClass}">${escapeHtml(slot.taskName)}</div>${durationText}</div>`;
                    }
                }
                
                html += `<div class="task-block segment-${segType}" style="--col:${slot.column};--top-px:${topPx}px;--height-px:${heightPx}px;--cat-color:${slot.color}">${blockContent}</div>`;
            });
            html += '</div>';
            
            html += '</div></div>';
            
            container.innerHTML = html;
        }

// 从日历弹窗展开到详情页的动画版本
function showDayDetailsWithAnimation(localDateStr) {
    const modal = document.getElementById('dayDetailModal');
    // 添加特殊标记用于展开动画（只在关闭弹窗时移除，避免触发二次动画）
    modal.classList.add('from-tooltip');
    // 调用原始函数填充内容
    showDayDetails(localDateStr);
}
function hideDayDetailModal() { document.getElementById('dayDetailModal').classList.remove('show', 'from-tooltip'); }
function hideCategoryDetailModal() { document.getElementById('categoryDetailModal').classList.remove('show', 'from-pie'); }
// [v5.2.0] 通用信息弹窗函数
function showInfoModal(title, content) { 
    document.getElementById('generalInfoModalTitle').textContent = title; 
    document.getElementById('generalInfoModalContent').innerHTML = content; 
    document.getElementById('generalInfoModal').classList.add('show'); 
}
function hideInfoModal() { document.getElementById('generalInfoModal').classList.remove('show'); }
// [v5.2.1] 自定义 alert 替代函数，避免显示"网址为..."的丑陋标题
function showAlert(message, title = '提示') {
    // 将换行符转换为 <br> 以便正确显示多行消息
    const htmlContent = message.replace(/\n/g, '<br>');
    showInfoModal(title, `<div style="white-space: pre-wrap;">${htmlContent}</div>`);
}
// [v5.2.1] 自定义 confirm 替代函数
let confirmResolve = null;
function showConfirm(message, title = '确认') {
    return new Promise((resolve) => {
        confirmResolve = resolve;
        document.getElementById('confirmModalTitle').textContent = title;
        document.getElementById('confirmModalContent').textContent = message;
        document.getElementById('confirmModal').classList.add('show');
    });
}
function resolveConfirm(result) {
    document.getElementById('confirmModal').classList.remove('show');
    if (confirmResolve) {
        confirmResolve(result);
        confirmResolve = null;
    }
}

// [v6.4.5] 戒除奖励显示模式选择弹窗
function showAbstinenceRewardModeDialog() {
    return new Promise((resolve) => {
        const isGlass = document.body.classList.contains('glass-mode');
        const currentMode = notificationSettings.abstinenceRewardMode || 'offset';
        
        const overlay = document.createElement('div');
        overlay.id = 'abstinence-mode-overlay';
        overlay.innerHTML = `
            <style>
                #abstinence-mode-overlay {
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5);
                    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
                    z-index: 10002;
                    display: flex; align-items: center; justify-content: center;
                    animation: absModeIn 0.25s ease;
                }
                @keyframes absModeIn { from { opacity: 0; } to { opacity: 1; } }
                .abs-mode-card {
                    background: ${isGlass ? 'rgba(28,28,32,0.95)' : 'var(--card-bg, #fff)'};
                    backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
                    border-radius: 20px;
                    width: 92%; max-width: 380px;
                    box-shadow: 0 25px 80px rgba(0,0,0,0.45);
                    border: 1px solid ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.06)'};
                    color: ${isGlass ? 'rgba(255,255,255,0.95)' : 'var(--text-color, #333)'};
                    overflow: hidden;
                    animation: absModeSlide 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
                }
                @keyframes absModeSlide {
                    from { opacity: 0; transform: translateY(30px) scale(0.92); }
                    to { opacity: 1; transform: translateY(0) scale(1); }
                }
                .abs-mode-header {
                    padding: 20px 16px 12px;
                    text-align: center;
                    background: linear-gradient(135deg, rgba(102,126,234,0.15), rgba(118,75,162,0.1));
                }
                .abs-mode-header .icon { font-size: 32px; margin-bottom: 6px; }
                .abs-mode-header h3 {
                    margin: 0; font-size: 17px; font-weight: 600;
                    color: ${isGlass ? '#a0b4ff' : '#667eea'};
                }
                .abs-mode-body { padding: 16px; }
                .abs-mode-desc {
                    font-size: 13px; opacity: 0.8; line-height: 1.6;
                    margin-bottom: 16px;
                }
                .abs-mode-options { display: flex; flex-direction: column; gap: 10px; }
                .abs-mode-option {
                    display: flex; align-items: flex-start; gap: 12px;
                    padding: 14px; border-radius: 12px;
                    background: ${isGlass ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.03)'};
                    cursor: pointer;
                    transition: background 0.15s, transform 0.15s;
                    border: 2px solid transparent;
                }
                .abs-mode-option:hover { background: ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)'}; }
                .abs-mode-option.selected {
                    border-color: ${isGlass ? '#667eea' : '#007aff'};
                    background: ${isGlass ? 'rgba(102,126,234,0.15)' : 'rgba(0,122,255,0.08)'};
                }
                .abs-mode-option:active { transform: scale(0.98); }
                .abs-mode-radio {
                    width: 20px; height: 20px; border-radius: 50%;
                    border: 2px solid ${isGlass ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.3)'};
                    flex-shrink: 0; margin-top: 2px;
                    display: flex; align-items: center; justify-content: center;
                }
                .abs-mode-option.selected .abs-mode-radio {
                    border-color: ${isGlass ? '#667eea' : '#007aff'};
                    background: ${isGlass ? '#667eea' : '#007aff'};
                }
                .abs-mode-option.selected .abs-mode-radio::after {
                    content: ''; width: 8px; height: 8px; border-radius: 50%;
                    background: white;
                }
                .abs-mode-text { flex: 1; }
                .abs-mode-text .title { font-size: 14px; font-weight: 600; margin-bottom: 4px; }
                .abs-mode-text .desc { font-size: 12px; opacity: 0.7; line-height: 1.5; }
                .abs-mode-footer { padding: 12px 16px 16px; }
                .abs-mode-dont-show {
                    display: flex; align-items: center; gap: 8px;
                    margin-bottom: 12px; cursor: pointer;
                    font-size: 13px; opacity: 0.8;
                }
                .abs-mode-dont-show input {
                    width: 16px; height: 16px; accent-color: ${isGlass ? '#667eea' : '#007aff'};
                }
                .abs-mode-btn {
                    width: 100%; padding: 14px; border: none; border-radius: 12px;
                    font-size: 15px; font-weight: 600; cursor: pointer;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    transition: transform 0.15s, opacity 0.15s;
                }
                .abs-mode-btn:active { transform: scale(0.97); opacity: 0.9; }
            </style>
            <div class="abs-mode-card">
                <div class="abs-mode-header">
                    <div class="icon">🎯</div>
                    <h3>戒除奖励显示设置</h3>
                </div>
                <div class="abs-mode-body">
                    <div class="abs-mode-desc">
                        您已启用习惯戒除功能。当您成功戒除时获得的奖励时间，希望如何在报告页面中显示？
                    </div>
                    <div class="abs-mode-options">
                        <div class="abs-mode-option ${currentMode === 'offset' ? 'selected' : ''}" data-mode="offset">
                            <div class="abs-mode-radio"></div>
                            <div class="abs-mode-text">
                                <div class="title">📉 抵扣消费时间（推荐）</div>
                                <div class="desc">戒除奖励直接减少对应任务的消费时间统计，不会出现在"获得时间"视图中</div>
                            </div>
                        </div>
                        <div class="abs-mode-option ${currentMode === 'separate' ? 'selected' : ''}" data-mode="separate">
                            <div class="abs-mode-radio"></div>
                            <div class="abs-mode-text">
                                <div class="title">📊 独立显示获得</div>
                                <div class="desc">戒除奖励作为正常获得时间显示，会出现在该任务分类的"获得时间"中</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="abs-mode-footer">
                    <label class="abs-mode-dont-show">
                        <input type="checkbox" id="absModeNoShow">
                        <span>不再显示此提示</span>
                    </label>
                    <button class="abs-mode-btn" id="absModeConfirm">确定</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(overlay);
        
        // 选项点击
        const options = overlay.querySelectorAll('.abs-mode-option');
        let selectedMode = currentMode;
        options.forEach(opt => {
            opt.addEventListener('click', () => {
                options.forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedMode = opt.dataset.mode;
            });
        });
        
        // 确定按钮
        overlay.querySelector('#absModeConfirm').addEventListener('click', () => {
            const dontShow = overlay.querySelector('#absModeNoShow').checked;
            
            // 保存设置
            notificationSettings.abstinenceRewardMode = selectedMode;
            if (dontShow) {
                notificationSettings.abstinenceRewardModePrompted = true;
            }
            
            overlay.remove();
            resolve(selectedMode);
        });
    });
}

// [v6.4.1] 输入提示弹窗
function showPrompt(message, defaultValue = '', title = '输入') {
    return new Promise((resolve) => {
        const isGlass = document.body.classList.contains('glass-mode');
        const overlay = document.createElement('div');
        overlay.id = 'prompt-overlay';
        overlay.innerHTML = `
            <style>
                #prompt-overlay {
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.5);
                    backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
                    z-index: 10001;
                    display: flex; align-items: center; justify-content: center;
                    animation: promptFadeIn 0.2s ease;
                }
                @keyframes promptFadeIn { from { opacity: 0; } to { opacity: 1; } }
                .prompt-card {
                    background: ${isGlass ? 'rgba(30,30,35,0.95)' : 'var(--card-bg, #fff)'};
                    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
                    border-radius: 16px; padding: 20px;
                    width: 85%; max-width: 320px;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
                    border: 1px solid ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)'};
                    color: ${isGlass ? 'rgba(255,255,255,0.95)' : 'var(--text-color, #333)'};
                }
                .prompt-card h4 { margin: 0 0 8px; font-size: 16px; font-weight: 600; }
                .prompt-card p { margin: 0 0 16px; font-size: 13px; opacity: 0.8; line-height: 1.5; }
                .prompt-card input {
                    width: 100%; padding: 12px; border-radius: 10px;
                    border: 1px solid ${isGlass ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)'};
                    background: ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.03)'};
                    color: inherit; font-size: 15px;
                    margin-bottom: 16px; box-sizing: border-box;
                }
                .prompt-card input::placeholder { color: ${isGlass ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.4)'}; }
                .prompt-card input:focus { outline: none; border-color: var(--color-primary, #007aff); }
                .prompt-btns { display: flex; gap: 8px; }
                .prompt-btn {
                    flex: 1; padding: 12px; border: none; border-radius: 10px;
                    font-size: 14px; font-weight: 500; cursor: pointer;
                }
                .prompt-btn-cancel {
                    background: ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.06)'};
                    color: ${isGlass ? 'rgba(255,255,255,0.7)' : 'var(--text-color)'};
                }
                .prompt-btn-ok {
                    background: linear-gradient(135deg, #007aff 0%, #0055cc 100%);
                    color: white;
                }
            </style>
            <div class="prompt-card">
                <h4>${title}</h4>
                <p>${message}</p>
                <input type="text" id="promptInput" value="${defaultValue}" placeholder="请输入...">
                <div class="prompt-btns">
                    <button class="prompt-btn prompt-btn-cancel" onclick="resolvePrompt(null)">取消</button>
                    <button class="prompt-btn prompt-btn-ok" onclick="resolvePrompt(document.getElementById('promptInput').value)">确定</button>
                </div>
            </div>
        `;
        document.body.appendChild(overlay);
        
        // 自动聚焦输入框
        setTimeout(() => {
            const input = document.getElementById('promptInput');
            if (input) { input.focus(); input.select(); }
        }, 100);
        
        // 回车确认
        overlay.querySelector('input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') resolvePrompt(document.getElementById('promptInput').value);
            if (e.key === 'Escape') resolvePrompt(null);
        });
        
        window._promptResolve = resolve;
    });
}
function resolvePrompt(value) {
    const overlay = document.getElementById('prompt-overlay');
    if (overlay) overlay.remove();
    if (window._promptResolve) {
        window._promptResolve(value);
        window._promptResolve = null;
    }
}

function showAllTasksInfoModal() { document.getElementById('allTasksInfoModal').classList.add('show'); }
function hideAllTasksInfoModal() { document.getElementById('allTasksInfoModal').classList.remove('show'); }
function showFlowChartInfoModal() { document.getElementById('flowChartInfoModal').classList.add('show'); }
function hideFlowChartInfoModal() { document.getElementById('flowChartInfoModal').classList.remove('show'); }
function disableFlowChartInfoButton() { localStorage.setItem('flowChartInfoHidden', 'true'); const btn = document.getElementById('flowChartInfoButton'); if (btn) btn.style.display = 'none'; hideFlowChartInfoModal(); }
function disableAllTasksInfoButton() { 
    localStorage.setItem('allTasksInfoHidden', 'true'); 
    const btn1 = document.getElementById('allTasksInfoButton'); 
    const btn2 = document.getElementById('allTasksInfoButtonSpend'); 
    if (btn1) btn1.style.display = 'none'; 
    if (btn2) btn2.style.display = 'none'; 
    hideAllTasksInfoModal(); 
}
function showActivityHeatmapInfoModal() { document.getElementById('activityHeatmapInfoModal').classList.add('show'); }
function hideActivityHeatmapInfoModal() { document.getElementById('activityHeatmapInfoModal').classList.remove('show'); }
function showAnalysisDashboardInfoModal() { document.getElementById('analysisDashboardInfoModal').classList.add('show'); }
function hideAnalysisDashboardInfoModal() { document.getElementById('analysisDashboardInfoModal').classList.remove('show'); }
function showTableInfoModal() { document.getElementById('tableInfoModal').classList.add('show'); }
function hideTableInfoModal() { document.getElementById('tableInfoModal').classList.remove('show'); }
function showTrendInfoModal() { document.getElementById('trendInfoModal').classList.add('show'); }
function hideTrendInfoModal() { document.getElementById('trendInfoModal').classList.remove('show'); }
function disableActivityHeatmapInfoButton() { localStorage.setItem('activityHeatmapInfoHidden', 'true'); const btn = document.getElementById('activityHeatmapInfoButton'); if (btn) btn.style.display = 'none'; hideActivityHeatmapInfoModal(); }
function disableAnalysisDashboardInfoButton() { localStorage.setItem('analysisDashboardInfoHidden', 'true'); const btn = document.getElementById('analysisDashboardInfoButton'); if (btn) btn.style.display = 'none'; hideAnalysisDashboardInfoModal(); }
function disableTableInfoButton() { localStorage.setItem('tableInfoHidden', 'true'); const btn = document.getElementById('tableInfoButton'); if (btn) btn.style.display = 'none'; hideTableInfoModal(); }
function disableTrendInfoButton() { localStorage.setItem('trendInfoHidden', 'true'); const btn = document.getElementById('trendInfoButton'); if (btn) btn.style.display = 'none'; hideTrendInfoModal(); }
function showAutoDetectInfoModal() { document.getElementById('autoDetectInfoModal').classList.add('show'); }
function hideAutoDetectInfoModal() { document.getElementById('autoDetectInfoModal').classList.remove('show'); }
function disableAutoDetectInfoButton() { localStorage.setItem('autoDetectInfoHidden', 'true'); const btn = document.getElementById('autoDetectInfoButton'); if (btn) btn.style.display = 'none'; hideAutoDetectInfoModal(); }
// [v5.10.0] 屏幕时间说明弹窗函数
function showScreenTimeInfoModal() { document.getElementById('screenTimeInfoModal').classList.add('show'); }
function hideScreenTimeInfoModal() { document.getElementById('screenTimeInfoModal').classList.remove('show'); }
function disableScreenTimeInfoButton() { localStorage.setItem('screenTimeInfoHidden', 'true'); const btn = document.getElementById('screenTimeInfoButton'); if (btn) btn.style.display = 'none'; hideScreenTimeInfoModal(); }
// [v6.4.x] 通透强度调节（透明度）
function applyGlassStrength(percent = 100, persist = true) {
    const slider = document.getElementById('glassStrengthSlider');
    const label = document.getElementById('glassStrengthValue');
    const numeric = Number(percent);
    const clamped = Math.max(0, Math.min(120, Number.isFinite(numeric) ? numeric : 100));
    const scale = clamped / 100;
    if (slider) slider.value = clamped;
    if (label) label.textContent = `${clamped}%`;
    screenTimeSettings.glassStrength = clamped;
    if (glassStrengthRaf) cancelAnimationFrame(glassStrengthRaf);
    glassStrengthRaf = requestAnimationFrame(() => {
        document.documentElement.style.setProperty('--glass-strength', scale);
        document.documentElement.style.setProperty('--glass-opacity-scale', scale);
        if (persist) saveScreenTimeSettings();
        glassStrengthRaf = null;
    });
}
function onGlassStrengthChange(val) { applyGlassStrength(val); }

// [v6.4.x] 模糊强度调节
function applyGlassBlurStrength(percent = 100, persist = true) {
    const slider = document.getElementById('glassBlurSlider');
    const label = document.getElementById('glassBlurValue');
    const numeric = Number(percent);
    const clamped = Math.max(0, Math.min(120, Number.isFinite(numeric) ? numeric : 100));
    const scale = clamped / 100;
    if (slider) slider.value = clamped;
    if (label) label.textContent = `${clamped}%`;
    screenTimeSettings.glassBlurStrength = clamped;
    if (glassBlurRaf) cancelAnimationFrame(glassBlurRaf);
    glassBlurRaf = requestAnimationFrame(() => {
        document.documentElement.style.setProperty('--glass-blur-scale', scale);
        if (persist) saveScreenTimeSettings();
        glassBlurRaf = null;
    });
}
function onGlassBlurChange(val) { applyGlassBlurStrength(val); }
// [v6.0.0] 统一卡片样式切换（时间余额卡片 + 屏幕时间卡片 + 任务卡片 + 底部导航栏 + 全局通透模式）
function setCardStyle(style) {
    // [v6.0.0] 应用全局通透模式到 body
    if (style === 'glass') {
        document.body.classList.add('glass-mode');
    } else {
        document.body.classList.remove('glass-mode');
    }
    // 应用到时间余额卡片
    const balanceCard = document.getElementById('balanceCard');
    if (balanceCard) {
        balanceCard.classList.remove('classic', 'glass');
        balanceCard.classList.add(style);
    }
    // 应用到屏幕时间卡片
    const screenTimeWrapper = document.getElementById('screenTimeWrapper');
    if (screenTimeWrapper) {
        screenTimeWrapper.classList.remove('classic', 'glass');
        screenTimeWrapper.classList.add(style);
    }
    // 应用到所有任务卡片
    document.querySelectorAll('.task-card').forEach(card => {
        card.classList.remove('classic', 'glass');
        card.classList.add(style);
    });
    // 应用到底部导航栏
    const bottomTabs = document.querySelector('.bottom-tabs');
    if (bottomTabs) {
        bottomTabs.classList.remove('classic', 'glass');
        bottomTabs.classList.add(style);
    }
    // 通透强度控制条显隐
    const glassStrengthSetting = document.getElementById('glassStrengthSetting');
    const glassBlurSetting = document.getElementById('glassBlurSetting');
    const glassAffectList = document.getElementById('glassAffectList');
    if (glassStrengthSetting) {
        glassStrengthSetting.style.display = style === 'glass' ? 'flex' : 'none';
    }
    if (glassBlurSetting) {
        glassBlurSetting.style.display = style === 'glass' ? 'flex' : 'none';
    }
    if (glassAffectList) {
        glassAffectList.style.display = style === 'glass' ? 'block' : 'none';
    }
    // 切换到通透时，应用当前强度
    if (style === 'glass') {
        applyGlassStrength(screenTimeSettings.glassStrength || 100, false);
        applyGlassBlurStrength(screenTimeSettings.glassBlurStrength || 100, false);
    }
    // 更新全局切换器按钮状态
    const globalSwitcher = document.getElementById('globalCardStyleSwitcher');
    if (globalSwitcher) {
        globalSwitcher.querySelectorAll('.style-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.style === style);
        });
    }
    // 保存设置到screenTimeSettings（兼容旧的保存机制）
    screenTimeSettings.cardStyle = style;
    saveScreenTimeSettings();
    // 刷新屏幕时间卡片颜色
    updateScreenTimeCard();
    // 刷新余额卡片（确保样式正确显示）
    if (typeof updateBalanceCard === 'function') updateBalanceCard();
}
// [v5.10.0] 兼容旧函数（内部调用统一函数）
function setScreenTimeCardStyle(style) {
    setCardStyle(style);
}
// [v5.10.0] 通透模式进度条颜色计算
function getScreenTimeProgressColor(percent) {
    if (percent <= 60) {
        return { gradient: 'linear-gradient(90deg, #22c55e 0%, #4ade80 100%)', color: '#22c55e' }; // 绿色
    } else if (percent <= 90) {
        return { gradient: 'linear-gradient(90deg, #eab308 0%, #facc15 100%)', color: '#eab308' }; // 黄色
    } else if (percent <= 100) {
        return { gradient: 'linear-gradient(90deg, #f97316 0%, #fb923c 100%)', color: '#f97316' }; // 橙色
    } else {
        return { gradient: 'linear-gradient(90deg, #ef4444 0%, #f87171 100%)', color: '#ef4444' }; // 红色
    }
}
        
        // --- Dashboard & Analysis ---
        let cachedAnalysisFilteredTransactions = [];
        let cachedAnalysisAggregatedData = []; // [v6.0.0] 缓存聚合数据供KPI切换使用

        function updateAnalysisDashboard() { 
            renderAnalysisFilters(); 
            const filteredTransactions = getFilteredTransactions(reportState.analysisPeriod); 
            cachedAnalysisFilteredTransactions = filteredTransactions; 
            const { aggregatedData } = processDashboardData(filteredTransactions, reportState.analysisView); 
            cachedAnalysisAggregatedData = aggregatedData; // 缓存
            renderKpiCards(filteredTransactions, aggregatedData, reportState.insightSubViewIndex || 0, true); // forceRender=true
            updateInteractiveAnalysisModule(aggregatedData, filteredTransactions); 
        }
        function renderAnalysisFilters() { const container = document.getElementById('analysisDashboardFilters'); container.innerHTML = `<button class="${reportState.analysisPeriod === '7d' ? 'active' : ''}" onclick="setAnalysisPeriod('7d')">7天内</button><button class="${reportState.analysisPeriod === '30d' ? 'active' : ''}" onclick="setAnalysisPeriod('30d')">30天内</button><button class="${reportState.analysisPeriod === 'all' ? 'active' : ''}" onclick="setAnalysisPeriod('all')">全部</button>`; /* Update view switcher in chart header */ const viewSwitcher = document.getElementById('analysisViewSwitcher'); if (viewSwitcher) { viewSwitcher.querySelectorAll('button').forEach(btn => { const isCategory = btn.textContent === '分类'; btn.classList.toggle('active', (isCategory && reportState.analysisView === 'category') || (!isCategory && reportState.analysisView === 'task')); }); } }
        
        // [v6.0.0] 记录上次KPI渲染的状态，用于防止切换饼图时重复刷新
        let lastKpiRenderState = { pieIndex: -1, timestamp: 0 };
        
        function renderKpiCards(transactions, data, pieIndex = 0, forceRender = false) {
            const container = document.getElementById('kpiGrid');
            if (transactions.length === 0) { container.innerHTML = ''; lastKpiRenderState = { pieIndex: -1, timestamp: 0 }; return; }
            
            // [v6.0.0] 防止饼图切换后的重复渲染（2秒内相同索引不重复渲染）
            const now = Date.now();
            if (!forceRender && lastKpiRenderState.pieIndex === pieIndex && (now - lastKpiRenderState.timestamp) < 2000) {
                return; // 短时间内相同索引，跳过渲染
            }
            lastKpiRenderState = { pieIndex, timestamp: now };
            
            const uniqueDays = new Set(transactions.map(t => getLocalDateString(t.timestamp))).size;
            
            // 计算各项数据
            const totalEarned = data.reduce((sum, item) => sum + item.earned, 0);
            const totalSpent = data.reduce((sum, item) => sum + item.spent, 0);
            const totalNet = data.reduce((sum, item) => sum + item.net, 0);
            const avgDailyNet = uniqueDays > 0 ? totalNet / uniqueDays : 0;
            const avgDailyEarned = uniqueDays > 0 ? totalEarned / uniqueDays : 0;
            const avgDailySpent = uniqueDays > 0 ? totalSpent / uniqueDays : 0;
            
            // 根据饼图索引决定显示获得还是消费
            const isEarnView = pieIndex === 0;
            const dynamicValue = isEarnView ? avgDailyEarned : avgDailySpent;
            const dynamicLabel = isEarnView ? '平均每日获得' : '平均每日消费';
            const dynamicClass = isEarnView ? 'positive' : 'negative';
            const dynamicPrefix = isEarnView ? '+' : '-';
            
            // KPI卡片直接显示，不使用动画
            container.innerHTML = `
                <div class="kpi-card"> 
                    <div class="kpi-label">${dynamicLabel}</div> 
                    <div class="kpi-value kpi-time ${dynamicClass}">${dynamicPrefix}${formatTime(Math.abs(dynamicValue))}</div> 
                </div>
                <div class="kpi-card"> 
                    <div class="kpi-label">平均每日净增</div> 
                    <div class="kpi-value kpi-time ${avgDailyNet >= 0 ? 'positive' : 'negative'}">${avgDailyNet >= 0 ? '+' : ''}${formatTime(avgDailyNet)}</div> 
                </div>
            `;
        }

        function updateInteractiveAnalysisModule(aggregatedData, filteredTransactions) {
            const pieContainer = document.getElementById('pieChartContainerWrapper');
            pieContainer.className = reportState.analysisView === 'task' ? 'task-view-active' : 'category-view-active';
            renderPieCharts(aggregatedData, filteredTransactions);
        }
        function setInsightSubViewIndex(index) { reportState.insightSubViewIndex = index; }

        function showCategoryDetail(categoryName, typeKey = 'earn', fromPie = false) {
            const modal = document.getElementById('categoryDetailModal');
            const title = document.getElementById('categoryDetailModalTitle');
            const content = document.getElementById('categoryDetailContent');
            if (!modal || !title || !content) return;
            
            // 长按饼图进入时添加展开动画（只在关闭弹窗时移除，避免触发二次动画）
            if (fromPie) {
                modal.classList.add('from-pie');
            }

            const periodLabelMap = { '7d': '7天内', '30d': '30天内', 'all': '全部' };
            const typeLabel = typeKey === 'earn' ? '获得' : '消费';
            const periodLabel = periodLabelMap[reportState.analysisPeriod] || '全部';

            const source = (cachedAnalysisFilteredTransactions && cachedAnalysisFilteredTransactions.length > 0)
                ? cachedAnalysisFilteredTransactions
                : getFilteredTransactions(reportState.analysisPeriod);

            const taskMap = new Map();
            source.forEach(t => {
                // [v5.10.0] 支持系统分类的自定义分类
                let category, taskName;
                if (t.isSystem) {
                    category = getTransactionCategory(t); // 使用统一的分类获取函数
                    taskName = t.taskName || '屏幕时间';
                } else {
                    const task = tasks.find(tsk => tsk.id === t.taskId);
                    if (!task) return;
                    category = task.category;
                    taskName = task.name || t.taskName || '未知任务';
                }
                if (category !== categoryName) return;
                const isEarn = t.type ? t.type === 'earn' : t.amount > 0;
                if (typeKey === 'earn' && !isEarn) return;
                if (typeKey === 'spend' && isEarn) return;
                const amount = Math.abs(t.amount);
                taskMap.set(taskName, (taskMap.get(taskName) || 0) + amount);
            });

            const tasksArr = Array.from(taskMap.entries()).map(([name, value]) => ({ name, value }))
                .sort((a, b) => b.value - a.value);
            const total = tasksArr.reduce((sum, item) => sum + item.value, 0);
            const maxVal = tasksArr.length > 0 ? tasksArr[0].value : 1;

            title.textContent = `${periodLabel} · ${categoryName} · 详情`;

            if (total === 0) {
                content.innerHTML = `<div class="empty-message">此周期该分类暂无${typeLabel}记录</div>`;
                modal.classList.add('show');
                return;
            }

            const colors = generateCategoryTaskColors(getCategoryColorSafe(categoryName), tasksArr.length);
            const slices = [];
            let accum = 0;
            tasksArr.forEach((item, idx) => {
                const percent = (item.value / total) * 100;
                slices.push({
                    name: item.name,
                    value: item.value,
                    percent,
                    start: accum,
                    end: accum + percent,
                    color: colors[idx] || '#7c4dff'
                });
                accum += percent;
            });
            const conicGradient = `conic-gradient(from 0deg, ${slices.map(s => `${s.color} ${s.start}% ${s.end}%`).join(', ')})`;
            const totalMinutes = Math.max(0, Math.round(total / 60));
            const totalHoursPart = Math.floor(totalMinutes / 60);
            const totalMinutesPart = totalMinutes % 60;
            const centerLine1 = `总${typeLabel}`;
            const centerLine2 = `${totalHoursPart}小时`;
            const centerLine3 = `${totalMinutesPart}分`;

            const listHtml = slices.map((s, idx) => {
                const percentText = `${s.percent.toFixed(0)}%`;
                const barPercent = maxVal > 0 ? Math.max(6, (s.value / maxVal) * 100) : 0; // 保持最短条可见
                return `<div class="leaderboard-item category-detail-item" title="${escapeHtml(s.name)}" style="gap: 10px; margin-bottom: 6px;">
                            <div class="leaderboard-label"><span class="color-dot" style="background:${s.color}"></span>${escapeHtml(s.name)}</div>
                            <div class="leaderboard-bar-wrapper" style="background: var(--border-color); height: 18px; border-radius: 4px;">
                                <div class="leaderboard-bar" style="width: ${barPercent}%; background-color: ${s.color}; height: 18px; border-radius: 4px;"></div>
                                <span class="leaderboard-bar-value">${formatTime(s.value)} · ${percentText}</span>
                            </div>
                        </div>`;
            }).join('');

            content.innerHTML = `
                <div class="category-detail-summary" style="padding: 4px 4px 6px; border-bottom: 1px solid var(--border-color); margin-bottom: 6px;">
                    <span class="category-detail-meta">${typeLabel}时长：${formatTime(total)}</span>
                </div>
                <div class="category-detail-list">${listHtml}</div>
            `;
            modal.classList.add('show');
        }

        // 分类视图中“其他”分类的详情（列出被合并的分类）
        function showOtherCategoriesDetail(otherCategories, typeKey = 'earn', fromPie = false) {
            const modal = document.getElementById('categoryDetailModal');
            const title = document.getElementById('categoryDetailModalTitle');
            const content = document.getElementById('categoryDetailContent');
            if (!modal || !title || !content || !otherCategories || otherCategories.length === 0) return;
            
            // 长按饼图进入时添加展开动画（只在关闭弹窗时移除，避免触发二次动画）
            if (fromPie) {
                modal.classList.add('from-pie');
            }

            const periodLabelMap = { '7d': '7天内', '30d': '30天内', 'all': '全部' };
            const typeLabel = typeKey === 'earn' ? '获得' : '消费';
            const periodLabel = periodLabelMap[reportState.analysisPeriod] || '全部';

            // 确保按数值排序
            const sorted = [...otherCategories].sort((a, b) => (b.value || 0) - (a.value || 0));
            const total = sorted.reduce((sum, c) => sum + (c.value || 0), 0);
            const maxVal = sorted.length > 0 ? (sorted[0].value || 1) : 1;

            title.textContent = `${periodLabel} · 其他分类 · 详情`;

            if (total === 0) {
                content.innerHTML = `<div class="empty-message">此周期其他分类暂无${typeLabel}记录</div>`;
                modal.classList.add('show');
                return;
            }

            const listHtml = sorted.map((cat, idx) => {
                const percent = total > 0 ? (cat.value / total) * 100 : 0;
                const percentText = `${percent.toFixed(0)}%`;
                const barPercent = maxVal > 0 ? Math.max(6, (cat.value / maxVal) * 100) : 0;
                const color = cat.color || getCategoryColorSafe(cat.name);
                const encodedName = encodeURIComponent(cat.name);
                return `<div class="leaderboard-item category-detail-item other-category-row" data-cat-name="${encodedName}" style="gap: 10px; margin-bottom: 6px; cursor: pointer;">
                            <div class="leaderboard-label"><span class="color-dot" style="background:${color}"></span>${escapeHtml(cat.name)}</div>
                            <div class="leaderboard-bar-wrapper" style="background: var(--border-color); height: 18px; border-radius: 4px;">
                                <div class="leaderboard-bar" style="width: ${barPercent}%; background-color: ${color}; height: 18px; border-radius: 4px;"></div>
                                <span class="leaderboard-bar-value">${formatTime(cat.value)} · ${percentText}</span>
                            </div>
                        </div>`;
            }).join('');

            content.innerHTML = `
                <div class="category-detail-summary" style="padding: 4px 4px 6px; border-bottom: 1px solid var(--border-color); margin-bottom: 6px;">
                    <span class="category-detail-meta">${typeLabel}时长：${formatTime(total)}</span>
                </div>
                <div class="category-detail-list">${listHtml}</div>
            `;

            // 行点击可跳转到具体分类详情
            content.querySelectorAll('.other-category-row').forEach(row => {
                const encodedName = row.dataset.catName;
                if (!encodedName) return;
                const catName = decodeURIComponent(encodedName);
                row.addEventListener('click', () => showCategoryDetail(catName, typeKey));
            });

            modal.classList.add('show');
        }

        // [v5.1.0] 显示"其他"任务详情弹窗（任务视图）
        function showOtherTasksDetail(otherTasks, typeKey = 'earn', fromPie = false) {
            const modal = document.getElementById('categoryDetailModal');
            const title = document.getElementById('categoryDetailModalTitle');
            const content = document.getElementById('categoryDetailContent');
            if (!modal || !title || !content || !otherTasks || otherTasks.length === 0) return;
            
            // 长按饼图进入时添加展开动画（只在关闭弹窗时移除，避免触发二次动画）
            if (fromPie) {
                modal.classList.add('from-pie');
            }

            const periodLabelMap = { '7d': '7天内', '30d': '30天内', 'all': '全部' };
            const typeLabel = typeKey === 'earn' ? '获得' : '消费';
            const periodLabel = periodLabelMap[reportState.analysisPeriod] || '全部';

            const total = otherTasks.reduce((sum, t) => sum + t.value, 0);
            const maxVal = otherTasks.length > 0 ? otherTasks[0].value : 1;

            title.textContent = `${periodLabel} · 其他任务 · 详情`;

            // [v5.1.0] 10级渐变色覆盖所有任务
            const earnGradient10 = ['#2E7D32', '#388E3C', '#43A047', '#4CAF50', '#66BB6A', '#81C784', '#A5D6A7', '#C8E6C9', '#E8F5E9', '#F1F8E9'];
            const spendGradient10 = ['#C62828', '#D32F2F', '#E53935', '#F44336', '#EF5350', '#E57373', '#EF9A9A', '#FFCDD2', '#FFEBEE', '#FFF3E0'];
            const colorPalette = typeKey === 'earn' ? earnGradient10 : spendGradient10;
            
            const listHtml = otherTasks.map((t, idx) => {
                const percent = total > 0 ? (t.value / total) * 100 : 0;
                const percentText = `${percent.toFixed(0)}%`;
                const barPercent = maxVal > 0 ? Math.max(6, (t.value / maxVal) * 100) : 0;
                const color = idx < colorPalette.length ? colorPalette[idx] : OTHER_COLOR;
                return `<div class="leaderboard-item category-detail-item" title="${escapeHtml(t.name)}" style="gap: 10px; margin-bottom: 6px; cursor: pointer;" onclick="showTaskHistory('${t.taskId}')">
                            <div class="leaderboard-label"><span class="color-dot" style="background:${color}"></span>${escapeHtml(t.name)}</div>
                            <div class="leaderboard-bar-wrapper" style="background: var(--border-color); height: 18px; border-radius: 4px;">
                                <div class="leaderboard-bar" style="width: ${barPercent}%; background-color: ${color}; height: 18px; border-radius: 4px;"></div>
                                <span class="leaderboard-bar-value">${formatTime(t.value)} · ${percentText}</span>
                            </div>
                        </div>`;
            }).join('');

            content.innerHTML = `
                <div class="category-detail-summary" style="padding: 4px 4px 6px; border-bottom: 1px solid var(--border-color); margin-bottom: 6px;">
                    <span class="category-detail-meta">${typeLabel}时长：${formatTime(total)}</span>
                </div>
                <div class="category-detail-list">${listHtml}</div>
            `;
            modal.classList.add('show');
        }
        
        // [v4.5.2] FIX: Removed setTimeout and added rAF + cAF
        function renderPieCharts(data, filteredTransactions) {
            const container = document.getElementById('pieChartContainerWrapper');
            const earnData = data.filter(d => d.earned > 0).sort((a, b) => b.earned - a.earned);
            const spendData = data.filter(d => d.spent > 0).sort((a, b) => b.spent - a.spent);
            const createPieChartHTML = (type) => `<div class="pie-chart-wrapper" id="pieWrapper-${type}"></div>`;

            const buildCategoryTaskBreakdown = () => {
                if (!filteredTransactions || reportState.analysisView !== 'category') return null;
                const breakdown = new Map();
                filteredTransactions.forEach(t => {
                    // [v5.2.0] 支持系统交易的分类细分
                    // [v5.10.0] 修复：使用 getTransactionCategory 获取自定义分类
                    let categoryName, taskName;
                    if (t.isSystem) {
                        categoryName = getTransactionCategory(t);
                        taskName = t.taskName || '系统任务';
                    } else {
                        const task = tasks.find(tsk => tsk.id === t.taskId);
                        categoryName = task?.category;
                        if (!categoryName) return;
                        taskName = task?.name || t.taskName || '未知任务';
                    }
                    const isEarn = t.type ? t.type === 'earn' : t.amount > 0;
                    const typeKey = isEarn ? 'earn' : 'spend';
                    if (!breakdown.has(categoryName)) breakdown.set(categoryName, { earn: new Map(), spend: new Map() });
                    const typeMap = breakdown.get(categoryName)[typeKey];
                    typeMap.set(taskName, (typeMap.get(taskName) || 0) + Math.abs(t.amount));
                });
                const result = new Map();
                breakdown.forEach((value, categoryName) => {
                    const earnArr = Array.from(value.earn.entries()).map(([name, val]) => ({ name, value: val })).sort((a, b) => b.value - a.value);
                    const spendArr = Array.from(value.spend.entries()).map(([name, val]) => ({ name, value: val })).sort((a, b) => b.value - a.value);
                    result.set(categoryName, { earn: earnArr, spend: spendArr });
                });
                return result;
            };

            const categoryTaskBreakdown = buildCategoryTaskBreakdown();
            
            // 1. 同步清空 DOM
            container.innerHTML = `<div class="swiper-container" id="pieSwiperContainer"><div class="swiper-wrapper"><div class="swiper-slide">${createPieChartHTML('earn')}</div><div class="swiper-slide">${createPieChartHTML('spend')}</div></div></div><div class="swiper-pagination" id="pieSwiperPagination"></div>`;
            
            // 2. 同步强制回流
            container.getBoundingClientRect(); 

            // 3. (cAF 防护) 取消上一个待处理的帧
            if (pendingPieRender) {
                cancelAnimationFrame(pendingPieRender);
            }

            // 4. (rAF 优化) 请求下一帧绘制
            pendingPieRender = requestAnimationFrame(() => {
                renderSinglePie('earn', earnData, reportState.analysisView, categoryTaskBreakdown); 
                renderSinglePie('spend', spendData, reportState.analysisView, categoryTaskBreakdown); 
                setupSwiper('pieSwiperContainer', 'pieSwiperPagination', (index) => { 
                    setInsightSubViewIndex(index); 
                    // [v6.0.0] 切换饼图时更新KPI卡片
                    if (cachedAnalysisFilteredTransactions.length > 0 && cachedAnalysisAggregatedData.length > 0) {
                        renderKpiCards(cachedAnalysisFilteredTransactions, cachedAnalysisAggregatedData, index);
                    }
                    // [v6.0.0] 切换饼图只保存本地，不触发云同步（避免同步回调导致二次刷新）
                    try { 
                        localStorage.setItem('timeBankData', JSON.stringify({ 
                            version: APP_VERSION, currentBalance, tasks, transactions, 
                            categoryColors: [...categoryColors], collapsedCategories: [...collapsedCategories], 
                            runningTasks: [...runningTasks], dailyChanges, notificationSettings, reportState 
                        })); 
                    } catch(e) {} 
                }); 
                initPieTooltips(); // [v5.1.0] 饼图长按弹窗
                pendingPieRender = null; // 完成后重置
            });
        }

        function renderSinglePie(type, sourceData, view, categoryTaskBreakdown) {
            const wrapper = document.getElementById(`pieWrapper-${type}`);
            if (!wrapper) return;
            const valueKey = type === 'earn' ? 'earned' : 'spent';
            const totalValue = sourceData.reduce((sum, item) => sum + item[valueKey], 0);
            if (totalValue === 0) { wrapper.innerHTML = `<div class="empty-message" style="padding: 20px 0; color: var(--text-color-light);">无${type === 'earn' ? '获得' : '消费'}数据</div>`; return; }
            let processedData = []; let otherValue = 0; let otherTasks = []; let otherCategories = []; const topN = view === 'task' ? 5 : 4; 
            sourceData.forEach((item, index) => { 
                if (index < topN) {
                    // 任务视图时查找taskId
                    let taskId = null;
                    if (view === 'task' && item.name !== '其他') {
                        const task = tasks.find(t => t.name === item.name);
                        if (task) taskId = task.id;
                    }
                    processedData.push({ name: item.name, value: item[valueKey], taskId }); 
                } else {
                    otherValue += item[valueKey];
                    // 任务视图时保存第6-15名任务详情
                    if (view === 'task' && index < 15) {
                        const task = tasks.find(t => t.name === item.name);
                        otherTasks.push({ name: item.name, value: item[valueKey], taskId: task?.id || null });
                    }
                    // 分类视图：记录被合并的其他分类以便展示详情
                    if (view === 'category') {
                        otherCategories.push({ name: item.name, value: item[valueKey], color: getCategoryColorSafe(item.name) });
                    }
                }
            });
            if (otherValue > 0) processedData.push({ name: '其他', value: otherValue, taskId: null, otherTasks, otherCategories });
            const isCategoryView = view === 'category';
            // [v6.0.0] 任务视图使用分类颜色+递减色阶；"其他"使用与饼图类型协调的颜色
            const taskColorMap = !isCategoryView ? buildTaskViewColorMap(processedData) : null;
            const otherColor = type === 'earn' ? OTHER_EARN_COLOR : OTHER_SPEND_COLOR;
            let currentAngle = 0;
            const gradientParts = processedData.map((item, index) => { const percent = (item.value / totalValue) * 100; let color; if (item.name === '其他') { color = otherColor; } else if (!isCategoryView) { color = taskColorMap.get(item.name) || otherColor; } else { color = getCategoryColorSafe(item.name); } item.color = color; const startAngle = currentAngle; const endAngle = currentAngle + percent; currentAngle = endAngle; return `${color} ${startAngle}% ${endAngle}%`; });
            const conicGradient = `conic-gradient(from 0deg, ${gradientParts.join(', ')})`;
            const legendHTML = isCategoryView ? '' : `<div class="pie-chart-legend">${processedData.map(item => `<div class="pie-legend-item"><div class="pie-legend-color-box" style="background-color: ${item.color};"></div>${item.name}</div>`).join('')}</div>`;
            const slices = []; let accum = 0;
            processedData.forEach(item => {
                const percent = (item.value / totalValue) * 100;
                const taskBreakdown = isCategoryView && categoryTaskBreakdown ? (type === 'earn' ? categoryTaskBreakdown.get(item.name)?.earn : categoryTaskBreakdown.get(item.name)?.spend) : null;
                slices.push({ name: item.name, value: item.value, percent, start: accum, end: accum + percent, tasks: taskBreakdown || [], typeKey: type, taskId: item.taskId || null, otherTasks: item.otherTasks || [], otherCategories: item.otherCategories || [], color: item.color });
                accum += percent;
            });
            const totalMinutes = Math.max(0, Math.round(totalValue / 60));
            const totalHoursPart = Math.floor(totalMinutes / 60);
            const totalMinutesPart = totalMinutes % 60;
            const centerLine1 = `总${type === 'earn' ? '获得' : '消费'}`;
            const centerLine2 = `${totalHoursPart}小时`;
            const centerLine3 = `${totalMinutesPart}分`;
            wrapper.innerHTML = `<div class="pie-chart-container" data-pie-meta="${encodeURIComponent(JSON.stringify({ typeLabel: type === 'earn' ? '获得' : '消费', typeKey: type, totalValue, view, slices }))}"><div class="pie-chart" style="background: ${conicGradient};"></div><div class="pie-slice-labels"></div><div class="pie-chart-center"><div class="pie-center-title">${centerLine1}</div><div class="pie-center-value">${centerLine2}</div><div class="pie-center-value">${centerLine3}</div></div></div>${legendHTML}`;
            const labelsContainer = wrapper.querySelector('.pie-slice-labels'); const pieContainer = wrapper.querySelector('.pie-chart-container'); if (!pieContainer || !labelsContainer) return;
            // [v5.4.0] 生成底层 SVG 高亮层（预渲染 base 和 expanded 两套路径）
            const pieSize = 180;
            const expand = 10;
            const svgSize = pieSize + expand * 2;
            const cx = svgSize / 2;
            const cy = svgSize / 2;
            const r0Base = pieSize * 0.195;
            const r1Base = pieSize / 2;
            const r0Expanded = r0Base;
            const r1Expanded = r1Base + expand;
            const toRad = deg => (deg - 90) * Math.PI / 180;
            const buildWedge = (r0, r1, startDeg, endDeg) => {
                let angleDiff = endDeg - startDeg;
                if (angleDiff <= 0 || angleDiff > 360) return '';
                if (angleDiff > 359.9) angleDiff = 359.9;
                const actualEndDeg = startDeg + angleDiff;
                const largeArc = angleDiff > 180 ? 1 : 0;
                const p1 = { x: cx + r1 * Math.cos(toRad(actualEndDeg)), y: cy + r1 * Math.sin(toRad(actualEndDeg)) };
                const p2 = { x: cx + r1 * Math.cos(toRad(startDeg)), y: cy + r1 * Math.sin(toRad(startDeg)) };
                const p3 = { x: cx + r0 * Math.cos(toRad(startDeg)), y: cy + r0 * Math.sin(toRad(startDeg)) };
                const p4 = { x: cx + r0 * Math.cos(toRad(actualEndDeg)), y: cy + r0 * Math.sin(toRad(actualEndDeg)) };
                return `M ${p1.x} ${p1.y} A ${r1} ${r1} 0 ${largeArc} 0 ${p2.x} ${p2.y} L ${p3.x} ${p3.y} A ${r0} ${r0} 0 ${largeArc} 1 ${p4.x} ${p4.y} Z`;
            };
            let highlightPaths = '';
            slices.forEach(slice => {
                const startDeg = (slice.start / 100) * 360;
                const endDeg = (slice.end / 100) * 360;
                const dBase = buildWedge(r0Base, r1Base, startDeg, endDeg);
                const dExpanded = buildWedge(r0Expanded, r1Expanded, startDeg, endDeg);
                if (!dBase) return;
                highlightPaths += `<path class="pie-highlight-slice" data-slice-name="${slice.name}" data-d-base="${dBase}" data-d-expanded="${dExpanded}" fill="${slice.color}" d="${dBase}"/>`;
            });
            const highlightSVG = `<svg class="pie-highlight-layer" width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">${highlightPaths}</svg>`;
            pieContainer.insertAdjacentHTML('afterbegin', highlightSVG);
            const centerX = pieContainer.offsetWidth / 2; const centerY = pieContainer.offsetHeight / 2; startAngle = -Math.PI / 2;
            processedData.forEach(item => {
                const percent = item.value / totalValue;
                const sliceAngle = 2 * Math.PI * percent;
                const midAngle = startAngle + sliceAngle / 2;
                const labelRadiusFactor = 0.725;
                const labelX = centerX + (centerX * labelRadiusFactor) * Math.cos(midAngle);
                const labelY = centerY + (centerY * labelRadiusFactor) * Math.sin(midAngle);
                const labelEl = document.createElement('div');
                labelEl.className = 'pie-slice-label';
                const percentText = `${(percent * 100).toFixed(0)}%`;
                if (isCategoryView) {
                    // 低于5%也显示名称和占比，但不显示时长
                    if (percent < 0.05) {
                        labelEl.innerHTML = `${item.name}<br>${percentText}`;
                    } else {
                        labelEl.innerHTML = `${item.name}<br>${percentText}<br><span class="time-value">${formatTimeForPie(item.value)}</span>`;
                    }
                } else {
                    // 任务视图：低于5%显示百分比，达标则显示时间
                    if (percent < 0.05) {
                        labelEl.innerHTML = `${percentText}`;
                    } else {
                        labelEl.innerHTML = `${percentText} <br> <span class="time-value">${formatTime(item.value)}</span>`;
                    }
                }
                labelEl.style.left = `${labelX}px`;
                labelEl.style.top = `${labelY}px`;
                labelsContainer.appendChild(labelEl);
                startAngle += sliceAngle;
            });
        }
        
        function updateTrendChart() { 
            const container = document.getElementById('trendChartContainerWrapper'); 
            const filtersHTML = `<div class="analysis-filters"> <div> <div class="analysis-view-switcher report-filters"> <button class="${reportState.trendView === 'category' ? 'active' : ''}" onclick="setTrendView('category')">分类</button> <button class="${reportState.trendView === 'task' ? 'active' : ''}" onclick="setTrendView('task')">任务</button> </div> </div> <div class="report-filters"> <button class="${reportState.trendPeriod === '7d' ? 'active' : ''}" onclick="setTrendPeriod('7d')">7天内</button> <button class="${reportState.trendPeriod === '30d' ? 'active' : ''}" onclick="setTrendPeriod('30d')">30天内</button> </div> </div>`; 
            const chartsHTML = `<div class="swiper-container" id="trendSwiperContainer"><div class="swiper-wrapper" id="trendSwiperWrapper"></div></div><div class="swiper-pagination" id="trendSwiperPagination"></div>`; 
            container.innerHTML = filtersHTML + chartsHTML; 
            const filteredTransactions = getFilteredTransactions(reportState.trendPeriod); 
            const { aggregatedData, trendData } = processDashboardData(filteredTransactions, reportState.trendView); 
            const earnChartHTML = createSingleTrendChartHTML('earned', trendData, aggregatedData); 
            const spendChartHTML = createSingleTrendChartHTML('spent', trendData, aggregatedData); 
            document.getElementById('trendSwiperWrapper').innerHTML = `<div class="swiper-slide">${earnChartHTML}</div><div class="swiper-slide">${spendChartHTML}</div>`; 
            setupSwiper('trendSwiperContainer', 'trendSwiperPagination');
            initTrendTooltips();
        }
function createSingleTrendChartHTML(type, trendData, allAggregatedData) {
    const valueKey = type;
    const title = valueKey === 'earned' ? '获得时间趋势' : '消费时间趋势';
    const daysCount = reportState.trendPeriod === '30d' ? 30 : 7;
    const fullDates = [];
    const today = new Date();
    for (let i = daysCount - 1; i >= 0; i--) {
        const d = new Date(today);
        d.setDate(today.getDate() - i);
        fullDates.push(getLocalDateString(d));
    }

    const isTaskView = reportState.trendView === 'task';
    // 分类视图：显示全部分类；任务视图：显示前5个
    const topN = isTaskView ? 5 : 999;
    const topItemsData = allAggregatedData
        .filter(d => d[valueKey] > 0)
        .sort((a, b) => b[valueKey] - a[valueKey])
        .slice(0, topN);
    const topItems = new Set(topItemsData.map(d => d.name));
    // [v6.0.0] 任务视图使用分类颜色+递减色阶；“其他”使用与图表类型协调的颜色
    const colorMap = isTaskView ? buildTaskViewColorMap(topItemsData) : null;
    const otherColor = type === 'earned' ? OTHER_EARN_COLOR : OTHER_SPEND_COLOR;
    const maxDailyTotal = Math.max(
        1,
        ...fullDates.map(date => {
            if (!trendData[date] || !trendData[date][type]) return 0;
            return Object.values(trendData[date][type]).reduce((sum, val) => sum + val, 0);
        })
    );

    const daysHTML = fullDates
        .map((date, index) => {
            const dayData = trendData[date] && trendData[date][type] ? trendData[date][type] : {};
            let dailyTotal = 0;
            let othersValue = 0;
            const segments = [];
            const tooltipEntries = {};

            for (const name in dayData) {
                const value = dayData[name];
                dailyTotal += value;
                tooltipEntries[name] = value;
                if (topItems.has(name)) {
                    segments.push({ name, value });
                } else {
                    othersValue += value;
                }
            }

            if (othersValue > 0) {
                segments.push({ name: '其他', value: othersValue });
                tooltipEntries['其他'] = othersValue;
            }

            const tooltipRowsHtml =
                dailyTotal > 0
                    ? Object.entries(tooltipEntries)
                          .sort((a, b) => b[1] - a[1])
                          .map(
                              ([name, value]) =>
                                  `<div class="trend-tooltip-row"><span>${escapeHtml(name)}</span><span>${formatTime(value)}</span></div>`
                          )
                          .join('')
                    : '';

            const tooltipHtml =
                dailyTotal > 0
                    ? `<span class="trend-tooltip-title">${date}</span><div class="trend-tooltip-list">${tooltipRowsHtml}</div><div class="trend-tooltip-total">总计: ${formatTime(dailyTotal)}</div>`
                    : '';

            const tooltipAttr = dailyTotal > 0 ? `data-tooltip="${encodeURIComponent(tooltipHtml)}"` : '';

            const segmentsHTML = segments
                .sort((a, b) => b.value - a.value)
                .map(item => {
                    const height = dailyTotal > 0 ? (item.value / dailyTotal) * 100 : 0;
                    let color;
                    if (item.name === '其他') {
                        color = otherColor;
                    } else if (isTaskView) {
                        color = colorMap.get(item.name);
                    } else {
                        color = getCategoryColorSafe(item.name);
                    }
                    return `<div class="trend-segment" style="height: ${height}%; background-color: ${color || '#ccc'}"></div>`;
                })
                .join('');

            const totalHeight = maxDailyTotal > 0 ? (dailyTotal / maxDailyTotal) * 100 : 0;
            const showLabel = daysCount <= 10 || index % 2 === 0;
            const dateLabel = showLabel ? new Date(date).getDate() : '';
            const interactionStyle = dailyTotal > 0 ? 'cursor: pointer;' : 'pointer-events: none;';

            return `<div> <div class="trend-day" data-date="${date}" style="height: 150px; ${interactionStyle}" ${tooltipAttr}> <div style="height:${totalHeight}%; width: 100%; display: flex; flex-direction: column; justify-content: flex-end; border-radius: 4px; overflow: hidden; background-color: rgba(0,0,0,0.05);"> ${segmentsHTML} </div> </div> <div class="trend-date-label">${dateLabel}</div> </div>`;
        })
        .join('');

    const legendItems = [...topItemsData];
    // 任务视图：显示"其他"图例；分类视图：已显示全部，无需"其他"
    if (isTaskView && allAggregatedData.filter(d => d[valueKey] > 0).length > topN) legendItems.push({ name: '其他' });

    const legendHTML = legendItems
        .map((item, index) => {
            let color;
            if (item.name === '其他') {
                color = otherColor;
            } else if (isTaskView) {
                color = colorMap.get(item.name) || otherColor;
            } else {
                color = getCategoryColorSafe(item.name);
            }
            return `<div class="legend-item"> <div class="legend-color-box" style="background-color:${color || '#ccc'};"></div> <div class="legend-label">${item.name}</div> </div>`;
        })
        .join('');

    const gridGap = daysCount > 10 ? '1px' : '8px';
    const gridStyle = `display: grid; grid-template-columns: repeat(${daysCount}, minmax(0, 1fr)); gap: ${gridGap};`;

    return `<div class="chart-container"><div class="chart-title">${title}</div><div class="trend-chart" style="${gridStyle}">${daysHTML}</div><div class="chart-legend">${legendHTML}</div></div>`;
}

let trendTooltipLongPressTimer = null;
let trendTooltipGlobalListenersBound = false;
// ====== ⭐ CRITICAL: 趋势演变防误触机制 - 修改前请仔细检查 ======
// 1. TREND_SWIPE_THRESHOLD: 滑动阈值(15px)，超过则取消长按
// 2. setPointerCapture: 长按激活后接管指针事件防止滚动
// 3. evt.preventDefault/stopPropagation: 长按状态下阻止默认行为
// 4. pointermove { passive: false, capture: true }: 确保能阻断事件
// 5. trendTooltipLongPressCooldown: 防止pointerup后touchend误触发滑动
// =============================================================
let trendTooltipPointerId = null;
let trendTooltipLongPressActive = false;
let trendTooltipLongPressCooldown = false; // [v5.3.0] 防止touchend误触发滑动
let trendTooltipActiveBar = null;
let trendTooltipMoveHandler = null;
let trendTooltipEndHandler = null;
let trendTooltipStartX = 0;
let trendTooltipStartY = 0;
const TREND_SWIPE_THRESHOLD = 15; // pixels to cancel long-press and allow swipe

function hideTrendTooltip() {
    const tooltipEl = document.getElementById('trendTooltip');
    if (!tooltipEl) return;
    tooltipEl.classList.remove('show', 'moving');
    // 清理节流和RAF
    clearTimeout(trendTooltipContentUpdateTimer);
    if (trendTooltipRAFId) cancelAnimationFrame(trendTooltipRAFId);
    trendTooltipLastTarget = null;
}

function clearTrendActiveBar() {
    document.querySelectorAll('.trend-day.active').forEach(el => el.classList.remove('active'));
    trendTooltipActiveBar = null;
}

function positionTrendTooltip(target, tooltipEl) {
    const rect = target.getBoundingClientRect();
    const tooltipRect = tooltipEl.getBoundingClientRect();
    const margin = 8;
    let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
    left = Math.max(margin, Math.min(left, window.innerWidth - tooltipRect.width - margin));
    let top = rect.top - tooltipRect.height - 10;
    if (top < margin) {
        top = rect.bottom + 10;
    }
    tooltipEl.style.left = `${left}px`;
    tooltipEl.style.top = `${top}px`;
}

// 节流和RAF优化变量
let trendTooltipContentUpdateTimer = null;
let trendTooltipLastTarget = null;
let trendTooltipRAFId = null;

function showTrendTooltip(target, isMoving = false) {
    const tooltipEl = document.getElementById('trendTooltip');
    if (!tooltipEl) return;
    const encoded = target.getAttribute('data-tooltip');
    if (!encoded) return;
    
    const wasShown = tooltipEl.classList.contains('show');
    
    // 如果是切换柱子，添加moving类
    if (isMoving && wasShown) {
        tooltipEl.classList.add('moving');
        
        // 位置立即用RAF更新（流畅跟随）
        if (trendTooltipRAFId) cancelAnimationFrame(trendTooltipRAFId);
        trendTooltipRAFId = requestAnimationFrame(() => {
            positionTrendTooltip(target, tooltipEl);
        });
        
        // 内容节流更新（避免闪烁）- 如果目标不同才更新
        if (target !== trendTooltipLastTarget) {
            clearTimeout(trendTooltipContentUpdateTimer);
            trendTooltipContentUpdateTimer = setTimeout(() => {
                tooltipEl.innerHTML = `<div class="trend-tooltip-content">${decodeURIComponent(encoded)}</div>`;
            }, 50); // 50ms节流
        }
        trendTooltipLastTarget = target;
    } else {
        // 首次显示：立即更新内容和位置
        tooltipEl.classList.remove('moving');
        tooltipEl.innerHTML = `<div class="trend-tooltip-content">${decodeURIComponent(encoded)}</div>`;
        tooltipEl.classList.add('show');
        positionTrendTooltip(target, tooltipEl);
        trendTooltipLastTarget = target;
    }
}

function bindTrendTooltipGlobalListeners() {
    if (trendTooltipGlobalListenersBound) return;
    window.addEventListener('scroll', hideTrendTooltip, true);
    window.addEventListener('resize', hideTrendTooltip);
    trendTooltipGlobalListenersBound = true;
}

function initTrendTooltips() {
    const tooltipEl = document.getElementById('trendTooltip');
    if (!tooltipEl) return;
    hideTrendTooltip();
    bindTrendTooltipGlobalListeners();

    const bars = document.querySelectorAll('.trend-day[data-tooltip]');
    bars.forEach(bar => {
        const showHandler = () => {
            if (trendTooltipLongPressActive) return;
            clearTrendActiveBar();
            showTrendTooltip(bar);
        };
        const hideHandler = () => {
            if (trendTooltipLongPressActive) return;
            hideTrendTooltip();
            clearTrendActiveBar();
        };

        bar.addEventListener('mouseenter', showHandler);
        bar.addEventListener('mouseleave', hideHandler);
        bar.addEventListener('focus', showHandler);
        bar.addEventListener('blur', hideHandler);
        bar.addEventListener('pointerdown', e => {
            if (e.pointerType === 'mouse') return; // 长按仅针对触控/触笔
            clearTimeout(trendTooltipLongPressTimer);
            trendTooltipPointerId = e.pointerId;
            trendTooltipLongPressActive = false;
            trendTooltipActiveBar = bar;
            trendTooltipStartX = e.clientX;
            trendTooltipStartY = e.clientY;

            const moveHandler = evt => {
                if (evt.pointerId !== trendTooltipPointerId) return;

                // 长按已激活：处理柱子切换
                if (trendTooltipLongPressActive) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    const target = document.elementFromPoint(evt.clientX, evt.clientY);
                    const newBar = target ? target.closest('.trend-day[data-tooltip]') : null;
                    if (newBar && newBar !== trendTooltipActiveBar) {
                        trendTooltipActiveBar = newBar;
                        clearTrendActiveBar();
                        newBar.classList.add('active');
                        showTrendTooltip(newBar, true); // isMoving=true 实现流畅位置过渡
                    }
                } else {
                    // 长按未激活：检测是否为滑动意图
                    const dx = Math.abs(evt.clientX - trendTooltipStartX);
                    const dy = Math.abs(evt.clientY - trendTooltipStartY);
                    if (dx > TREND_SWIPE_THRESHOLD || dy > TREND_SWIPE_THRESHOLD) {
                        // 用户意图是滑动，取消长按
                        clearTimeout(trendTooltipLongPressTimer);
                        trendTooltipPointerId = null;
                        trendTooltipActiveBar = null;
                        window.removeEventListener('pointermove', trendTooltipMoveHandler, true);
                        window.removeEventListener('pointerup', trendTooltipEndHandler, true);
                        window.removeEventListener('pointercancel', trendTooltipEndHandler, true);
                        trendTooltipMoveHandler = null;
                        trendTooltipEndHandler = null;
                    }
                }
            };

            const endHandler = evt => {
                if (trendTooltipPointerId !== null && evt.pointerId !== trendTooltipPointerId) return;
                clearTimeout(trendTooltipLongPressTimer);
                // [v5.3.0] 设置 cooldown 防止 touchend 误触发滑动切换
                const wasLongPressActive = trendTooltipLongPressActive;
                if (wasLongPressActive) {
                    trendTooltipLongPressCooldown = true;
                    setTimeout(() => { trendTooltipLongPressCooldown = false; }, 100);
                }
                if (trendTooltipLongPressActive && trendTooltipActiveBar) {
                    // 释放 pointer capture
                    try { trendTooltipActiveBar.releasePointerCapture(evt.pointerId); } catch(e) {}
                    const date = trendTooltipActiveBar.getAttribute('data-date');
                    if (date) showDayDetails(date);
                }
                trendTooltipPointerId = null;
                trendTooltipLongPressActive = false;
                trendTooltipActiveBar = null;
                hideTrendTooltip();
                clearTrendActiveBar();
                window.removeEventListener('pointermove', trendTooltipMoveHandler, true);
                window.removeEventListener('pointerup', trendTooltipEndHandler, true);
                window.removeEventListener('pointercancel', trendTooltipEndHandler, true);
                trendTooltipMoveHandler = null;
                trendTooltipEndHandler = null;
            };

            trendTooltipMoveHandler = moveHandler;
            trendTooltipEndHandler = endHandler;
            window.addEventListener('pointermove', trendTooltipMoveHandler, { passive: false, capture: true });
            window.addEventListener('pointerup', trendTooltipEndHandler, true);
            window.addEventListener('pointercancel', trendTooltipEndHandler, true);

            trendTooltipLongPressTimer = setTimeout(() => {
                trendTooltipLongPressActive = true;
                // 使用 setPointerCapture 接管所有指针事件，防止页面滚动
                try { bar.setPointerCapture(trendTooltipPointerId); } catch(e) {}
                clearTrendActiveBar();
                bar.classList.add('active');
                showTrendTooltip(bar);
            }, 250);
        });
    });
}

// ========== 活动日历 Tooltip 交互 ==========
// ====== ⭐ CRITICAL: 活动日历防误触机制 - 修改前请仔细检查 ======
// 1. HEATMAP_SWIPE_THRESHOLD: 滑动阈值(10px)，超过则取消长按
// 2. setPointerCapture: 长按激活后接管指针事件防止滚动
// 3. setTimeout延迟清除长按状态: 确保touchend处理时状态仍为true
// 4. evt.preventDefault/stopPropagation/stopImmediatePropagation: 全面阻断
// 5. pointermove { passive: false, capture: true }: 确保能阻断事件
// =============================================================
let heatmapTooltipLongPressTimer = null;
let heatmapTooltipAutoOpenTimer = null; // 3秒自动打开详情
let heatmapTooltipPointerId = null;
let heatmapTooltipLongPressActive = false;
let heatmapTooltipActiveCell = null;
let heatmapTooltipMoveHandler = null;
let heatmapTooltipEndHandler = null;
let heatmapTooltipStartX = 0;
let heatmapTooltipStartY = 0;
let heatmapTooltipContentUpdateTimer = null;
let heatmapTooltipLastTarget = null;
let heatmapTooltipRAFId = null;
let heatmapTouchInteractionActive = false; // 触摸交互进行中，阻止mouseenter
const HEATMAP_SWIPE_THRESHOLD = 10; // 日历格子较小，阈值更低

function hideHeatmapTooltip() {
    const tooltipEl = document.getElementById('heatmapTooltip');
    if (!tooltipEl) return;
    
    // [v5.8.0] 如果tooltip正在显示，创建影子元素播放退出动画
    if (tooltipEl.classList.contains('show')) {
        const shadow = tooltipEl.cloneNode(true);
        shadow.id = '';
        shadow.classList.remove('show', 'flipping');
        shadow.classList.add('heatmap-tooltip-shadow');
        // 移除进度条，避免干扰
        const progressBar = shadow.querySelector('.heatmap-tooltip-progress');
        if (progressBar) progressBar.remove();
        document.body.appendChild(shadow);
        // 动画结束后移除影子
        shadow.addEventListener('animationend', () => shadow.remove(), { once: true });
    }
    
    tooltipEl.classList.remove('show', 'flipping');
    // 停止进度条动画并重置样式
    const progressBar = tooltipEl.querySelector('.heatmap-tooltip-progress');
    if (progressBar) {
        progressBar.classList.remove('animating');
        progressBar.style.display = ''; // 重置 display 样式
        progressBar.style.width = '0%';
    }
    clearTimeout(heatmapTooltipContentUpdateTimer);
    clearTimeout(heatmapTooltipAutoOpenTimer);
    if (heatmapTooltipRAFId) cancelAnimationFrame(heatmapTooltipRAFId);
    heatmapTooltipLastTarget = null;
}

function clearHeatmapActiveCell() {
    document.querySelectorAll('.heatmap-day.active').forEach(el => el.classList.remove('active'));
    heatmapTooltipActiveCell = null;
}

// 集中管理日历格子的 active 切换，避免遗漏清理
function setHeatmapActiveCell(cell) {
    clearHeatmapActiveCell();
    if (cell) {
        heatmapTooltipActiveCell = cell;
        cell.classList.add('active');
    }
}

function positionHeatmapTooltip(target, tooltipEl) {
    const rect = target.getBoundingClientRect();
    const tooltipRect = tooltipEl.getBoundingClientRect();
    const margin = 8;
    let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
    left = Math.max(margin, Math.min(left, window.innerWidth - tooltipRect.width - margin));
    let top = rect.top - tooltipRect.height - 10;
    if (top < margin) {
        top = rect.bottom + 10;
    }
    tooltipEl.style.left = `${left}px`;
    tooltipEl.style.top = `${top}px`;
}

function showHeatmapTooltip(target, isMoving = false) {
    const tooltipEl = document.getElementById('heatmapTooltip');
    if (!tooltipEl) return;
    const encoded = target.getAttribute('data-tooltip');
    if (!encoded) return;
    
    const wasShown = tooltipEl.classList.contains('show');
    
    if (isMoving && wasShown) {
        // [v5.8.0] 波浪翻页效果：旧位置播放退出动画，新位置播放进入动画
        if (target !== heatmapTooltipLastTarget) {
            // 创建影子元素在旧位置播放退出动画
            const shadow = tooltipEl.cloneNode(true);
            shadow.id = '';
            shadow.classList.remove('show', 'flipping');
            shadow.classList.add('heatmap-tooltip-shadow');
            // 移除进度条，避免干扰
            const progressBar = shadow.querySelector('.heatmap-tooltip-progress');
            if (progressBar) progressBar.remove();
            document.body.appendChild(shadow);
            // 动画结束后移除影子
            shadow.addEventListener('animationend', () => shadow.remove(), { once: true });
            
            // 将原 tooltip 移动到新位置并更新内容
            tooltipEl.innerHTML = decodeURIComponent(encoded);
            positionHeatmapTooltip(target, tooltipEl);
            
            // 触发翻页进入动画
            tooltipEl.classList.remove('flipping');
            void tooltipEl.offsetWidth;
            tooltipEl.classList.add('flipping');
            
            // 重置进度条
            startHeatmapAutoOpenTimer(target);
        }
        heatmapTooltipLastTarget = target;
    } else {
        // [v5.8.0] 首次显示也播放翻页动画
        tooltipEl.classList.remove('flipping');
        tooltipEl.innerHTML = decodeURIComponent(encoded);
        // 先使弹窗可测量但不可见，定位后再显示
        tooltipEl.style.visibility = 'hidden';
        tooltipEl.style.display = 'block';
        positionHeatmapTooltip(target, tooltipEl);
        tooltipEl.style.visibility = '';
        tooltipEl.style.display = '';
        tooltipEl.classList.add('show');
        // 触发翻页进入动画
        void tooltipEl.offsetWidth;
        tooltipEl.classList.add('flipping');
        heatmapTooltipLastTarget = target;
        // 启动3秒自动打开定时器
        startHeatmapAutoOpenTimer(target);
    }
}

// 启动3秒自动打开详情的定时器和进度条
function startHeatmapAutoOpenTimer(target) {
    clearTimeout(heatmapTooltipAutoOpenTimer);
    const tooltipEl = document.getElementById('heatmapTooltip');
    const progressBar = tooltipEl ? tooltipEl.querySelector('.heatmap-tooltip-progress') : null;
    
    if (progressBar) {
        // 重置进度条：先移除动画类和内联样式，然后用 RAF 添加动画类
        progressBar.classList.remove('animating');
        progressBar.style.width = '0%';
        progressBar.style.display = ''; // 确保可见
        requestAnimationFrame(() => {
            progressBar.style.width = ''; // 清除内联样式，让 CSS 类生效
            progressBar.classList.add('animating');
        });
    }
    
    // 3秒后自动打开详情（250ms激活 + 2750ms = 3秒总计）
    heatmapTooltipAutoOpenTimer = setTimeout(() => {
        if (heatmapTooltipLongPressActive && target) {
            const date = target.getAttribute('data-date');
            if (date) {
                // [v5.8.0] 进入详情页震动反馈
                if (typeof Android !== 'undefined' && Android.vibrate) {
                    Android.vibrate(20);
                } else if (navigator.vibrate) {
                    navigator.vibrate(20);
                }
                hideHeatmapTooltip();
                clearHeatmapActiveCell();
                heatmapTooltipLongPressActive = false;
                showDayDetailsWithAnimation(date);
            }
        }
    }, 2750);
}

function initHeatmapTooltips() {
    const tooltipEl = document.getElementById('heatmapTooltip');
    if (!tooltipEl) return;
    // [v5.4.0] 初始化前彻底清理旧状态，防止残留
    clearTimeout(heatmapTooltipLongPressTimer);
    clearTimeout(heatmapTooltipAutoOpenTimer);
    if (heatmapTooltipMoveHandler) {
        window.removeEventListener('pointermove', heatmapTooltipMoveHandler, true);
    }
    if (heatmapTooltipEndHandler) {
        window.removeEventListener('pointerup', heatmapTooltipEndHandler, true);
        window.removeEventListener('pointercancel', heatmapTooltipEndHandler, true);
    }
    heatmapTooltipMoveHandler = null;
    heatmapTooltipEndHandler = null;
    heatmapTooltipPointerId = null;
    heatmapTooltipLongPressActive = false;
    heatmapTouchInteractionActive = false;
    clearHeatmapActiveCell();
    hideHeatmapTooltip();

    const cells = document.querySelectorAll('.heatmap-day[data-tooltip]');
    cells.forEach(cell => {
        // 桌面端：hover显示tooltip（桌面端不启动自动打开计时器）
        cell.addEventListener('mouseenter', () => {
            if (heatmapTooltipLongPressActive || heatmapTouchInteractionActive) return;
            clearHeatmapActiveCell();
            // 桌面端hover时清除自动打开计时器
            clearTimeout(heatmapTooltipAutoOpenTimer);
            const tooltipEl = document.getElementById('heatmapTooltip');
            tooltipEl.classList.remove('moving');
            const encoded = cell.getAttribute('data-tooltip');
            if (!encoded) return;
            tooltipEl.innerHTML = decodeURIComponent(encoded);
            tooltipEl.classList.add('show');
            positionHeatmapTooltip(cell, tooltipEl);
            // 桌面端不显示进度条
            const progressBar = tooltipEl.querySelector('.heatmap-tooltip-progress');
            if (progressBar) progressBar.style.display = 'none';
        });
        cell.addEventListener('mouseleave', () => {
            if (heatmapTooltipLongPressActive) return;
            hideHeatmapTooltip();
            clearHeatmapActiveCell();
        });
        // 桌面端点击直接打开详情
        cell.addEventListener('click', (e) => {
            if (heatmapTooltipLongPressActive) return;
            const date = cell.getAttribute('data-date');
            if (date) showDayDetails(date);
        });

        // 移动端：长按拖动
        cell.addEventListener('pointerdown', e => {
            if (e.pointerType === 'mouse') return;
            // [v5.4.0] 新的 pointerdown 开始前，先清理之前可能残留的状态
            clearTimeout(heatmapTooltipLongPressTimer);
            clearTimeout(heatmapTooltipAutoOpenTimer);
            if (heatmapTooltipMoveHandler) {
                window.removeEventListener('pointermove', heatmapTooltipMoveHandler, true);
            }
            if (heatmapTooltipEndHandler) {
                window.removeEventListener('pointerup', heatmapTooltipEndHandler, true);
                window.removeEventListener('pointercancel', heatmapTooltipEndHandler, true);
            }
            clearHeatmapActiveCell();
            hideHeatmapTooltip();
            
            heatmapTouchInteractionActive = true;
            heatmapTooltipPointerId = e.pointerId;
            heatmapTooltipLongPressActive = false;
            heatmapTooltipStartX = e.clientX;
            heatmapTooltipStartY = e.clientY;

            const moveHandler = evt => {
                if (evt.pointerId !== heatmapTooltipPointerId) return;

                if (heatmapTooltipLongPressActive) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    const target = document.elementFromPoint(evt.clientX, evt.clientY);
                    const newCell = target ? target.closest('.heatmap-day[data-tooltip]') : null;
                    if (newCell && newCell !== heatmapTooltipActiveCell) {
                        // [v5.8.0] 切换日期时震动反馈
                        if (typeof Android !== 'undefined' && Android.vibrate) {
                            Android.vibrate(10);
                        } else if (navigator.vibrate) {
                            navigator.vibrate(10);
                        }
                        // [v5.4.0] 统一通过 setHeatmapActiveCell 切换状态，防止遗留
                        setHeatmapActiveCell(newCell);
                        showHeatmapTooltip(newCell, true);
                    } else if (!newCell && heatmapTooltipActiveCell) {
                        // [v5.4.0] 移出日历区域时清除 active 状态并隐藏 tooltip
                        clearTimeout(heatmapTooltipAutoOpenTimer);
                        clearHeatmapActiveCell();
                        hideHeatmapTooltip();
                    }
                } else {
                    const dx = Math.abs(evt.clientX - heatmapTooltipStartX);
                    const dy = Math.abs(evt.clientY - heatmapTooltipStartY);
                    if (dx > HEATMAP_SWIPE_THRESHOLD || dy > HEATMAP_SWIPE_THRESHOLD) {
                        clearTimeout(heatmapTooltipLongPressTimer);
                        clearTimeout(heatmapTooltipAutoOpenTimer);
                        heatmapTooltipPointerId = null;
                        heatmapTooltipLongPressActive = false;
                        // [v5.4.0] 确保清除所有可能的 active 状态
                        clearHeatmapActiveCell();
                        hideHeatmapTooltip();
                        setTimeout(() => { heatmapTouchInteractionActive = false; }, 100);
                        window.removeEventListener('pointermove', heatmapTooltipMoveHandler, true);
                        window.removeEventListener('pointerup', heatmapTooltipEndHandler, true);
                        window.removeEventListener('pointercancel', heatmapTooltipEndHandler, true);
                        heatmapTooltipMoveHandler = null;
                        heatmapTooltipEndHandler = null;
                    }
                }
            };

            const endHandler = evt => {
                const pointerMatches = heatmapTooltipPointerId === null || evt.pointerId === heatmapTooltipPointerId;
                // 如果出现指针ID异常但长按仍为激活状态，也要强制清理，避免残留 active
                if (!pointerMatches && !heatmapTooltipLongPressActive) return;
                clearTimeout(heatmapTooltipLongPressTimer);
                clearTimeout(heatmapTooltipAutoOpenTimer);
                const wasLongPressActive = heatmapTooltipLongPressActive;
                if (wasLongPressActive) {
                    // 阻止事件传播，防止触发页面滑动
                    evt.preventDefault();
                    evt.stopPropagation();
                    evt.stopImmediatePropagation();
                }
                heatmapTooltipPointerId = null;
                // [v5.0.0] 延迟清除长按状态，确保 touchend 事件处理时状态仍为 true，防止触发页面滑动
                if (wasLongPressActive) {
                    setTimeout(() => { heatmapTooltipLongPressActive = false; }, 50);
                } else {
                    heatmapTooltipLongPressActive = false;
                }
                // 延迟清除触摸交互标志，防止mouseenter在pointerup后立即触发
                setTimeout(() => { heatmapTouchInteractionActive = false; }, 100);
                heatmapTooltipActiveCell = null;
                hideHeatmapTooltip();
                clearHeatmapActiveCell();
                window.removeEventListener('pointermove', heatmapTooltipMoveHandler, true);
                window.removeEventListener('pointerup', heatmapTooltipEndHandler, true);
                window.removeEventListener('pointercancel', heatmapTooltipEndHandler, true);
                heatmapTooltipMoveHandler = null;
                heatmapTooltipEndHandler = null;
            };

            heatmapTooltipMoveHandler = moveHandler;
            heatmapTooltipEndHandler = endHandler;
            window.addEventListener('pointermove', heatmapTooltipMoveHandler, { passive: false, capture: true });
            window.addEventListener('pointerup', heatmapTooltipEndHandler, true);
            window.addEventListener('pointercancel', heatmapTooltipEndHandler, true);

            heatmapTooltipLongPressTimer = setTimeout(() => {
                heatmapTooltipLongPressActive = true;
                // [v5.8.0] 长按激活震动反馈
                if (typeof Android !== 'undefined' && Android.vibrate) {
                    Android.vibrate(15);
                } else if (navigator.vibrate) {
                    navigator.vibrate(15);
                }
                // [v5.4.0] 不再使用 setPointerCapture，因为它会影响 elementFromPoint 的结果
                // 导致移动时无法正确检测到新的日期格子
                setHeatmapActiveCell(cell);
                showHeatmapTooltip(cell);
            }, 250);
        });
    });
}
        
        function setupSwiper(containerId, paginationId, onSlideChangeCallback) {
            const container = document.getElementById(containerId); if (!container) return;
            const wrapper = container.querySelector('.swiper-wrapper'); if (!wrapper) return; 
            const totalSlides = wrapper.children.length; if (totalSlides === 0) return;

            let paginationEl = null; let paginationBullets = [];
            if (paginationId) {
                paginationEl = document.getElementById(paginationId);
                if (paginationEl) {
                    paginationEl.innerHTML = ''; 
                    for (let i = 0; i < totalSlides; i++) {
                        const bullet = document.createElement('span');
                        bullet.className = 'swiper-pagination-bullet';
                        bullet.onclick = () => goToSlide(i);
                        paginationEl.appendChild(bullet);
                        paginationBullets.push(bullet);
                    }
                }
            }

            let initialIndex = (containerId === 'pieSwiperContainer') ? (reportState.insightSubViewIndex || 0) : 0;
            let currentIndex = -1; 
            const slideWidthPercentage = 100 / totalSlides;
            
            function updatePagination() {
                if (!paginationEl) return;
                paginationBullets.forEach((bullet, index) => {
                    bullet.classList.toggle('swiper-pagination-bullet-active', index === currentIndex);
                });
            }

            function goToSlide(index, isInitialization = false) { // [v4.5.4] 修复: 增加标志
                if (index < 0 || index >= totalSlides || index === currentIndex) return; 
                wrapper.style.transform = `translateX(-${index * slideWidthPercentage}%)`; 
                currentIndex = index; 
                updatePagination();
                if (containerId === 'trendSwiperContainer') hideTrendTooltip();
                // [v4.5.4] 修复: 只有在非初始化时才触发回调，防止死循环
                if (!isInitialization && onSlideChangeCallback) {
                    onSlideChangeCallback(index);
                }
            }
            
            wrapper.style.transition = 'none'; 
            goToSlide(initialIndex, true); // [v4.5.4] 修复: 传入 true
            setTimeout(() => { wrapper.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)'; }, 50);

            let touchstartX = 0; let touchstartY = 0; 
            container.addEventListener('touchstart', e => {
                if ((containerId === 'trendSwiperContainer' && (trendTooltipLongPressActive || trendTooltipLongPressCooldown)) || (containerId === 'pieSwiperContainer' && (pieTooltipLongPressActive || pieTooltipLongPressCooldown))) return;
                touchstartX = e.changedTouches[0].screenX; touchstartY = e.changedTouches[0].screenY;
            }, { passive: true });
            container.addEventListener('touchend', e => {
                if ((containerId === 'trendSwiperContainer' && (trendTooltipLongPressActive || trendTooltipLongPressCooldown)) || (containerId === 'pieSwiperContainer' && (pieTooltipLongPressActive || pieTooltipLongPressCooldown))) return;
                const touchendX = e.changedTouches[0].screenX; const touchendY = e.changedTouches[0].screenY; const deltaX = touchendX - touchstartX; const deltaY = touchendY - touchstartY; const absDeltaX = Math.abs(deltaX); const absDeltaY = Math.abs(deltaY); const swipeThreshold = 50; if (absDeltaX > swipeThreshold && absDeltaX > absDeltaY) { if (deltaX < 0 && currentIndex < totalSlides - 1) { goToSlide(currentIndex + 1); } else if (deltaX > 0 && currentIndex > 0) { goToSlide(currentIndex - 1); } } touchstartX = 0; touchstartY = 0; });
        }
        
        function updateDetailedDataTable() { const container = document.getElementById('tableContainerWrapper'); const isTaskView = reportState.tableView === 'task'; const filtersHTML = `<div class="analysis-filters"> <div> <div class="analysis-view-switcher report-filters"> <button class="${reportState.tableView === 'category' ? 'active' : ''}" onclick="setTableView('category')">分类</button> <button class="${isTaskView ? 'active' : ''}" onclick="setTableView('task')">任务</button> </div> </div> <div class="report-filters"> <button class="${reportState.tablePeriod === '7d' ? 'active' : ''}" onclick="setTablePeriod('7d')">7天内</button> <button class="${reportState.tablePeriod === '30d' ? 'active' : ''}" onclick="setTablePeriod('30d')">30天内</button> <button class="${reportState.tablePeriod === 'all' ? 'active' : ''}" onclick="setTablePeriod('all')">全部</button> </div> </div>`; const tableHTML = `<div class="analysis-table-container"> <table class="analysis-table${isTaskView ? ' task-view' : ''}" id="analysisTable"> <thead></thead> <tbody></tbody> <tfoot></tfoot> </table> </div>`; container.innerHTML = filtersHTML + tableHTML; const filteredTransactions = getFilteredTransactions(reportState.tablePeriod); const { aggregatedData } = processDashboardData(filteredTransactions, reportState.tableView); aggregatedData.forEach(row => { row.avgTime = row.count > 0 ? (row.earned + row.spent) / row.count : 0; }); renderDetailedDataTable(aggregatedData); }
        function setTableSort(key) { const currentSort = reportState.tableSortKey; if (key === 'amount') { if (currentSort === 'amount_desc') reportState.tableSortKey = 'amount_asc'; else if (currentSort === 'amount_asc') reportState.tableSortKey = 'amount_abs_desc'; else reportState.tableSortKey = 'amount_desc'; } else if (key === 'count') { if (currentSort === 'count_desc') reportState.tableSortKey = 'count_asc'; else reportState.tableSortKey = 'count_desc'; } else if (key === 'avg_time') { if (currentSort === 'avg_time_desc') reportState.tableSortKey = 'avg_time_asc'; else reportState.tableSortKey = 'avg_time_desc'; } updateDetailedDataTable(); }

        function renderDetailedDataTable(data) {
            const table = document.getElementById('analysisTable'); const thead = table.querySelector('thead'); const tbody = table.querySelector('tbody'); const tfoot = table.querySelector('tfoot');
            const sortKey = reportState.tableSortKey; const sortedData = [...data].sort((a, b) => { switch (sortKey) { case 'amount_desc': return b.net - a.net; case 'amount_asc': return a.net - b.net; case 'amount_abs_desc': return Math.abs(b.net) - Math.abs(a.net); case 'count_desc': return b.count - a.count; case 'count_asc': return a.count - b.count; case 'avg_time_desc': return b.avgTime - a.avgTime; case 'avg_time_asc': return a.avgTime - b.avgTime; default: return Math.abs(b.net) - Math.abs(a.net); } });
            const defaultVisibleRows = 10;
            const visibleRows = reportState.tableVisibleRows || defaultVisibleRows; const visibleData = sortedData.slice(0, visibleRows);
            const getSortIndicator = (key) => { const placeholder = '<span style="visibility:hidden"> ▼</span>'; const amountPlaceholder = '<span style="visibility:hidden"> |▼|</span>'; if (key === 'amount') { if (sortKey === 'amount_desc') return ' ▼'; if (sortKey === 'amount_asc') return ' ▲'; if (sortKey === 'amount_abs_desc') return ' |▼|'; return amountPlaceholder; } if (key === 'count') { if (sortKey === 'count_desc') return ' ▼'; if (sortKey === 'count_asc') return ' ▲'; return placeholder; } if (key === 'avg_time') { if (sortKey === 'avg_time_desc') return ' ▼'; if (sortKey === 'avg_time_asc') return ' ▲'; return placeholder; } return ''; };
            const isTaskView = reportState.tableView === 'task'; const headers = isTaskView ? { name: '任务', amount: '时间', avg_time: '平均', count: '次' } : { name: '分类', amount: '时间', count: '次' };
            const headerKeys = Object.keys(headers); thead.innerHTML = `<tr>${headerKeys.map(key => { const sortable = (key === 'amount' || key === 'count' || (isTaskView && key === 'avg_time')); const onClick = sortable ? `onclick="setTableSort('${key}')"` : ''; return `<th ${onClick} style="${sortable ? 'cursor: pointer;' : ''}">${headers[key]}${getSortIndicator(key)}</th>`; }).join('')}</tr>`;
            tbody.innerHTML = visibleData.length > 0 ? visibleData.map(row => { let amountText, amountClass; if (row.earned > 0 && row.spent > 0) { amountText = `<span class="text-positive">+${formatTimeHoursDecimal(row.earned)}</span><br><span class="text-negative">-${formatTimeHoursDecimal(row.spent)}</span>`; } else if (row.earned > 0) { amountText = `+${formatTimeHoursDecimal(row.earned)}`; amountClass = 'text-positive'; } else if (row.spent > 0) { amountText = `-${formatTimeHoursDecimal(row.spent)}`; amountClass = 'text-negative'; } else { amountText = formatTimeHoursDecimal(0); amountClass = 'text-neutral'; } const nameCell = `<td><div class="task-name-scrollable" tabindex="0" title="${row.name}">${row.name}</div></td>`; const amountCell = `<td class="${amountClass || ''}">${amountText}</td>`; const countCell = `<td>${row.count}</td>`; const avgTimeCell = isTaskView ? `<td>${formatTimeHoursDecimal(row.avgTime)}</td>` : ''; if (isTaskView) return `<tr>${nameCell}${amountCell}${avgTimeCell}${countCell}</tr>`; else { const categoryNameCell = `<td>${row.name}</td>`; return `<tr>${categoryNameCell}${amountCell}${countCell}</tr>`; } }).join('') : `<tr><td colspan="${headerKeys.length}" class="empty-message" style="color:var(--text-color);">无匹配数据</td></tr>`;
            tfoot.innerHTML = '';
            if (sortedData.length > visibleRows) {
                const remaining = sortedData.length - visibleRows;
                tfoot.innerHTML = `<tr class="table-footer-row"><td colspan="${headerKeys.length}"><button class="show-more-btn" onclick="showMoreTableRows()">显示更多 (${remaining} 条)</button></td></tr>`;
            } else if (sortedData.length > defaultVisibleRows && visibleRows >= sortedData.length) {
                tfoot.innerHTML = `<tr class="table-footer-row"><td colspan="${headerKeys.length}"><button class="show-more-btn" onclick="collapseTableRows()">收起</button></td></tr>`;
            }
        }
        function showMoreTableRows() { reportState.tableVisibleRows = (reportState.tableVisibleRows || 10) + 10; updateDetailedDataTable(); }
        function collapseTableRows() { reportState.tableVisibleRows = 10; updateDetailedDataTable(); }
        function processDashboardData(transactionsToProcess, view) { 
            const dataMap = new Map(); 
            const trendData = {}; 
            const chronoSortedTransactions = [...transactionsToProcess].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); 
            
            // [v6.4.5] 获取戒除奖励显示模式
            const abstinenceMode = notificationSettings.abstinenceRewardMode || 'offset';
            
            // [v5.2.0] 支持系统任务的分类和名称获取
            // [v5.10.0] 修复：系统任务使用 getTransactionCategory 获取自定义分类
            const getItemNameAndCategory = (t) => { 
                // 系统任务特殊处理
                if (t.isSystem) {
                    const category = getTransactionCategory(t); // [v5.10.0] 使用统一的分类获取函数
                    if (view === 'category') { 
                        return { name: category, category: null }; 
                    }
                    return { name: t.taskName || '系统任务', category: category };
                }
                // 普通任务
                const task = tasks.find(tsk => tsk.id === t.taskId); 
                if (view === 'category') { 
                    return { name: task ? task.category : '未知', category: null }; 
                } 
                return { name: t.taskName || task?.name || '未知任务', category: task?.category }; 
            };
            
            // [v6.4.5] 检查是否为戒除奖励交易
            const isAbstinenceReward = (t) => {
                // 戒除成功奖励交易特征：type='earn', isStreakAdvancement=true, 关联的任务是消费类型
                if (t.type !== 'earn' || !t.isStreakAdvancement) return false;
                const task = tasks.find(tsk => tsk.id === t.taskId);
                if (!task) return false;
                return ['instant_redeem', 'continuous_redeem'].includes(task.type) && 
                       task.isHabit && 
                       task.habitDetails?.type === 'abstinence';
            };
            
            chronoSortedTransactions.forEach(t => { 
                const { name, category } = getItemNameAndCategory(t); 
                if (!name) return; 
                if (!dataMap.has(name)) { 
                    dataMap.set(name, { name, category, earned: 0, spent: 0, net: 0, count: 0 }); 
                } 
                const item = dataMap.get(name); 
                
                // [v5.7.0] 修正交易特殊处理：抵消原先的错误记录而非产生反向收支
                const isCorrection = t.autoDetectType === 'correction';
                // [v6.4.5] 检查是否为戒除奖励
                const isAbstReward = isAbstinenceReward(t);
                const isEarn = t.type ? t.type === 'earn' : t.amount > 0; 
                const amount = Math.abs(t.amount); 
                
                if (isCorrection) {
                    // 修正交易：type='earn'表示返还（应减少spent），type='spend'表示扣减（应减少earned）
                    if (isEarn) {
                        // 消耗类多记录返还 → 减少消耗
                        item.spent = Math.max(0, item.spent - amount);
                        item.net += amount;
                    } else {
                        // 获得类多记录扣减 → 减少获得
                        item.earned = Math.max(0, item.earned - amount);
                        item.net -= amount;
                    }
                    // 修正不增加次数
                } else if (isAbstReward && abstinenceMode === 'offset') {
                    // [v6.4.5] 戒除奖励 + 抵扣模式：从消费中扣减，不计入获得
                    item.spent = Math.max(0, item.spent - amount);
                    item.net += amount;
                    // 抵扣不增加次数，因为这不是一次独立的任务完成
                } else {
                    if (isEarn) { item.earned += amount; item.net += amount; } 
                    else { item.spent += amount; item.net -= amount; } 
                    item.count++; 
                }
                
                const dateStr = getLocalDateString(t.timestamp); 
                if (!trendData[dateStr]) trendData[dateStr] = { earned: {}, spent: {} }; 
                // 更正交易不应把消费分类计入“获得”趋势：改为抵扣对应方向
                if (isCorrection) {
                    if (isEarn) {
                        // 返还消费 -> 从消费趋势中扣减
                        const prev = trendData[dateStr].spent[name] || 0;
                        trendData[dateStr].spent[name] = Math.max(0, prev - amount);
                    } else {
                        // 扣减获得 -> 从获得趋势中扣减
                        const prev = trendData[dateStr].earned[name] || 0;
                        trendData[dateStr].earned[name] = Math.max(0, prev - amount);
                    }
                } else if (isAbstReward && abstinenceMode === 'offset') {
                    // [v6.4.5] 戒除奖励 + 抵扣模式：从消费趋势中扣减
                    const prev = trendData[dateStr].spent[name] || 0;
                    trendData[dateStr].spent[name] = Math.max(0, prev - amount);
                } else {
                    const trendType = isEarn ? 'earned' : 'spent'; 
                    trendData[dateStr][trendType][name] = (trendData[dateStr][trendType][name] || 0) + amount; 
                }
            }); 
            return { aggregatedData: Array.from(dataMap.values()), trendData }; 
        }
        
        // --- Report State Changers ---
        function setAnalysisPeriod(period) { reportState.analysisPeriod = period; saveData(); updateAnalysisDashboard(); }
        function setAnalysisView(view) { reportState.analysisView = view; saveData(); updateAnalysisDashboard(); }
        function setTrendPeriod(period) { reportState.trendPeriod = period; saveData(); updateTrendChart(); }
        function setTrendView(view) { reportState.trendView = view; saveData(); updateTrendChart(); }
        function setTablePeriod(period) { reportState.tableVisibleRows = 10; reportState.tablePeriod = period; saveData(); updateDetailedDataTable(); }
        function setTableView(view) { reportState.tableVisibleRows = 10; reportState.tableView = view; saveData(); updateDetailedDataTable(); }
        
        // --- Utilities & Helpers ---
        function getLocalDateString(date) { const d = new Date(date); const year = d.getFullYear(); const month = (d.getMonth() + 1).toString().padStart(2, '0'); const day = d.getDate().toString().padStart(2, '0'); return `${year}-${month}-${day}`; }
        function getHeatmapColorClass(net) { if (net === 0) return ''; const absNet = Math.abs(net); if (net > 0) { if (absNet < 3600) return 'net-surplus-1'; if (absNet < 10800) return 'net-surplus-2'; return 'net-surplus-3'; } else { if (absNet < 3600) return 'net-deficit-1'; if (absNet < 10800) return 'net-deficit-2'; return 'net-deficit-3'; } }
        function escapeHtml(str) { if (str === undefined || str === null) return ''; return String(str).replace(/[&<>'"]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])); }
        function generateId() { if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') { return crypto.randomUUID(); } return `id_${Date.now()}_${Math.random().toString(16).slice(2)}`; }
        
        // [v4.1.0] New helper function for balance card click
        // [v5.8.0] 改为调用时间流图版
        function showTodayDetails() {
            const todayStr = getLocalDateString(new Date());
            showDayFlowChart(todayStr);
        }
function updateCategoryRecommendations(taskType) { let relevantCategories = []; if (taskType) { const isEarnType = ['reward', 'continuous', 'continuous_target'].includes(taskType); const filteredTasks = tasks.filter(task => { const taskIsEarn = ['reward', 'continuous', 'continuous_target'].includes(task.type); return isEarnType === taskIsEarn; }); relevantCategories = [...new Set(filteredTasks.map(t => t.category))]; } else { relevantCategories = [...new Set(tasks.map(t => t.category))]; } document.getElementById('categoryRecommendations').innerHTML = relevantCategories.map(cat => `<div class="recommendation-item" onclick="selectCategory('${cat}')">${cat}</div>`).join(''); }
        function selectCategory(category) { document.getElementById('taskCategory').value = category; }
        function formatTime(seconds) { if (seconds === null || isNaN(seconds)) return '0秒'; if (seconds < 0) return '-' + formatTime(-seconds); if (seconds === 0) return '0秒'; seconds = Math.round(seconds); const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60); const s = seconds % 60; const parts = []; if (h > 0) parts.push(`${h}小时`); if (m > 0) parts.push(`${m}分`); if (s > 0 && h === 0) parts.push(`${s}秒`); return parts.length > 0 ? parts.join('') : '0秒'; }
        function formatTimeForPie(seconds) { if (seconds === null || isNaN(seconds)) return '0分'; if (seconds < 0) return '-' + formatTimeForPie(-seconds); const totalMinutes = Math.round(seconds / 60); if (totalMinutes < 1) return '0分'; if (totalMinutes < 60) return `${totalMinutes}分`; const h = Math.floor(totalMinutes / 60); const m = totalMinutes % 60; const parts = []; if (h > 0) parts.push(`${h}小时`); if (m > 0) parts.push(`${m}分`); return parts.join(''); }
        function formatTimeHoursDecimal(seconds) { if (seconds === null || isNaN(seconds)) return '0.0小时'; const sign = seconds < 0 ? '-' : ''; const absSeconds = Math.abs(seconds); if (absSeconds === 0) return '0.0小时'; const hours = absSeconds / 3600; return `${sign}${hours.toFixed(1)}小时`; }
        function formatDateTime(timestamp) { const d = new Date(timestamp), n = new Date(); const diff = (new Date(n.toDateString()) - new Date(d.toDateString())) / 86400000; if (diff === 0) return d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); if (diff === 1) return '昨天 ' + d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); if (diff < 7) return `${diff}天前`; return d.toLocaleDateString('zh-CN'); }
        
        // [v5.10.0] 更新桌面小组件
        function updateWidgets() {
            if (typeof Android !== 'undefined' && Android.updateWidgets) {
                try {
                    const balance = Math.round(currentBalance || 0);
                    const dailyLimit = screenTimeSettings?.dailyLimitMinutes || 120;
                    const whitelist = JSON.stringify(screenTimeSettings?.whitelistApps || []);
                    console.log('[Widget] Updating widgets: balance=' + balance + ', limit=' + dailyLimit);
                    Android.updateWidgets(balance, dailyLimit, whitelist);
                } catch (e) { console.error('Widget update failed:', e); }
            }
        }
        
        // --- Settings & Notifications ---
        function requestNotificationPermission() { if ('Notification' in window) Notification.requestPermission(); }
        
        // [v4.5.6-Android] 混合开发适配版通知函数
        async function showNotification(title, body, type) {
            const isTestNotification = title === '✅ 测试通知';

            // 1. 检查应用内设置开关
            if (!isTestNotification) {
                if (type === 'achievement' && !notificationSettings.achievement) {
                    return;
                }
                if (type === 'habitNudge' && !notificationSettings.habitNudgeEnabled) {
                    return;
                }
                if (type !== 'reminder' && type !== 'achievement' && type !== 'habitNudge' && !notificationSettings[type]) {
                    return; 
                }
            }
            
            // 2. 核心修改：检查是否存在 Android 原生接口
            if (window.Android && window.Android.showNotification) {
                console.log('Calling Android Native Notification');
                // 直接调用 Java 定义的接口
                window.Android.showNotification(title, body);
                return;
            }
            
            // 3. 降级回退：如果是浏览器环境，继续使用 Service Worker
            if (!('Notification' in window) || !('serviceWorker' in navigator) || Notification.permission !== 'granted') {
                return; 
            }
            
            try {
                const registration = await navigator.serviceWorker.ready;
                await registration.showNotification(title, { body: body, icon: 'icon-192.png' });
            } catch (error) {
                console.error(`Failed to show notification "${title}". Error:`, error);
            }
        }
        
        async function sendTestNotification() {
            // [v4.5.6-Android] 核心适配：优先检查是否在安卓 App 中
            if (window.Android && window.Android.showNotification) {
                // 如果是安卓环境，直接发送，跳过后面的 PWA 检查
                console.log('Triggering Android Test Notification');
                // 直接调用之前改好的 showNotification 函数
                showNotification('✅ 测试通知', '如果看到此消息，说明您的通知功能工作正常！', 'achievement');
                showAlert('指令已发送至 Android 系统！\n若未收到通知请授予相关权限。', '测试通知');
                return;
            }

            // === 以下是原本的 PWA 网页版逻辑 (保持不变作为后备) ===
            if (!('Notification' in window) || !('serviceWorker' in navigator)) { showAlert('此浏览器不支持 PWA 通知功能。'); return; }
            if (Notification.permission === 'denied') { showAlert('通知权限已被拒绝。请在您的浏览器或系统设置中为本站重新开启通知权限。'); return; }
            if (Notification.permission === 'default') { const permission = await Notification.requestPermission(); if (permission !== 'granted') { showAlert('您拒绝了通知权限。请在浏览器设置中手动开启。'); return; } }
            try { await showNotification('✅ 测试通知', '如果看到此消息，说明您的通知功能工作正常！', 'achievement'); showAlert('测试通知已成功发送！请检查您的系统通知。', '测试通知'); } catch (error) { showAlert(`发送通知时出错：\n${error.message}\n\n请检查浏览器控制台获取详细信息。`, '错误'); }
        }
	// [v4.6.1] 悬浮窗开关逻辑
        function toggleFloatingTimer() {
            notificationSettings.floatingTimer = document.getElementById('floatingTimerToggle').checked;
            saveData();
        }
        function toggleAchievementNotifications() { notificationSettings.achievement = document.getElementById('achievementNotificationToggle').checked; if (notificationSettings.achievement && Notification.permission === 'default') requestNotificationPermission(); saveData(); }
        function toggleLongRunningNotifications() { notificationSettings.longRunning = document.getElementById('longRunningNotificationToggle').checked; saveData(); }
        function updateLongRunningThreshold() { const v = parseInt(document.getElementById('longRunningThreshold').value); if (v >= 300) { notificationSettings.longRunningThreshold = v; saveData(); } }
        function toggleLowBalanceNotifications() { notificationSettings.lowBalance = document.getElementById('lowBalanceNotificationToggle').checked; saveData(); }
        function updateLowBalanceThreshold() { const v = parseInt(document.getElementById('lowBalanceThreshold').value); if (v >= 0) { notificationSettings.lowBalanceThreshold = v; saveData(); updateBalance(); } }
        function toggleHabitNudge() { notificationSettings.habitNudgeEnabled = document.getElementById('habitNudgeToggle').checked; if (notificationSettings.habitNudgeEnabled && Notification.permission === 'default') requestNotificationPermission(); saveData(); }
        function updateHabitNudgeTime() { notificationSettings.habitNudgeTime = document.getElementById('habitNudgeTime').value; saveData(); }
        
        // [v4.5.3] FIX: This function now correctly reflects the loaded state
        function updateNotificationSettingsUI() { 
            document.getElementById('achievementNotificationToggle').checked = notificationSettings.achievement; 
            document.getElementById('longRunningNotificationToggle').checked = notificationSettings.longRunning; 
            document.getElementById('longRunningThreshold').value = notificationSettings.longRunningThreshold; 
            document.getElementById('lowBalanceNotificationToggle').checked = notificationSettings.lowBalance; 
            document.getElementById('lowBalanceThreshold').value = notificationSettings.lowBalanceThreshold; 
            document.getElementById('habitNudgeToggle').checked = notificationSettings.habitNudgeEnabled;
            document.getElementById('habitNudgeTime').value = notificationSettings.habitNudgeTime;
            // [v4.6.1] Update floating timer toggle
            document.getElementById('floatingTimerToggle').checked = notificationSettings.floatingTimer !== false; 
        }

        // ========== [v5.10.0] 卡片堆叠系统 ==========
        
        const CARD_STACK_STATE_KEY = 'cardStackExpanded';
        let cardStackTouchStartY = 0;
        let cardStackTouchStartTime = 0;
        let cardStackIsDragging = false;
        
        // 初始化卡片堆叠
        function initCardStack() {
            const cardStack = document.getElementById('cardStack');
            if (!cardStack) return;
            
            // 读取记忆的状态，默认展开
            const savedState = localStorage.getItem(CARD_STACK_STATE_KEY);
            const isExpanded = savedState === null ? true : savedState === 'true';
            
            cardStack.classList.toggle('expanded', isExpanded);
            cardStack.classList.toggle('collapsed', !isExpanded);
            
            // 绑定手势事件
            cardStack.addEventListener('touchstart', handleCardStackTouchStart, { passive: true });
            cardStack.addEventListener('touchmove', handleCardStackTouchMove, { passive: false });
            cardStack.addEventListener('touchend', handleCardStackTouchEnd, { passive: true });
        }
        
        // 切换堆叠状态
        function toggleCardStack() {
            const cardStack = document.getElementById('cardStack');
            if (!cardStack) return;
            
            const isExpanded = cardStack.classList.contains('expanded');
            setCardStackState(!isExpanded);
        }
        
        // 设置堆叠状态
        function setCardStackState(expanded) {
            const cardStack = document.getElementById('cardStack');
            if (!cardStack) return;
            
            cardStack.classList.toggle('expanded', expanded);
            cardStack.classList.toggle('collapsed', !expanded);
            
            // 记忆状态
            localStorage.setItem(CARD_STACK_STATE_KEY, expanded.toString());
        }
        
        // 手势开始
        function handleCardStackTouchStart(e) {
            if (e.touches.length !== 1) return;
            cardStackTouchStartY = e.touches[0].clientY;
            cardStackTouchStartTime = Date.now();
            cardStackIsDragging = false;
        }
        
        // 手势移动
        function handleCardStackTouchMove(e) {
            if (e.touches.length !== 1) return;
            const deltaY = e.touches[0].clientY - cardStackTouchStartY;
            
            // 检测是否有明显的垂直滑动意图
            if (Math.abs(deltaY) > 10) {
                cardStackIsDragging = true;
                const cardStack = document.getElementById('cardStack');
                if (cardStack) cardStack.classList.add('dragging');
            }
        }
        
        // 手势结束
        function handleCardStackTouchEnd(e) {
            const cardStack = document.getElementById('cardStack');
            if (cardStack) cardStack.classList.remove('dragging');
            
            if (!cardStackIsDragging) return;
            
            const deltaY = e.changedTouches[0].clientY - cardStackTouchStartY;
            const deltaTime = Date.now() - cardStackTouchStartTime;
            const velocity = Math.abs(deltaY) / deltaTime;
            
            // 滑动阈值：距离 > 50px 或 速度 > 0.3px/ms
            const threshold = 50;
            const velocityThreshold = 0.3;
            
            const isExpanded = cardStack.classList.contains('expanded');
            
            if (deltaY > threshold || (deltaY > 20 && velocity > velocityThreshold)) {
                // 下拉 → 展开
                if (!isExpanded) {
                    setCardStackState(true);
                }
            } else if (deltaY < -threshold || (deltaY < -20 && velocity > velocityThreshold)) {
                // 上滑 → 收起
                if (isExpanded) {
                    setCardStackState(false);
                }
            }
            
            cardStackIsDragging = false;
        }
        
        // [v5.10.0] 屏幕时间卡片点击处理
        function handleScreenTimeCardClick(event) {
            const cardStack = document.getElementById('cardStack');
            if (!cardStack) return;
            
            const isExpanded = cardStack.classList.contains('expanded');
            const header = document.getElementById('screenTimeHeader');
            
            // 如果是收起状态，点击任何位置都展开
            // 如果是展开状态，点击header收起，点击body跳转详情
            if (!isExpanded) {
                // 收起状态，点击展开
                setCardStackState(true);
            } else {
                // 展开状态，检查点击位置
                if (header && header.contains(event.target)) {
                    // 点击header，收起
                    setCardStackState(false);
                } else {
                    // 点击body，跳转详情
                    showScreenTimeDetails();
                }
            }
        }

        // ========== [v5.2.0] 屏幕时间管理 ==========
        
        let screenTimeSettings = {
            enabled: false,
            dailyLimitMinutes: 120,      // 默认 2 小时
            showCard: true,               // 是否显示首页卡片
            whitelistApps: [],            // 白名单应用包名
            lastSettleDate: null,         // 上次结算日期
            lastSettleTime: null,         // 上次结算时间戳
            enabledDate: null,            // 首次启用日期（用于判断是否需要补结算）
            settledDates: [],             // 已结算的日期列表
            autoSettle: true,             // 自动结算（v5.10.0起固定开启）
            earnCategory: null,           // [v5.10.0] 节省时间归属分类（null时使用「系统」）
            spendCategory: null,          // [v5.10.0] 超出时间归属分类（null时使用「系统」）
            cardStyle: 'classic',         // [v5.10.0] 卡片样式：'classic' | 'glass'
            glassStrength: 100,           // [v6.4.x] 通透强度（百分比，影响透明度）
            glassBlurStrength: 100        // [v6.4.x] 模糊强度（百分比，影响 blur）
        };
        
        // 初始化屏幕时间设置
        function initScreenTimeSettings() {
            const saved = localStorage.getItem('screenTimeSettings');
            if (saved) {
                screenTimeSettings = { ...screenTimeSettings, ...JSON.parse(saved) };
            }
            
            // 更新 UI
            document.getElementById('screenTimeToggle').checked = screenTimeSettings.enabled;
            document.getElementById('screenTimeLimitHours').value = Math.floor(screenTimeSettings.dailyLimitMinutes / 60);
            document.getElementById('screenTimeLimitMinutes').value = screenTimeSettings.dailyLimitMinutes % 60;
            document.getElementById('screenTimeCardToggle').checked = screenTimeSettings.showCard;
            document.getElementById('whitelistCount').textContent = `${screenTimeSettings.whitelistApps.length} 个应用不计入使用时间`;
            
            // [v6.0.0] 修复：直接调用 setCardStyle 确保所有元素同步（包括 body.glass-mode）
            const cardStyle = screenTimeSettings.cardStyle || 'classic';
            setCardStyle(cardStyle);
            // [v6.4.x] 应用通透强度（无论模式，以便下次切换已准备好）
            applyGlassStrength(screenTimeSettings.glassStrength || 100, false);
            applyGlassBlurStrength(screenTimeSettings.glassBlurStrength || 100, false);
            
            // [v5.10.0] 初始化分类选择器
            updateScreenTimeCategorySelectors();
            
            if (screenTimeSettings.enabled) {
                document.getElementById('screenTimeSettings').classList.remove('hidden');
                document.getElementById('screenTimeStatus').textContent = '已启用';
                
                // [v5.2.0] 应用启动时自动结算过去未处理的天数（仅在开关开启时）
                if (screenTimeSettings.autoSettle !== false) {
                    setTimeout(() => {
                        autoSettleScreenTime();
                    }, 1000); // 延迟1秒执行，确保其他初始化完成
                } else {
                    // [v5.3.0] 即使自动结算关闭，也要执行应用检测
                    setTimeout(() => {
                        autoDetectAppUsage();
                    }, 1000);
                }
            } else {
                // [v5.3.0] 屏幕时间管理未开启时，仍需检测启用了自动检测的任务
                setTimeout(() => {
                    autoDetectAppUsage();
                }, 1000);
            }
            
            updateScreenTimeCardVisibility();
            updateLastSettleTimeDisplay();
        }
        
        // 保存设置
        function saveScreenTimeSettings() {
            localStorage.setItem('screenTimeSettings', JSON.stringify(screenTimeSettings));
        }
        
        // [v5.10.0] 更新分类选择器选项
        // [v6.4.0] 重构为支持自定义弹窗
        let categorySelectCurrentType = null; // 'earn' 或 'spend'
        let earnCategoriesCache = [];
        let spendCategoriesCache = [];
        let categoryBottomSheetDragBound = false;
        let bottomSheetDragState = null;
        let bottomSheetPointerId = null;
        let bottomSheetClosing = false;
        let glassStrengthRaf = null;
        let glassBlurRaf = null;

        function initBottomSheetDrag(modalId, onClose) {
            if (categoryBottomSheetDragBound) return; // 仅绑定一次
            const modal = document.getElementById(modalId);
            if (!modal) return;
            const content = modal.querySelector('.bottom-sheet-content');
            const header = modal.querySelector('.bottom-sheet-header');
            if (!content || !header) return;

            const getY = (e) => (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;

            const onStart = (e) => {
                bottomSheetDragState = {
                    startY: getY(e),
                    delta: 0,
                };
                bottomSheetPointerId = e.pointerId ?? null;
                content.classList.add('dragging');
                content.style.transition = 'none';
                if (content.setPointerCapture && bottomSheetPointerId !== null) {
                    try { content.setPointerCapture(bottomSheetPointerId); } catch (_) {}
                }
                window.addEventListener('pointermove', onMove, { passive: false });
                window.addEventListener('pointerup', onEnd, { passive: false });
                window.addEventListener('pointercancel', onEnd, { passive: false });
                e.preventDefault();
            };

            const onMove = (e) => {
                if (!bottomSheetDragState) return;
                if (bottomSheetPointerId !== null && e.pointerId !== bottomSheetPointerId) return;
                const currentY = getY(e);
                const delta = Math.max(0, currentY - bottomSheetDragState.startY);
                bottomSheetDragState.delta = delta;
                content.style.transform = `translateY(${delta}px)`;
                e.preventDefault();
            };

            const onEnd = () => {
                if (!bottomSheetDragState) return;
                if (bottomSheetClosing) return;
                const delta = bottomSheetDragState.delta;
                const shouldClose = delta > 90;
                content.classList.remove('dragging');
                content.style.transition = 'transform 0.2s ease';
                if (shouldClose) {
                    bottomSheetClosing = true;
                    // 添加 slide-close 类保持滑出状态，然后直接关闭
                    content.classList.add('slide-close');
                    content.style.transform = '';
                    content.style.transition = '';
                    // 等待滑出动画完成后关闭
                    setTimeout(() => {
                        onClose();
                        bottomSheetClosing = false;
                    }, 220);
                } else {
                    content.style.transform = 'translateY(0)';
                    setTimeout(() => {
                        content.style.transition = '';
                        content.style.transform = '';
                    }, 180);
                }
                if (content.releasePointerCapture && bottomSheetPointerId !== null) {
                    try { content.releasePointerCapture(bottomSheetPointerId); } catch (_) {}
                }
                window.removeEventListener('pointermove', onMove);
                window.removeEventListener('pointerup', onEnd);
                window.removeEventListener('pointercancel', onEnd);
                bottomSheetDragState = null;
                bottomSheetPointerId = null;
            };

            header.addEventListener('pointerdown', onStart);
            categoryBottomSheetDragBound = true;
        }
        
        function updateScreenTimeCategorySelectors() {
            // 收集所有分类（区分获得类和消耗类）
            const earnCategories = new Set();
            const spendCategories = new Set();
            
            tasks.forEach(task => {
                const isEarnType = ['reward', 'continuous', 'continuous_target'].includes(task.type);
                if (isEarnType) {
                    earnCategories.add(task.category);
                } else {
                    spendCategories.add(task.category);
                }
            });
            
            // 缓存分类列表供弹窗使用
            earnCategoriesCache = Array.from(earnCategories).sort();
            spendCategoriesCache = Array.from(spendCategories).sort();
            
            // 更新触发器显示文本
            const earnTrigger = document.getElementById('screenTimeEarnCategoryTrigger');
            const spendTrigger = document.getElementById('screenTimeSpendCategoryTrigger');
            const earnInput = document.getElementById('screenTimeEarnCategory');
            const spendInput = document.getElementById('screenTimeSpendCategory');
            
            if (earnTrigger && earnInput) {
                earnInput.value = screenTimeSettings.earnCategory || '';
                earnTrigger.textContent = screenTimeSettings.earnCategory || '系统（自动创建分类）';
            }
            if (spendTrigger && spendInput) {
                spendInput.value = screenTimeSettings.spendCategory || '';
                spendTrigger.textContent = screenTimeSettings.spendCategory || '系统（自动创建分类）';
            }
        }
        
        // [v5.10.0] 保存分类设置
        // [v6.4.0] 改为从 hidden input 读取
        function updateScreenTimeCategories() {
            const earnInput = document.getElementById('screenTimeEarnCategory');
            const spendInput = document.getElementById('screenTimeSpendCategory');
            
            screenTimeSettings.earnCategory = earnInput.value || null;
            screenTimeSettings.spendCategory = spendInput.value || null;
            saveScreenTimeSettings();
        }
        
        // [v6.4.0] 分类选择弹窗控制函数
        function showCategorySelectModal(type) {
            categorySelectCurrentType = type;
            const modal = document.getElementById('categorySelectModal');
            const title = document.getElementById('categorySelectModalTitle');
            const body = document.getElementById('categorySelectModalBody');
            const content = modal?.querySelector('.bottom-sheet-content');
            
            // 重置上次关闭留下的样式
            if (content) {
                content.classList.remove('slide-close', 'dragging');
                content.style.transform = '';
                content.style.transition = '';
            }
            
            initBottomSheetDrag('categorySelectModal', hideCategorySelectModal);
            
            title.textContent = type === 'earn' ? '选择节省时间分类' : '选择超出时间分类';
            
            const categories = type === 'earn' ? earnCategoriesCache : spendCategoriesCache;
            const currentValue = type === 'earn' 
                ? (screenTimeSettings.earnCategory || '') 
                : (screenTimeSettings.spendCategory || '');
            
            let html = `
                <div class="category-select-item ${currentValue === '' ? 'selected' : ''}" data-value="" onclick="selectScreenTimeCategory(this)">
                    <div class="category-select-color" style="background: var(--text-color-light);"></div>
                    <div class="category-select-name">系统（自动创建分类）</div>
                </div>
            `;
            
            categories.forEach(cat => {
                const color = categoryColors.get(cat) || '#888';
                html += `
                    <div class="category-select-item ${currentValue === cat ? 'selected' : ''}" data-value="${cat}" onclick="selectScreenTimeCategory(this)">
                        <div class="category-select-color" style="background: ${color};"></div>
                        <div class="category-select-name">${cat}</div>
                    </div>
                `;
            });
            
            body.innerHTML = html;
            modal.classList.add('show');
        }
        
        function hideCategorySelectModal() {
            const modal = document.getElementById('categorySelectModal');
            const content = modal?.querySelector('.bottom-sheet-content');
            // 移除 show，触发 CSS transition 滑出
            modal?.classList.remove('show');
            if (content) {
                content.classList.remove('dragging');
                // 不在这里重置 transform/transition，防止闪回
                // 样式将在下次 show 时重置
            }
            bottomSheetClosing = false;
        }
        
        function selectScreenTimeCategory(item) {
            const value = item.dataset.value;
            const displayText = value || '系统（自动创建分类）';
            
            if (categorySelectCurrentType === 'earn') {
                document.getElementById('screenTimeEarnCategory').value = value;
                document.getElementById('screenTimeEarnCategoryTrigger').textContent = displayText;
            } else {
                document.getElementById('screenTimeSpendCategory').value = value;
                document.getElementById('screenTimeSpendCategoryTrigger').textContent = displayText;
            }
            
            hideCategorySelectModal();
            updateScreenTimeCategories();
        }
        
        // 点击背景关闭底部抽屉
        document.getElementById('categorySelectModal')?.addEventListener('click', function(e) {
            if (e.target === this) hideCategorySelectModal();
        });
        
        // [v5.10.0] toggleAutoSettle 函数已移除，自动结算功能固定开启
        
        // 开关屏幕时间管理
        async function toggleScreenTimeManagement() {
            const toggle = document.getElementById('screenTimeToggle');
            
            if (toggle.checked) {
                // 检查权限
                if (typeof Android !== 'undefined' && Android.hasUsageStatsPermission) {
                    if (!Android.hasUsageStatsPermission()) {
                        // 显示权限引导
                        const confirmed = await showConfirm(
                            '屏幕时间管理需要"使用情况访问权限"。\n\n' +
                            '点击"确定"后，请在列表中找到"时间银行"并开启权限，然后返回应用重新开启此功能。',
                            '需要权限'
                        );
                        
                        if (confirmed) {
                            Android.openUsageAccessSettings();
                        }
                        toggle.checked = false;
                        return;
                    }
                } else {
                    showToast('此功能仅在 Android 应用中可用');
                    toggle.checked = false;
                    return;
                }
                
                // 启用成功
                screenTimeSettings.enabled = true;
                if (!screenTimeSettings.enabledDate) {
                    screenTimeSettings.enabledDate = getLocalDateString(new Date());
                }
                if (!screenTimeSettings.settledDates) {
                    screenTimeSettings.settledDates = [];
                }
                document.getElementById('screenTimeSettings').classList.remove('hidden');
                document.getElementById('screenTimeStatus').textContent = '已启用';
                saveScreenTimeSettings();
                updateScreenTimeCard();
            } else {
                screenTimeSettings.enabled = false;
                document.getElementById('screenTimeSettings').classList.add('hidden');
                document.getElementById('screenTimeStatus').textContent = '未启用';
                saveScreenTimeSettings();
            }
            
            updateScreenTimeCardVisibility();
        }
        
        // 更新每日限额
        function updateScreenTimeLimit() {
            const hours = parseInt(document.getElementById('screenTimeLimitHours').value) || 0;
            const minutes = parseInt(document.getElementById('screenTimeLimitMinutes').value) || 0;
            screenTimeSettings.dailyLimitMinutes = hours * 60 + minutes;
            if (screenTimeSettings.dailyLimitMinutes < 1) {
                screenTimeSettings.dailyLimitMinutes = 1; // 最少 1 分钟
                document.getElementById('screenTimeLimitMinutes').value = 1;
            }
            saveScreenTimeSettings();
            updateScreenTimeCard();
        }
        
        // 开关首页卡片
        function toggleScreenTimeCard() {
            screenTimeSettings.showCard = document.getElementById('screenTimeCardToggle').checked;
            saveScreenTimeSettings();
            updateScreenTimeCardVisibility();
        }
        
        // [v5.2.1] 屏幕时间卡片自动刷新定时器
        let screenTimeRefreshTimer = null;
        const SCREEN_TIME_REFRESH_INTERVAL = 60000; // 每60秒刷新一次
        
        // [v5.2.1] 启动屏幕时间卡片自动刷新
        function startScreenTimeAutoRefresh() {
            stopScreenTimeAutoRefresh(); // 先清除已有定时器
            if (!screenTimeSettings.enabled || !screenTimeSettings.showCard) return;
            
            screenTimeRefreshTimer = setInterval(() => {
                if (document.visibilityState === 'visible') {
                    updateScreenTimeCard();
                }
            }, SCREEN_TIME_REFRESH_INTERVAL);
        }
        
        // [v5.2.1] 停止屏幕时间卡片自动刷新
        function stopScreenTimeAutoRefresh() {
            if (screenTimeRefreshTimer) {
                clearInterval(screenTimeRefreshTimer);
                screenTimeRefreshTimer = null;
            }
        }
        
        // [v5.10.0] 更新卡片显示状态
        function updateScreenTimeCardVisibility() {
            const wrapper = document.getElementById('screenTimeWrapper');
            const stackedContainer = document.getElementById('stackedCardsContainer');
            
            if (screenTimeSettings.enabled && screenTimeSettings.showCard) {
                if (wrapper) wrapper.style.display = '';
                if (stackedContainer) stackedContainer.style.display = '';
                updateScreenTimeCard();
                startScreenTimeAutoRefresh(); // [v5.2.1] 启动自动刷新
            } else {
                if (wrapper) wrapper.style.display = 'none';
                // 如果没有其他堆叠卡片，隐藏整个堆叠容器
                if (stackedContainer) stackedContainer.style.display = 'none';
                stopScreenTimeAutoRefresh(); // [v5.2.1] 停止自动刷新
            }
        }
        
        // 更新首页卡片数据
        function updateScreenTimeCard() {
            if (!screenTimeSettings.enabled || !screenTimeSettings.showCard) return;
            
            if (typeof Android !== 'undefined' && Android.getTodayScreenTime) {
                const usedMs = Android.getTodayScreenTime(JSON.stringify(screenTimeSettings.whitelistApps));
                if (usedMs < 0) return; // 无权限或异常
                
                const usedMinutes = Math.floor(usedMs / 60000);
                const limitMinutes = screenTimeSettings.dailyLimitMinutes;
                const percent = (usedMinutes / limitMinutes) * 100;
                const displayPercent = Math.min(100, percent);
                const diff = limitMinutes - usedMinutes;
                
                // 更新进度条
                document.getElementById('screenTimeProgressBar').style.width = displayPercent + '%';
                
                // 更新百分比显示
                document.getElementById('screenTimePercent').textContent = Math.round(percent) + '%';
                
                // 更新统计
                document.getElementById('screenTimeUsed').textContent = formatScreenTimeMinutes(usedMinutes);
                document.getElementById('screenTimeLimit').textContent = '/ ' + formatScreenTimeMinutes(limitMinutes);
                
                // 更新预计奖惩
                const footer = document.getElementById('screenTimeFooter');
                
                if (diff >= 0) {
                    footer.textContent = `预计奖励: +${formatScreenTimeMinutes(diff)}`;
                } else {
                    footer.textContent = `预计消耗: ${formatScreenTimeMinutes(-diff)}`;
                }
                
                const wrapper = document.getElementById('screenTimeWrapper');
                const progressBar = document.getElementById('screenTimeProgressBar');
                const percentEl = document.getElementById('screenTimePercent');
                const isGlass = screenTimeSettings.cardStyle === 'glass';
                
                if (isGlass) {
                    // [v5.10.0] 通透模式：动态颜色进度条，白色文字
                    const colors = getScreenTimeProgressColor(percent);
                    if (progressBar) progressBar.style.background = colors.gradient;
                    // 通透模式不设置wrapper背景渐变（由CSS控制毛玻璃效果）
                    if (wrapper) wrapper.style.background = '';
                } else {
                    // 经典模式：背景渐变色
                    let gradient;
                    if (percent <= 33) {
                        gradient = 'linear-gradient(135deg, #27ae60 0%, #1abc9c 100%)';
                    } else if (percent <= 66) {
                        gradient = 'linear-gradient(135deg, #3498db 0%, #9b59b6 100%)';
                    } else if (percent <= 100) {
                        gradient = 'linear-gradient(135deg, #f39c12 0%, #e74c3c 100%)';
                    } else {
                        gradient = 'linear-gradient(135deg, #e74c3c 0%, #8e44ad 100%)';
                    }
                    if (wrapper) wrapper.style.background = gradient;
                    if (progressBar) progressBar.style.background = 'white';
                    if (percentEl) percentEl.style.color = '';
                    if (footer) footer.style.color = '';
                }
            }
        }
        
        // 格式化分钟数
        function formatScreenTimeMinutes(minutes) {
            if (minutes < 60) {
                return `${minutes}分钟`;
            }
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            return m > 0 ? `${h}小时${m}分钟` : `${h}小时`;
        }
        
        // 简洁格式化分钟数（用于结算记录）
        function formatScreenTimeCompact(minutes) {
            if (minutes < 60) {
                return `${minutes}分`;
            }
            const hours = minutes / 60;
            // 如果是整小时，不显示小数
            if (minutes % 60 === 0) {
                return `${Math.floor(hours)}h`;
            }
            // 显示一位小数
            return `${hours.toFixed(1)}h`;
        }
        
        // [v5.2.0] 自动结算 - 应用启动时自动结算过去未处理的天数
        function autoSettleScreenTime() {
            if (!screenTimeSettings.enabled) return;
            if (typeof Android === 'undefined' || !Android.getScreenTimeForDate) return;
            
            const today = getLocalDateString(new Date());
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = getLocalDateString(yesterday);
            
            // 初始化 settledDates
            if (!screenTimeSettings.settledDates) {
                screenTimeSettings.settledDates = [];
            }
            
            // [v5.6.0] 检查是否已有该日期的屏幕时间记录（兼容旧格式）
            function hasScreenTimeRecordForDate(dateStr) {
                return transactions.some(t => 
                    t.screenTimeData?.originalDate === dateStr ||
                    (t.systemType === 'screen-time' && t.screenTimeData?.originalDate === dateStr)
                );
            }
            
            // 获取过去7天未结算的日期（不含今天）
            const unsettledDates = [];
            for (let i = 1; i <= 7; i++) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dateStr = getLocalDateString(date);
                
                // [v5.6.0] 额外检查是否已有交易记录（兼容旧格式数据）
                if (!screenTimeSettings.settledDates.includes(dateStr) && !hasScreenTimeRecordForDate(dateStr)) {
                    // 检查是否有数据
                    try {
                        const usedMs = Android.getScreenTimeForDate(dateStr, JSON.stringify(screenTimeSettings.whitelistApps || []));
                        if (usedMs > 0) {
                            unsettledDates.push({
                                date: dateStr,
                                usedMs: usedMs,
                                usedMinutes: Math.floor(usedMs / 60000)
                            });
                        }
                    } catch (e) {
                        console.error('[ScreenTime] Error getting screen time for', dateStr, e);
                    }
                }
            }
            
            if (unsettledDates.length === 0) {
                console.log('[ScreenTime] No unsettled dates found');
                // [v5.5.2 Fix] 即使没有待结算的屏幕时间，也要执行应用检测补录
                autoDetectAppUsage();
                return;
            }
            
            // 静默执行结算
            const limitMinutes = screenTimeSettings.dailyLimitMinutes;
            let totalChange = 0;
            let settledCount = 0;
            
            unsettledDates.forEach(item => {
                const dateStr = item.date;
                const usedMinutes = item.usedMinutes;
                const diff = limitMinutes - usedMinutes;
                const diffSeconds = diff * 60;
                const isReward = diff >= 0;
                const absAmount = Math.abs(diffSeconds);
                
                // 更新余额
                currentBalance += diffSeconds;
                totalChange += diffSeconds;
                
                // 计算该日期对应的 dailyChanges key
                const [year, month, day] = dateStr.split('-').map(Number);
                const dateObj = new Date(year, month - 1, day);
                const dayKey = dateObj.toDateString();
                dailyChanges[dayKey] = dailyChanges[dayKey] || { earned: 0, spent: 0 };
                
                if (isReward) {
                    dailyChanges[dayKey].earned += absAmount;
                } else {
                    dailyChanges[dayKey].spent += absAmount;
                }
                
                // 添加 transaction 记录
                const systemTask = SYSTEM_TASKS.SCREEN_TIME;
                // [v5.10.0] 使用用户自定义的分类
                const customCategory = isReward ? screenTimeSettings.earnCategory : screenTimeSettings.spendCategory;
                addTransaction({
                    type: isReward ? 'earn' : 'spend',
                    taskId: systemTask.id,
                    taskName: systemTask.name,
                    category: customCategory || SYSTEM_CATEGORY, // [v5.10.0] 保存分类
                    amount: absAmount,
                    description: `📱 屏幕时间: ${formatScreenTimeMinutes(usedMinutes)}/${formatScreenTimeMinutes(limitMinutes)} (${isReward ? '奖励' : '超出'}${formatScreenTimeMinutes(Math.abs(diff))})`,
                    timestamp: new Date(dateObj.getTime() + 23 * 60 * 60 * 1000).toISOString(),
                    isSystem: true,
                    systemType: 'screen-time',
                    isBackdate: true,
                    screenTimeData: {
                        usedMinutes,
                        limitMinutes,
                        diffMinutes: diff,
                        originalDate: dateStr
                    }
                });
                
                // 记录到已结算日期
                screenTimeSettings.settledDates.push(dateStr);
                
                // 添加历史记录
                addScreenTimeHistory(usedMinutes, limitMinutes, diff, dateStr);
                
                settledCount++;
            });
            
            // 保存数据
            saveScreenTimeSettings();
            saveData();
            updateBalanceDisplay();
            
            // 显示通知
            const changeStr = totalChange >= 0 
                ? `+${formatTime(totalChange)}`
                : `-${formatTime(Math.abs(totalChange))}`;
            showToast(`⚡ 已自动结算 ${settledCount} 天屏幕时间，净变化: ${changeStr}`);
            
            console.log(`[ScreenTime] Auto-settled ${settledCount} days, balance change: ${changeStr}`);
            
            // [v5.3.0] 自动结算后执行应用时间检测补录
            autoDetectAppUsage();
        }
        
        // [v5.3.0] 应用时间自动检测补录
        // [v5.6.0] 重构：追溯多天 + 修正多记录 + 开启时追溯7天
        const AUTO_DETECT_MIN_THRESHOLD = 5; // 最小补录/修正阈值：5分钟
        const AUTO_DETECT_MAX_DAYS = 7; // 最大追溯天数
        let pendingAutoDetectNotifications = []; // 待显示的补录通知
        
        // [v5.6.0] 获取需要检查的日期范围（从上次检查到昨天）
        function getAutoDetectDateRange() {
            const dates = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // 获取上次检查日期
            const lastChecked = screenTimeSettings.autoDetect?.lastCheckedDate;
            let startDate;
            
            if (lastChecked) {
                // 从上次检查的下一天开始
                const [y, m, d] = lastChecked.split('-').map(Number);
                startDate = new Date(y, m - 1, d);
                startDate.setDate(startDate.getDate() + 1);
            } else {
                // 首次运行，追溯7天
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - AUTO_DETECT_MAX_DAYS);
            }
            
            // 生成日期列表（到昨天为止）
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            const current = new Date(startDate);
            while (current <= yesterday) {
                dates.push(getLocalDateString(current));
                current.setDate(current.getDate() + 1);
            }
            
            return dates;
        }
        
        // [v5.6.0] 手动触发单个任务的自动检测
        function runAutoDetectForTask(taskId, forceRecheck = false) {
            try {
                console.log('[runAutoDetectForTask] Called with taskId:', taskId, 'forceRecheck:', forceRecheck);
                
                const task = tasks.find(t => t.id === taskId);
                if (!task) {
                    showInfoModal('检测失败', '任务不存在');
                    return;
                }
                
                if (!task.appPackage || !task.autoDetect) {
                    showInfoModal('检测失败', '此任务未开启自动补录，请在编辑任务中开启。');
                    return;
                }
            
            if (typeof Android === 'undefined' || !Android.getAppScreenTimeForDate) {
                showInfoModal('检测失败', '此功能仅在 Android 应用中可用，浏览器环境不支持。');
                return;
            }
            
            // 检查权限
            if (typeof Android !== 'undefined' && Android.hasUsageStatsPermission) {
                if (!Android.hasUsageStatsPermission()) {
                    showInfoModal('需要权限', '请先授予"应用使用情况访问"权限，才能读取应用使用时间。');
                    if (Android.openUsageAccessSettings) {
                        Android.openUsageAccessSettings();
                    }
                    return;
                }
            }
            
            showToast('正在检测...');
            
            // 获取检测日期范围（最近7天）
            const dates = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            for (let i = 1; i <= AUTO_DETECT_MAX_DAYS; i++) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                dates.push(getLocalDateString(d));
            }
            
            let processedDates = JSON.parse(localStorage.getItem('autoDetectProcessedDates') || '{}');
            
            // 强制重新检测时，清除此任务的所有处理记录
            if (forceRecheck) {
                dates.forEach(dateStr => {
                    const taskKey = `${task.id}_${dateStr}`;
                    delete processedDates[taskKey];
                });
                localStorage.setItem('autoDetectProcessedDates', JSON.stringify(processedDates));
                console.log('[runAutoDetectForTask] Cleared processed dates for task:', taskId);
            }
            
            const results = [];
            let checkedCount = 0;
            let skippedCount = 0;
            const checkDetails = [];
            
            dates.forEach(dateStr => {
                const taskKey = `${task.id}_${dateStr}`;
                if (processedDates[taskKey]) {
                    skippedCount++;
                    return; // 已处理过
                }
                
                try {
                    const actualMs = Android.getAppScreenTimeForDate(task.appPackage, dateStr);
                    if (actualMs < 0) {
                        checkDetails.push({ date: dateStr, status: 'error', msg: '无法获取数据' });
                        return;
                    }
                    
                    checkedCount++;
                    const actualMinutes = Math.floor(actualMs / 60000);
                    const recordedSeconds = getTaskRecordedTimeForDateIncludeAuto(task.id, dateStr);
                    const recordedMinutes = Math.floor(recordedSeconds / 60);
                    const diffMinutes = actualMinutes - recordedMinutes;
                    
                    console.log(`[AutoDetect Manual] ${task.name} ${dateStr}: actual=${actualMinutes}min, recorded=${recordedMinutes}min, diff=${diffMinutes}min`);
                    
                    if (diffMinutes <= -AUTO_DETECT_MIN_THRESHOLD) {
                        // 多记录：修正
                        const correctionMinutes = Math.abs(diffMinutes);
                        const result = createAutoCorrection(task, dateStr, correctionMinutes, actualMinutes, recordedMinutes);
                        if (result) {
                            results.push(result);
                            processedDates[taskKey] = { type: 'correction', timestamp: Date.now() };
                            checkDetails.push({ date: dateStr, status: 'correction', actual: actualMinutes, recorded: recordedMinutes, diff: diffMinutes });
                        }
                    } else if (diffMinutes >= AUTO_DETECT_MIN_THRESHOLD) {
                        // 漏记录：补录
                        const result = createAutoMakeup(task, dateStr, diffMinutes, actualMinutes, recordedMinutes);
                        if (result) {
                            results.push(result);
                            processedDates[taskKey] = { type: 'makeup', timestamp: Date.now() };
                            checkDetails.push({ date: dateStr, status: 'makeup', actual: actualMinutes, recorded: recordedMinutes, diff: diffMinutes });
                        }
                    } else {
                        processedDates[taskKey] = { type: 'ok', timestamp: Date.now() };
                        checkDetails.push({ date: dateStr, status: 'ok', actual: actualMinutes, recorded: recordedMinutes, diff: diffMinutes });
                    }
                } catch (e) {
                    console.error('[AutoDetect Manual] Error:', e);
                    checkDetails.push({ date: dateStr, status: 'error', msg: e.message });
                }
            });
            
            // 保存处理记录
            localStorage.setItem('autoDetectProcessedDates', JSON.stringify(processedDates));
            
            if (results.length > 0) {
                saveData();
                updateBalance();
                showAutoDetectNotification(results);
            } else {
                // 构建详细反馈
                let content = `<div style="text-align: left;">`;
                content += `<p><strong>任务：</strong>${escapeHtml(task.name)}</p>`;
                content += `<p><strong>关联应用：</strong>${escapeHtml(task.appPackage)}</p>`;
                content += `<p style="margin-top: 12px;"><strong>检测范围：</strong>最近 ${AUTO_DETECT_MAX_DAYS} 天</p>`;
                
                if (skippedCount === dates.length) {
                    content += `<p style="color: var(--text-color-light); margin-top: 8px;">⏭️ 所有日期已检测过，无需重复检测。</p>`;
                    content += `<p style="font-size: 0.85rem; color: var(--text-color-light); margin-top: 8px;">提示：如果撤回了之前的补录记录，可点击下方按钮重新检测。</p>`;
                    content += `<div style="margin-top: 16px; text-align: center;">
                        <button class="btn btn-primary" onclick="hideInfoModal(); runAutoDetectForTask('${task.id}', true);">🔄 清除缓存重新检测</button>
                    </div>`;
                } else if (checkedCount === 0) {
                    content += `<p style="color: #f39c12; margin-top: 8px;">⚠️ 无法获取应用使用数据，请检查权限设置。</p>`;
                } else {
                    content += `<p style="color: var(--color-positive); margin-top: 8px;">✅ 检测完成，记录匹配良好，无需补录或修正。</p>`;
                    content += `<ul style="font-size: 0.85rem; color: var(--text-color-light); margin-top: 8px; padding-left: 20px;">`;
                    checkDetails.filter(d => d.status === 'ok').slice(0, 3).forEach(d => {
                        content += `<li>${d.date}: 实际 ${d.actual}分钟，记录 ${d.recorded}分钟</li>`;
                    });
                    if (checkDetails.filter(d => d.status === 'ok').length > 3) {
                        content += `<li>... 等 ${checkDetails.filter(d => d.status === 'ok').length} 天</li>`;
                    }
                    content += `</ul>`;
                }
                
                content += `</div>`;
                showInfoModal('🤖 自动检测结果', content);
            }
            } catch (e) {
                console.error('[runAutoDetectForTask] Error:', e);
                showInfoModal('检测出错', `<div style="text-align: left;">
                    <p style="color: #e74c3c; margin-bottom: 12px;">发生错误:</p>
                    <p style="word-break: break-all;"><strong>${escapeHtml(e.message || String(e))}</strong></p>
                    <details style="margin-top: 12px;">
                        <summary style="cursor: pointer; color: var(--text-color-light);">技术详情</summary>
                        <pre style="font-size: 0.75rem; color: var(--text-color-light); white-space: pre-wrap; margin-top: 8px;">${escapeHtml(e.stack || '无堆栈信息')}</pre>
                    </details>
                </div>`);
            }
        }
        
        function autoDetectAppUsage() {
            console.log('[AutoDetect] Starting auto-detect check...');
            
            if (typeof Android === 'undefined' || !Android.getAppScreenTimeForDate) {
                console.log('[AutoDetect] Android interface not available');
                return;
            }
            
            // [v5.5.2] 检查权限
            if (typeof Android !== 'undefined' && Android.hasUsageStatsPermission) {
                if (!Android.hasUsageStatsPermission()) {
                    console.log('[AutoDetect] No usage stats permission');
                    return;
                }
            }
            
            // 获取所有启用了自动检测的任务
            const autoDetectTasks = tasks.filter(t => t.appPackage && t.autoDetect);
            console.log('[AutoDetect] Tasks with auto-detect:', autoDetectTasks.length, autoDetectTasks.map(t => t.name));
            if (autoDetectTasks.length === 0) {
                console.log('[AutoDetect] No tasks with auto-detect enabled');
                return;
            }
            
            console.log('[AutoDetect] Checking', autoDetectTasks.length, 'tasks with auto-detect enabled');
            
            // [v5.6.0] 获取需要检查的日期范围（追溯多天）
            const datesToCheck = getAutoDetectDateRange();
            if (datesToCheck.length === 0) {
                console.log('[AutoDetect] No dates to check');
                return;
            }
            console.log('[AutoDetect] Dates to check:', datesToCheck);
            
            // 获取已处理的日期记录
            let processedDates = JSON.parse(localStorage.getItem('autoDetectProcessedDates') || '{}');
            
            const results = []; // 存储检测结果
            
            // [v5.6.0] 遍历每个日期和每个任务
            datesToCheck.forEach(dateStr => {
                autoDetectTasks.forEach(task => {
                    const taskKey = `${task.id}_${dateStr}`;
                    if (processedDates[taskKey]) return; // 已处理过
                    
                    try {
                        // 获取应用实际使用时长
                        const actualMs = Android.getAppScreenTimeForDate(task.appPackage, dateStr);
                        if (actualMs < 0) {
                            console.log('[AutoDetect] Failed to get app time for', task.appPackage, dateStr);
                            return;
                        }
                        
                        const actualMinutes = Math.floor(actualMs / 60000);
                        
                        // 计算该任务在该日期的已记录时长（包含之前的自动补录/修正）
                        const recordedSeconds = getTaskRecordedTimeForDateIncludeAuto(task.id, dateStr);
                        const recordedMinutes = Math.floor(recordedSeconds / 60);
                        
                        const diffMinutes = actualMinutes - recordedMinutes;
                        
                        console.log(`[AutoDetect] ${task.name} ${dateStr}: actual=${actualMinutes}min, recorded=${recordedMinutes}min, diff=${diffMinutes}min`);
                        
                        // [v5.6.0] 用户多记录了时间 → 执行修正
                        if (diffMinutes <= -AUTO_DETECT_MIN_THRESHOLD) {
                            const correctionMinutes = Math.abs(diffMinutes);
                            const result = createAutoCorrection(task, dateStr, correctionMinutes, actualMinutes, recordedMinutes);
                            if (result) {
                                results.push(result);
                                processedDates[taskKey] = { type: 'correction', timestamp: Date.now() };
                            }
                        }
                        // [v5.6.0] 用户漏记录了时间 → 执行补录
                        else if (diffMinutes >= AUTO_DETECT_MIN_THRESHOLD) {
                            const makeupMinutes = diffMinutes;
                            const result = createAutoMakeup(task, dateStr, makeupMinutes, actualMinutes, recordedMinutes);
                            if (result) {
                                results.push(result);
                                processedDates[taskKey] = { type: 'makeup', timestamp: Date.now() };
                            }
                        } else {
                            // 差异在阈值内，标记为已处理
                            processedDates[taskKey] = { type: 'ok', timestamp: Date.now() };
                        }
                    } catch (e) {
                        console.error('[AutoDetect] Error processing task', task.name, dateStr, e);
                    }
                });
            });
            
            // [v5.6.0] 更新上次检查日期
            if (datesToCheck.length > 0) {
                if (!screenTimeSettings.autoDetect) {
                    screenTimeSettings.autoDetect = {};
                }
                screenTimeSettings.autoDetect.lastCheckedDate = datesToCheck[datesToCheck.length - 1];
                saveScreenTimeSettings();
            }
            
            // 保存已处理记录（只保留最近30天）
            const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
            Object.keys(processedDates).forEach(key => {
                if (processedDates[key].timestamp < thirtyDaysAgo) {
                    delete processedDates[key];
                }
            });
            localStorage.setItem('autoDetectProcessedDates', JSON.stringify(processedDates));
            
            // 如果有结果，保存数据并显示通知
            if (results.length > 0) {
                saveData();
                updateBalanceDisplay();
                showAutoDetectNotification(results);
            }
        }
        
        // [v5.6.0] 创建自动补录交易（漏记录）
        function createAutoMakeup(task, dateStr, makeupMinutes, actualMinutes, recordedMinutes) {
            const makeupSeconds = makeupMinutes * 60;
            const isSpend = ['instant_redeem', 'continuous_redeem'].includes(task.type);
            const multiplier = task.multiplier || 1;
            
            // [v5.6.0] 惩罚逻辑：
            // - 消耗类漏记录：×1.2 消耗（多扣作为惩罚）
            // - 获得类漏记录：×0.8 获得（少给作为惩罚）
            const penaltyMultiplier = isSpend ? 1.2 : 0.8;
            const adjustedSeconds = Math.round(makeupSeconds * multiplier * penaltyMultiplier);
            
            // 更新余额
            if (isSpend) {
                currentBalance -= adjustedSeconds;
            } else {
                currentBalance += adjustedSeconds;
            }
            
            // 更新每日统计
            const [year, month, day] = dateStr.split('-').map(Number);
            const dateObj = new Date(year, month - 1, day);
            const dayKey = dateObj.toDateString();
            dailyChanges[dayKey] = dailyChanges[dayKey] || { earned: 0, spent: 0 };
            
            if (isSpend) {
                dailyChanges[dayKey].spent += adjustedSeconds;
            } else {
                dailyChanges[dayKey].earned += adjustedSeconds;
            }
            
            const penaltyDesc = isSpend ? '×1.2惩罚' : '×0.8惩罚';
            const multiplierStr = multiplier !== 1 ? `×${multiplier}` : '';
            addTransaction({
                type: isSpend ? 'spend' : 'earn',
                taskId: task.id,
                taskName: task.name,
                amount: adjustedSeconds,
                description: `自动补录: ${task.name} (漏记${makeupMinutes}分钟, ${multiplierStr}${penaltyDesc})`,
                multiplier: multiplier,
                timestamp: new Date(dateObj.getTime() + 23 * 60 * 60 * 1000).toISOString(),
                isAutoDetected: true,
                autoDetectType: 'makeup',
                isBackdate: true,
                autoDetectData: {
                    actualMinutes,
                    recordedMinutes,
                    makeupMinutes,
                    penaltyMultiplier,
                    originalDate: dateStr
                }
            });
            
            return {
                task,
                type: 'makeup',
                actualMinutes,
                recordedMinutes,
                diffMinutes: makeupMinutes,
                adjustedSeconds,
                penaltyMultiplier,
                isSpend,
                date: dateStr
            };
        }
        
        // [v5.6.0] 创建自动修正交易（多记录）
        function createAutoCorrection(task, dateStr, correctionMinutes, actualMinutes, recordedMinutes) {
            const correctionSeconds = correctionMinutes * 60;
            const isSpend = ['instant_redeem', 'continuous_redeem'].includes(task.type);
            const multiplier = task.multiplier || 1;
            
            // [v5.6.0] 惩罚逻辑：
            // - 消耗类多记录：×0.8 返还（少还作为惩罚）
            // - 获得类多记录：×1.2 扣减（多扣作为惩罚）
            const penaltyMultiplier = isSpend ? 0.8 : 1.2;
            const adjustedSeconds = Math.round(correctionSeconds * multiplier * penaltyMultiplier);
            
            // 更新余额（反向操作）
            // earn型多记录 → 扣减余额
            // spend型多记录 → 返还余额
            if (isSpend) {
                currentBalance += adjustedSeconds; // 返还（但只返还80%）
            } else {
                currentBalance -= adjustedSeconds; // 扣减（扣120%）
            }
            
            // 更新每日统计（反向）
            const [year, month, day] = dateStr.split('-').map(Number);
            const dateObj = new Date(year, month - 1, day);
            const dayKey = dateObj.toDateString();
            dailyChanges[dayKey] = dailyChanges[dayKey] || { earned: 0, spent: 0 };
            
            if (isSpend) {
                // 原本多消耗了，现在返还，减少spent
                dailyChanges[dayKey].spent = Math.max(0, (dailyChanges[dayKey].spent || 0) - adjustedSeconds);
            } else {
                // 原本多获得了，现在扣减，减少earned
                dailyChanges[dayKey].earned = Math.max(0, (dailyChanges[dayKey].earned || 0) - adjustedSeconds);
            }
            
            const penaltyDesc = isSpend ? '×0.8返还' : '×1.2扣减';
            const multiplierStr = multiplier !== 1 ? `×${multiplier}` : '';
            addTransaction({
                type: isSpend ? 'earn' : 'spend', // 反向类型
                taskId: task.id,
                taskName: task.name,
                amount: adjustedSeconds,
                description: `自动修正: ${task.name} (多记录${correctionMinutes}分钟, ${multiplierStr}${penaltyDesc})`,
                multiplier: multiplier,
                timestamp: new Date(dateObj.getTime() + 23 * 60 * 60 * 1000 + 1000).toISOString(), // +1秒区分
                isAutoDetected: true,
                autoDetectType: 'correction',
                isBackdate: true,
                autoDetectData: {
                    actualMinutes,
                    recordedMinutes,
                    correctionMinutes,
                    penaltyMultiplier,
                    originalDate: dateStr
                }
            });
            
            return {
                task,
                type: 'correction',
                actualMinutes,
                recordedMinutes,
                diffMinutes: correctionMinutes,
                adjustedSeconds,
                penaltyMultiplier,
                isSpend,
                date: dateStr
            };
        }
        
        // [v5.6.0] 获取任务在指定日期的已记录时长（包含自动补录/修正，用于检测时计算总记录）
        // [v5.8.0 Fix] 从描述中解析时间，而不是用当前倍率反推（倍率可能已更改）
        function getTaskRecordedTimeForDateIncludeAuto(taskId, dateStr) {
            let totalSeconds = 0;
            
            transactions.forEach(t => {
                if (t.taskId !== taskId) return;
                if (t.isHabitReward || t.isStreakAdvancement || t.isSystem) return;
                
                const tDateStr = getLocalDateString(new Date(t.timestamp));
                if (tDateStr === dateStr) {
                    // [v5.8.0] 从描述中解析实际时长，避免倍率变化导致的计算错误
                    let recordedSeconds = parseTimeFromDescription(t.description);
                    
                    // 如果无法从描述解析，使用autoDetectData或回退到旧方法
                    if (recordedSeconds === null) {
                        if (t.autoDetectData?.makeupMinutes) {
                            recordedSeconds = t.autoDetectData.makeupMinutes * 60;
                        } else if (t.autoDetectData?.correctionMinutes) {
                            recordedSeconds = t.autoDetectData.correctionMinutes * 60;
                        } else {
                            // 回退：使用当前任务倍率（不太准确，但作为最后手段）
                            const task = tasks.find(tk => tk.id === taskId);
                            const multiplier = task?.multiplier || 1;
                            recordedSeconds = Math.round((t.amount || 0) / multiplier);
                            // 检查透支惩罚
                            if (t.description && (t.description.includes('余额不足, 1.2倍消耗') || t.description.includes('历史余额不足, 1.2倍消耗'))) {
                                recordedSeconds = Math.round(recordedSeconds / 1.2);
                            }
                        }
                    }
                    
                    // 修正类型是反向的，需要减去
                    if (t.autoDetectType === 'correction') {
                        totalSeconds -= recordedSeconds;
                    } else {
                        totalSeconds += recordedSeconds;
                    }
                    
                    console.log(`[getTaskRecordedTimeForDateIncludeAuto] ${t.description?.substring(0, 40)}... parsed=${recordedSeconds}s (${Math.floor(recordedSeconds/60)}min), autoType=${t.autoDetectType || 'none'}`);
                }
            });
            
            console.log(`[getTaskRecordedTimeForDateIncludeAuto] Total for ${taskId} on ${dateStr}: ${totalSeconds}s = ${Math.floor(totalSeconds/60)}min`);
            return Math.max(0, totalSeconds);
        }
        
        // [v5.8.0] 从描述中解析时间
        // 支持格式: "(1小时15分 × 2)", "(30分54秒 × 1.2)", "(2小时20分 × 2)"
        function parseTimeFromDescription(description) {
            if (!description) return null;
            
            // 匹配时间格式：(时间 × 倍率)
            // 时间可以是: "1小时15分", "30分54秒", "2小时20分", "59分10秒" 等
            const timeMatch = description.match(/\((\d+小时)?(\d+分)?(\d+秒)?\s*[×x]\s*[\d.]+\)/);
            if (!timeMatch) return null;
            
            let seconds = 0;
            const hourMatch = description.match(/(\d+)小时/);
            const minMatch = description.match(/(\d+)分/);
            const secMatch = description.match(/(\d+)秒/);
            
            // 需要确保这些匹配在括号内
            const bracketContent = description.match(/\(([^)]+[×x]\s*[\d.]+)\)/);
            if (!bracketContent) return null;
            
            const content = bracketContent[1];
            const hourInBracket = content.match(/(\d+)小时/);
            const minInBracket = content.match(/(\d+)分/);
            const secInBracket = content.match(/(\d+)秒/);
            
            if (hourInBracket) seconds += parseInt(hourInBracket[1]) * 3600;
            if (minInBracket) seconds += parseInt(minInBracket[1]) * 60;
            if (secInBracket) seconds += parseInt(secInBracket[1]);
            
            return seconds > 0 ? seconds : null;
        }
        
        // [v5.3.0] 获取任务在指定日期的已记录时长（秒）- 仅用户记录，不含自动补录
        // [v5.5.2 Fix] 返回原始记录时长（未乘倍率），用于与应用实际使用时长对比
        // [v5.8.0 Fix] 从描述中解析时间，而不是用当前倍率反推
        function getTaskRecordedTimeForDate(taskId, dateStr) {
            let totalSeconds = 0;
            
            transactions.forEach(t => {
                if (t.taskId !== taskId) return;
                
                // 排除习惯奖励、连续奖励、系统记录、自动补录等非用户直接记录
                if (t.isHabitReward || t.isStreakAdvancement || t.isSystem || t.isAutoDetected) return;
                
                // 解析 transaction 的日期
                const tDate = new Date(t.timestamp);
                const tDateStr = getLocalDateString(tDate);
                
                if (tDateStr === dateStr) {
                    // [v5.8.0] 从描述中解析实际时长
                    let recordedSeconds = parseTimeFromDescription(t.description);
                    
                    // 如果无法从描述解析，回退到旧方法
                    if (recordedSeconds === null) {
                        const task = tasks.find(tk => tk.id === taskId);
                        const multiplier = task?.multiplier || 1;
                        recordedSeconds = Math.round((t.amount || 0) / multiplier);
                        // 检查透支惩罚
                        if (t.description && (t.description.includes('余额不足, 1.2倍消耗') || t.description.includes('历史余额不足, 1.2倍消耗'))) {
                            recordedSeconds = Math.round(recordedSeconds / 1.2);
                        }
                    }
                    
                    totalSeconds += recordedSeconds;
                }
            });
            
            return totalSeconds;
        }
        
        // [v5.6.0] 显示自动检测通知（支持补录和修正）
        function showAutoDetectNotification(results) {
            let content = '<div style="max-height: 400px; overflow-y: auto;">';
            
            const makeupResults = results.filter(r => r.type === 'makeup');
            const correctionResults = results.filter(r => r.type === 'correction');
            
            if (makeupResults.length > 0) {
                content += '<div style="margin-bottom: 16px;"><div style="font-weight: 600; color: var(--color-primary); margin-bottom: 8px;">🤖 已自动补录（漏记录）</div>';
                makeupResults.forEach(r => {
                    const penaltyStr = r.isSpend ? '×1.2惩罚' : '×0.8惩罚';
                    const changeStr = r.isSpend 
                        ? `<span style="color: #e74c3c;">-${formatTime(r.adjustedSeconds)}</span>`
                        : `<span style="color: var(--color-positive);">+${formatTime(r.adjustedSeconds)}</span>`;
                    content += `
                        <div style="padding: 8px; background: var(--card-bg); border-radius: 8px; margin-bottom: 8px;">
                            <div style="font-weight: 500;">${escapeHtml(r.task.name)}</div>
                            <div style="font-size: 0.85rem; color: var(--text-color-light); margin-top: 4px;">
                                ${r.date}: 实际 ${r.actualMinutes}分钟，已记录 ${r.recordedMinutes}分钟
                            </div>
                            <div style="font-size: 0.9rem; margin-top: 4px;">
                                补录 ${r.diffMinutes}分钟 (${penaltyStr}) → ${changeStr}
                            </div>
                        </div>`;
                });
                content += '</div>';
            }
            
            if (correctionResults.length > 0) {
                content += '<div><div style="font-weight: 600; color: #f39c12; margin-bottom: 8px;">🔧 已自动修正（多记录）</div>';
                correctionResults.forEach(r => {
                    const penaltyStr = r.isSpend ? '×0.8返还' : '×1.2扣减';
                    const changeStr = r.isSpend 
                        ? `<span style="color: var(--color-positive);">+${formatTime(r.adjustedSeconds)}</span>` // 返还
                        : `<span style="color: #e74c3c;">-${formatTime(r.adjustedSeconds)}</span>`; // 扣减
                    content += `
                        <div style="padding: 8px; background: rgba(243, 156, 18, 0.1); border-radius: 8px; margin-bottom: 8px;">
                            <div style="font-weight: 500;">${escapeHtml(r.task.name)}</div>
                            <div style="font-size: 0.85rem; color: var(--text-color-light); margin-top: 4px;">
                                ${r.date}: 实际 ${r.actualMinutes}分钟，已记录 ${r.recordedMinutes}分钟
                            </div>
                            <div style="font-size: 0.9rem; margin-top: 4px;">
                                修正 ${r.diffMinutes}分钟 (${penaltyStr}) → ${changeStr}
                            </div>
                        </div>`;
                });
                content += '</div>';
            }
            
            content += '</div>';
            
            showInfoModal('应用时间检测报告', content);
        }
        
        // [v5.2.0] 提前结算今日（可选）
        async function settleScreenTimeToday() {
            if (!screenTimeSettings.enabled) {
                showToast('请先启用屏幕时间管理');
                return;
            }
            
            if (typeof Android === 'undefined' || !Android.getTodayScreenTime) {
                showToast('此功能仅在 Android 应用中可用');
                return;
            }
            
            const usedMs = Android.getTodayScreenTime(JSON.stringify(screenTimeSettings.whitelistApps || []));
            if (usedMs < 0) {
                showToast('获取屏幕时间失败，请检查权限');
                return;
            }
            
            const usedMinutes = Math.floor(usedMs / 60000);
            const limitMinutes = screenTimeSettings.dailyLimitMinutes;
            const diff = limitMinutes - usedMinutes;
            const diffSeconds = diff * 60;
            
            const today = getLocalDateString(new Date());
            
            // 检查今日是否已结算
            if (screenTimeSettings.settledDates && screenTimeSettings.settledDates.includes(today)) {
                showToast('今日已结算过');
                return;
            }
            
            // 确认结算
            const confirmMsg = diff >= 0 
                ? `今日屏幕使用 ${formatScreenTimeMinutes(usedMinutes)}，未超过限额 ${formatScreenTimeMinutes(limitMinutes)}。\n\n将获得奖励: +${formatScreenTimeMinutes(diff)}\n\n⚠️ 提前结算后，今日后续使用将不再计入。\n\n确定提前结算吗？`
                : `今日屏幕使用 ${formatScreenTimeMinutes(usedMinutes)}，超出限额 ${formatScreenTimeMinutes(limitMinutes)}。\n\n将消耗时间: ${formatScreenTimeMinutes(-diff)}\n\n⚠️ 提前结算后，今日后续使用将不再计入。\n\n确定提前结算吗？`;
            
            if (!await showConfirm(confirmMsg, '提前结算今日')) return;
            
            // 执行结算
            const isReward = diffSeconds >= 0;
            const absAmount = Math.abs(diffSeconds);
            const todayKey = new Date().toDateString();
            
            currentBalance += diffSeconds;
            dailyChanges[todayKey] = dailyChanges[todayKey] || { earned: 0, spent: 0 };
            
            if (isReward) {
                dailyChanges[todayKey].earned += absAmount;
                showToast(`🎉 屏幕时间奖励: +${formatTime(absAmount)}`);
            } else {
                dailyChanges[todayKey].spent += absAmount;
                showToast(`📱 屏幕时间消耗: ${formatTime(absAmount)}`);
            }
            
            // 添加 transaction 记录
            const systemTask = SYSTEM_TASKS.SCREEN_TIME;
            // [v5.10.0] 使用用户自定义的分类
            const customCategory = isReward ? screenTimeSettings.earnCategory : screenTimeSettings.spendCategory;
            addTransaction({
                type: isReward ? 'earn' : 'spend',
                taskId: systemTask.id,
                taskName: systemTask.name,
                category: customCategory || SYSTEM_CATEGORY, // [v5.10.0] 保存分类
                amount: absAmount,
                description: `📱 屏幕时间: ${formatScreenTimeMinutes(usedMinutes)}/${formatScreenTimeMinutes(limitMinutes)} (${isReward ? '奖励' : '超出'}${formatScreenTimeMinutes(Math.abs(diff))})`,
                isSystem: true,
                systemType: 'screen-time',
                screenTimeData: {
                    usedMinutes,
                    limitMinutes,
                    diffMinutes: diff
                }
            });
            
            // 记录结算
            if (!screenTimeSettings.settledDates) screenTimeSettings.settledDates = [];
            screenTimeSettings.settledDates.push(today);
            screenTimeSettings.lastSettleDate = today;
            screenTimeSettings.lastSettleTime = Date.now();
            
            saveScreenTimeSettings();
            saveData();
            updateBalanceDisplay();
            updateScreenTimeCard();
            updateLastSettleTimeDisplay();
            
            // 添加历史记录
            addScreenTimeHistory(usedMinutes, limitMinutes, diff, today);
        }
        
        // [保留旧函数名以兼容] 原手动结算函数
        function settleScreenTime() {
            settleScreenTimeToday();
        }
        
        // 添加屏幕时间历史记录
        function addScreenTimeHistory(usedMinutes, limitMinutes, diffMinutes, actualDate) {
            // actualDate 格式: 'YYYY-MM-DD' 或 Date 对象
            let dateToStore;
            if (actualDate) {
                dateToStore = typeof actualDate === 'string' ? actualDate : getLocalDateString(actualDate);
            } else {
                dateToStore = getLocalDateString(new Date());
            }
            
            const record = {
                date: dateToStore,
                usedMinutes,
                limitMinutes,
                diffMinutes,
                type: diffMinutes >= 0 ? 'reward' : 'consume'
            };
            
            let history = JSON.parse(localStorage.getItem('screenTimeHistory') || '[]');
            history.push(record);
            // 只保留最近 30 条
            if (history.length > 30) {
                history = history.slice(-30);
            }
            localStorage.setItem('screenTimeHistory', JSON.stringify(history));
        }
        
        // [v5.10.0] 屏幕时间分类迁移工具：将历史记录从「系统」分类迁移到用户选择的分类
        async function migrateScreenTimeCategoryRecords() {
            // 检查用户是否已设置自定义分类
            const earnCategory = screenTimeSettings.earnCategory;
            const spendCategory = screenTimeSettings.spendCategory;
            
            if (!earnCategory && !spendCategory) {
                showInfoModal('分类修复', `
                    <p>ℹ️ 您还未设置屏幕时间的自定义分类。</p>
                    <p style="margin-top: 12px;">请先在 <strong>屏幕时间管理 → 分类标签</strong> 中选择您希望的分类，然后再运行此修复工具。</p>
                `);
                return;
            }
            
            // 找出所有屏幕时间记录（仅限「系统」分类的）
            const screenTimeRecords = transactions.filter(t => 
                t.systemType === 'screen-time' && 
                (!t.category || t.category === SYSTEM_CATEGORY)
            );
            
            if (screenTimeRecords.length === 0) {
                showInfoModal('分类修复', `<p>✅ 没有需要修复的记录，所有屏幕时间记录已使用自定义分类。</p>`);
                return;
            }
            
            // 统计待修复记录
            const earnRecords = screenTimeRecords.filter(r => r.type === 'earn');
            const spendRecords = screenTimeRecords.filter(r => r.type === 'spend');
            
            // 构建确认弹窗
            let content = `<div style="text-align: left;">`;
            content += `<p style="margin-bottom: 12px;">发现 <strong>${screenTimeRecords.length}</strong> 条屏幕时间记录使用「系统」分类，可修复为您设置的自定义分类：</p>`;
            content += `<div style="background: var(--card-bg); padding: 12px; border-radius: 8px; margin-bottom: 12px;">`;
            
            if (earnRecords.length > 0 && earnCategory) {
                content += `<p>🟢 <strong>${earnRecords.length}</strong> 条节省时间记录 → <strong>${earnCategory}</strong></p>`;
            } else if (earnRecords.length > 0) {
                content += `<p style="color: var(--text-color-light);">🟢 ${earnRecords.length} 条节省时间记录（未设置分类，将保持「系统」）</p>`;
            }
            
            if (spendRecords.length > 0 && spendCategory) {
                content += `<p>🔴 <strong>${spendRecords.length}</strong> 条超出时间记录 → <strong>${spendCategory}</strong></p>`;
            } else if (spendRecords.length > 0) {
                content += `<p style="color: var(--text-color-light);">🔴 ${spendRecords.length} 条超出时间记录（未设置分类，将保持「系统」）</p>`;
            }
            
            content += `</div>`;
            content += `<p style="color: var(--text-color-light); font-size: 0.9rem;">ℹ️ 此操作仅修改分类标签，不影响时间余额。</p>`;
            content += `</div>`;
            
            if (!await showConfirm(content, '确认修复分类')) return;
            
            // 执行修复
            let fixedCount = 0;
            screenTimeRecords.forEach(record => {
                if (record.type === 'earn' && earnCategory) {
                    record.category = earnCategory;
                    fixedCount++;
                } else if (record.type === 'spend' && spendCategory) {
                    record.category = spendCategory;
                    fixedCount++;
                }
            });
            
            // 保存数据
            saveData();
            updateAllUI();
            
            showToast(`✅ 已修复 ${fixedCount} 条屏幕时间记录的分类`);
        }
        
        // [v5.6.0] 清理重复的屏幕时间记录
        function cleanupDuplicateScreenTimeRecords() {
            // 找出所有屏幕时间相关的记录
            const screenTimeRecords = transactions.filter(t => 
                t.systemType === 'screen-time' || 
                (t.description && t.description.includes('屏幕时间'))
            );
            
            // 按 originalDate 分组
            const recordsByDate = {};
            screenTimeRecords.forEach(record => {
                const dateStr = record.screenTimeData?.originalDate;
                if (dateStr) {
                    if (!recordsByDate[dateStr]) {
                        recordsByDate[dateStr] = [];
                    }
                    recordsByDate[dateStr].push(record);
                }
            });
            
            // 找出需要删除的记录
            const duplicateDates = []; // 有重复的日期
            const oldFormatDates = []; // 只有旧格式的日期
            const toRemove = [];
            
            Object.keys(recordsByDate).forEach(dateStr => {
                const records = recordsByDate[dateStr];
                const newFormat = records.filter(r => r.description && r.description.startsWith('📱'));
                const oldFormat = records.filter(r => r.description && !r.description.startsWith('📱'));
                
                if (records.length > 1) {
                    // 有重复记录
                    duplicateDates.push(dateStr);
                    if (newFormat.length > 0 && oldFormat.length > 0) {
                        // 有新格式，删除所有旧格式
                        toRemove.push(...oldFormat);
                    } else {
                        // 全是同一格式，保留第一条
                        toRemove.push(...records.slice(1));
                    }
                } else if (records.length === 1 && oldFormat.length === 1) {
                    // 只有一条旧格式记录，也标记为待清理（可选）
                    oldFormatDates.push(dateStr);
                }
            });
            
            // 构建确认弹窗
            let content = `<div style="text-align: left; max-height: 400px; overflow-y: auto;">`;
            
            if (toRemove.length === 0 && oldFormatDates.length === 0) {
                showInfoModal('数据检查', `<p>✅ 未发现需要清理的屏幕时间记录，数据正常。</p>`);
                return;
            }
            
            // 计算重复记录的退还金额
            let refundAmount = 0;
            toRemove.forEach(record => {
                if (record.type === 'spend') {
                    refundAmount += record.amount;
                } else if (record.type === 'earn') {
                    refundAmount -= record.amount;
                }
            });
            
            // 显示重复记录
            if (toRemove.length > 0) {
                content += `<p style="color: #e74c3c; margin-bottom: 12px;">⚠️ 发现 <strong>${duplicateDates.length}</strong> 天有重复记录，共 <strong>${toRemove.length}</strong> 条</p>`;
                content += `<p style="margin-bottom: 12px;">重复日期: ${duplicateDates.sort().join(', ')}</p>`;
                content += `<div style="background: var(--card-bg); padding: 12px; border-radius: 8px; margin-bottom: 12px;">`;
                content += `<p><strong>将删除的重复记录:</strong></p>`;
                content += `<ul style="font-size: 0.85rem; padding-left: 20px; margin-top: 8px;">`;
                toRemove.slice(0, 10).forEach(r => {
                    const typeIcon = r.type === 'spend' ? '🔻' : '🔺';
                    content += `<li>${r.screenTimeData?.originalDate}: ${typeIcon} ${formatTime(r.amount)}</li>`;
                });
                if (toRemove.length > 10) {
                    content += `<li>... 等 ${toRemove.length} 条</li>`;
                }
                content += `</ul></div>`;
                
                const refundStr = refundAmount >= 0 
                    ? `<span style="color: var(--color-positive);">+${formatTime(refundAmount)}</span>` 
                    : `<span style="color: #e74c3c;">${formatTime(refundAmount)}</span>`;
                content += `<p>清理重复记录后余额变化: ${refundStr}</p>`;
            }
            
            // 显示旧格式单独记录（可选删除）
            if (oldFormatDates.length > 0) {
                const oldRecords = oldFormatDates.map(d => recordsByDate[d][0]);
                let oldRefund = 0;
                oldRecords.forEach(r => {
                    if (r.type === 'spend') oldRefund += r.amount;
                    else if (r.type === 'earn') oldRefund -= r.amount;
                });
                
                content += `<div style="margin-top: 16px; padding: 12px; background: rgba(243, 156, 18, 0.1); border-radius: 8px;">`;
                content += `<p style="color: #f39c12; margin-bottom: 8px;">📋 发现 <strong>${oldFormatDates.length}</strong> 天有旧格式记录（启用屏幕时间管理前被补结算的）:</p>`;
                content += `<p style="font-size: 0.85rem; margin-bottom: 8px;">${oldFormatDates.sort().join(', ')}</p>`;
                content += `<ul style="font-size: 0.85rem; padding-left: 20px;">`;
                oldRecords.forEach(r => {
                    const typeIcon = r.type === 'spend' ? '🔻' : '🔺';
                    content += `<li>${r.screenTimeData?.originalDate}: ${typeIcon} ${formatTime(r.amount)}</li>`;
                });
                content += `</ul>`;
                const oldRefundStr = oldRefund >= 0 
                    ? `<span style="color: var(--color-positive);">+${formatTime(oldRefund)}</span>` 
                    : `<span style="color: #e74c3c;">${formatTime(oldRefund)}</span>`;
                content += `<p style="margin-top: 8px;">如同时删除，额外变化: ${oldRefundStr}</p>`;
                content += `<label style="display: flex; align-items: center; margin-top: 8px; cursor: pointer;">`;
                content += `<input type="checkbox" id="includeOldFormat" style="margin-right: 8px;"> 同时删除这些旧格式记录`;
                content += `</label></div>`;
                
                // 暂存旧格式记录
                window._pendingOldFormatIds = oldRecords.map(r => r.id);
                window._pendingOldFormatRefund = oldRefund;
            }
            
            content += `<div style="margin-top: 16px; text-align: center;">`;
            content += `<button class="btn btn-secondary" onclick="hideInfoModal()" style="margin-right: 8px;">取消</button>`;
            content += `<button class="btn btn-primary" onclick="executeCleanupDuplicates()">确认清理</button>`;
            content += `</div></div>`;
            
            // 暂存待删除的记录 ID
            window._pendingCleanupIds = toRemove.map(r => r.id);
            window._pendingRefundAmount = refundAmount;
            
            showInfoModal('🔧 清理屏幕时间记录', content);
        }
        
        // 执行清理
        function executeCleanupDuplicates() {
            let idsToRemove = window._pendingCleanupIds || [];
            let refundAmount = window._pendingRefundAmount || 0;
            
            // 检查是否勾选了删除旧格式记录
            const includeOldFormat = document.getElementById('includeOldFormat')?.checked;
            if (includeOldFormat && window._pendingOldFormatIds) {
                idsToRemove = idsToRemove.concat(window._pendingOldFormatIds);
                refundAmount += window._pendingOldFormatRefund || 0;
            }
            
            if (idsToRemove.length === 0) {
                hideInfoModal();
                showToast('没有需要清理的记录');
                return;
            }
            
            // 从 transactions 中删除
            const beforeCount = transactions.length;
            transactions = transactions.filter(t => !idsToRemove.includes(t.id));
            const removedCount = beforeCount - transactions.length;
            
            // 调整余额
            currentBalance += refundAmount;
            
            // 保存
            saveData();
            updateBalanceDisplay();
            
            // 清理暂存
            delete window._pendingCleanupIds;
            delete window._pendingRefundAmount;
            delete window._pendingOldFormatIds;
            delete window._pendingOldFormatRefund;
            
            hideInfoModal();
            
            const refundStr = refundAmount >= 0 
                ? `+${formatTime(refundAmount)}` 
                : formatTime(refundAmount);
            showToast(`✅ 已清理 ${removedCount} 条重复记录，余额 ${refundStr}`);
        }
        
        // [v5.9.0] 事件日志验证工具 - 供高级用户使用
        async function runEventValidation() {
            const currentUser = AV.User.current();
            if (!currentUser) {
                showToast('请先登录');
                return;
            }
            
            showToast('正在验证事件日志...', 10000);
            
            try {
                const result = await validateStateFromEvents();
                
                let content = '<div style="text-align: left; max-height: 400px; overflow-y: auto;">';
                
                if (result.error) {
                    content += `<p style="color: #e74c3c;">❌ 验证失败: ${result.error}</p>`;
                } else if (result.isValid) {
                    content += `<p style="color: var(--color-positive);">✅ 状态验证通过！</p>`;
                    content += `<p style="margin-top: 8px;">快照与事件日志计算结果完全一致。</p>`;
                    content += `<div style="background: var(--card-bg); padding: 12px; border-radius: 8px; margin-top: 12px;">`;
                    content += `<p><strong>当前状态:</strong></p>`;
                    content += `<ul style="font-size: 0.85rem; padding-left: 20px; margin-top: 8px;">`;
                    content += `<li>余额: ${formatTime(currentBalance)}</li>`;
                    content += `<li>任务数: ${tasks.length}</li>`;
                    content += `<li>交易数: ${transactions.length}</li>`;
                    content += `</ul></div>`;
                } else {
                    content += `<p style="color: #f39c12;">⚠️ 发现 ${result.differences.length} 处差异</p>`;
                    content += `<div style="background: var(--card-bg); padding: 12px; border-radius: 8px; margin-top: 12px;">`;
                    result.differences.forEach(diff => {
                        if (diff.type === 'balance') {
                            content += `<p>📊 <strong>余额不一致</strong>: 快照 ${formatTime(diff.snapshot)} vs 计算 ${formatTime(diff.computed)}</p>`;
                        } else if (diff.type === 'transaction_count') {
                            content += `<p>📝 <strong>交易数不一致</strong>: 快照 ${diff.snapshot} 条 vs 计算 ${diff.computed} 条</p>`;
                        } else if (diff.type === 'task_count') {
                            content += `<p>📋 <strong>任务数不一致</strong>: 快照 ${diff.snapshot} 个 vs 计算 ${diff.computed} 个</p>`;
                        } else if (diff.type === 'habit_streak') {
                            content += `<p>🔥 <strong>习惯连续天数不一致</strong> (${diff.taskName}): 快照 ${diff.snapshot} vs 计算 ${diff.computed}</p>`;
                        }
                    });
                    content += `</div>`;
                    content += `<p style="margin-top: 12px; font-size: 0.85rem; color: var(--text-secondary);">`;
                    content += `注意: 差异可能是因为事件日志未记录历史操作（v5.8.1之前的操作）。`;
                    content += `</p>`;
                    
                    // 暂不提供自动修复功能，待事件日志数据完整后再启用
                    // content += `<div style="margin-top: 16px; text-align: center;">`;
                    // content += `<button class="btn btn-primary" onclick="repairStateFromEvents(); hideInfoModal();">尝试修复</button>`;
                    // content += `</div>`;
                }
                
                content += '</div>';
                
                showInfoModal('🔍 事件日志验证', content);
                
            } catch (e) {
                console.error('[ES] 验证失败:', e);
                showToast('验证失败: ' + e.message, 3000);
            }
        }
        
        // [v5.9.0] 检查事件日志并显示 ES 诊断工具
        async function checkAndShowESTools() {
            const currentUser = AV.User.current();
            if (!currentUser) return;
            
            try {
                const query = new AV.Query('UserTimeBankEvent');
                query.equalTo('owner', currentUser);
                query.limit(1);
                const count = await query.count();
                
                if (count > 0) {
                    const esContainer = document.getElementById('esToolsContainer');
                    if (esContainer) {
                        esContainer.style.display = 'block';
                        console.log(`[ES] 发现 ${count} 条事件记录，已启用诊断工具`);
                    }
                }
            } catch (e) {
                console.warn('[ES] 检查事件日志失败:', e.message);
            }
        }
        
        // [v5.2.0] 检查并提供历史补结算
        function checkAndOfferHistoricalSettlement() {
            try {
                console.log('[ScreenTime] checkAndOfferHistoricalSettlement called');
                
                if (typeof Android === 'undefined') {
                    showAlert('此功能仅在 Android 应用中可用');
                    return;
                }
                
                if (!Android.getScreenTimeForDate) {
                    showAlert('请重新编译安装 App 以启用此功能\n\n当前 Android 接口缺少 getScreenTimeForDate 方法');
                    return;
                }
                
                if (!screenTimeSettings.enabled) {
                    showAlert('请先启用屏幕时间管理');
                    return;
                }
                
                // 获取过去7天有数据的日期（不含今天）
                const today = getLocalDateString(new Date());
                const availableDates = [];
                const debugLines = [];
                
                for (let i = 1; i <= 7; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateStr = getLocalDateString(date);
                    
                    // 跳过已结算的日期
                    if (screenTimeSettings.settledDates && screenTimeSettings.settledDates.includes(dateStr)) {
                        debugLines.push(`${dateStr}: 已结算，跳过`);
                        continue;
                    }
                    
                    // 检查是否有数据
                    try {
                        const usedMs = Android.getScreenTimeForDate(dateStr, JSON.stringify(screenTimeSettings.whitelistApps || []));
                        debugLines.push(`${dateStr}: ${usedMs}ms (${Math.floor(usedMs/60000)}分钟)`);
                        if (usedMs > 0) {
                            availableDates.push({
                                date: dateStr,
                                usedMs: usedMs,
                                usedMinutes: Math.floor(usedMs / 60000)
                            });
                        }
                    } catch (e) {
                        debugLines.push(`${dateStr}: 查询出错 - ${e.message}`);
                    }
                }
                
                console.log('[ScreenTime] Query results:', debugLines);
                
                if (availableDates.length === 0) {
                    showAlert('过去7天没有可补结算的数据\n\n详情:\n' + debugLines.join('\n'));
                    return;
                }
                
                // 显示补结算弹窗
                showHistoricalSettlementModal(availableDates);
            } catch (e) {
                showAlert('补结算检查出错: ' + e.message + '\n\n' + e.stack, '错误');
            }
        }
        
        // 显示历史补结算弹窗
        let pendingSettlementDates = null; // 临时存储待结算数据，避免通过 onclick 传递复杂对象
        
        function showHistoricalSettlementModal(availableDates) {
            // 存储到全局变量，避免 JSON 序列化问题
            pendingSettlementDates = availableDates;
            
            const limitMinutes = screenTimeSettings.dailyLimitMinutes;
            
            let totalReward = 0;
            let totalPenalty = 0;
            
            const rows = availableDates.map(item => {
                const diff = limitMinutes - item.usedMinutes;
                if (diff >= 0) {
                    totalReward += diff;
                } else {
                    totalPenalty += Math.abs(diff);
                }
                const diffStr = diff >= 0 
                    ? `<span style="color: var(--color-primary);">+${formatScreenTimeMinutes(diff)}</span>` 
                    : `<span style="color: #e74c3c;">-${formatScreenTimeMinutes(-diff)}</span>`;
                return `
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border-color);">
                        <span>${item.date}</span>
                        <span>${formatScreenTimeMinutes(item.usedMinutes)}</span>
                        <span>${diffStr}</span>
                    </div>
                `;
            }).join('');
            
            const netEffect = totalReward - totalPenalty;
            const netStr = netEffect >= 0 
                ? `<span style="color: var(--color-primary); font-weight: bold;">+${formatScreenTimeMinutes(netEffect)}</span>`
                : `<span style="color: #e74c3c; font-weight: bold;">-${formatScreenTimeMinutes(-netEffect)}</span>`;
            
            const content = `
                <div style="margin-bottom: 16px;">
                    <p>检测到过去 ${availableDates.length} 天有屏幕使用数据。</p>
                    <p>是否按当前限额 (${formatScreenTimeMinutes(limitMinutes)}/天) 进行补结算？</p>
                </div>
                <div style="background: var(--bg-color-light); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; font-weight: 600; border-bottom: 2px solid var(--border-color);">
                        <span>日期</span>
                        <span>使用时间</span>
                        <span>奖惩</span>
                    </div>
                    ${rows}
                    <div style="display: flex; justify-content: space-between; padding: 12px 0 4px; font-weight: 600;">
                        <span>合计</span>
                        <span></span>
                        <span>${netStr}</span>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button class="btn-secondary" onclick="hideInfoModal(); pendingSettlementDates = null;">跳过</button>
                    <button class="btn-primary" id="confirmSettlementBtn" onclick="executeHistoricalSettlement()">确认补结算</button>
                </div>
            `;
            
            showInfoModal('历史数据补结算', content);
        }
        
        // 执行历史补结算
        function executeHistoricalSettlement() {
            // 从全局变量获取数据
            if (!pendingSettlementDates || pendingSettlementDates.length === 0) {
                showToast('没有待结算的数据');
                hideInfoModal();
                return;
            }
            
            // 禁用按钮防止重复点击
            const btn = document.getElementById('confirmSettlementBtn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = '处理中...';
            }
            
            const availableDates = pendingSettlementDates;
            pendingSettlementDates = null; // 清空，防止重复执行
            
            const limitMinutes = screenTimeSettings.dailyLimitMinutes;
            let totalChange = 0;
            let settledCount = 0;
            
            // 初始化 settledDates 数组
            if (!screenTimeSettings.settledDates) {
                screenTimeSettings.settledDates = [];
            }
            
            // 使用 Set 进行去重，防止同一天多次结算
            const processedDates = new Set();
            
            availableDates.forEach(item => {
                const dateStr = item.date;
                
                // 跳过已处理或已结算的日期
                if (processedDates.has(dateStr) || screenTimeSettings.settledDates.includes(dateStr)) {
                    console.log(`[ScreenTime] 跳过已结算日期: ${dateStr}`);
                    return;
                }
                
                // [v5.6.0] 检查是否已有该日期的屏幕时间交易记录（兼容旧格式）
                const hasExistingRecord = transactions.some(t => 
                    t.screenTimeData?.originalDate === dateStr ||
                    (t.systemType === 'screen-time' && t.screenTimeData?.originalDate === dateStr)
                );
                if (hasExistingRecord) {
                    console.log(`[ScreenTime] 跳过已有记录的日期: ${dateStr}`);
                    return;
                }
                
                processedDates.add(dateStr);
                
                const usedMinutes = item.usedMinutes;
                const diff = limitMinutes - usedMinutes;
                const diffSeconds = diff * 60;
                const isReward = diff >= 0;
                const absAmount = Math.abs(diffSeconds);
                
                // 更新余额
                currentBalance += diffSeconds;
                totalChange += diffSeconds;
                
                // 计算该日期对应的 dailyChanges key
                const [year, month, day] = dateStr.split('-').map(Number);
                const dateObj = new Date(year, month - 1, day);
                const dayKey = dateObj.toDateString();
                dailyChanges[dayKey] = dailyChanges[dayKey] || { earned: 0, spent: 0 };
                
                if (isReward) {
                    dailyChanges[dayKey].earned += absAmount;
                } else {
                    dailyChanges[dayKey].spent += absAmount;
                }
                
                // 添加 transaction 记录（标记为补结算）
                const systemTask = SYSTEM_TASKS.SCREEN_TIME;
                // [v5.10.0] 使用用户自定义的分类
                const customCategory = isReward ? screenTimeSettings.earnCategory : screenTimeSettings.spendCategory;
                addTransaction({
                    type: isReward ? 'earn' : 'spend',
                    taskId: systemTask.id,
                    taskName: systemTask.name,
                    category: customCategory || SYSTEM_CATEGORY, // [v5.10.0] 保存分类
                    amount: absAmount,
                    description: `📱 屏幕时间: ${formatScreenTimeMinutes(usedMinutes)}/${formatScreenTimeMinutes(limitMinutes)} (${isReward ? '奖励' : '超出'}${formatScreenTimeMinutes(Math.abs(diff))})`,
                    timestamp: new Date(dateObj.getTime() + 23 * 60 * 60 * 1000).toISOString(), // 设为当天23:00
                    isSystem: true,
                    systemType: 'screen-time',
                    isBackdate: true, // 标记为补结算
                    screenTimeData: {
                        usedMinutes,
                        limitMinutes,
                        diffMinutes: diff,
                        originalDate: dateStr
                    }
                });
                
                // 记录到已结算日期（前面已初始化，这里直接添加）
                screenTimeSettings.settledDates.push(dateStr);
                
                // 添加历史记录
                addScreenTimeHistory(usedMinutes, limitMinutes, diff, dateStr);
                
                settledCount++;
            });
            
            // 保存数据
            saveScreenTimeSettings();
            saveData();
            updateBalanceDisplay();
            hideInfoModal();
            
            // 显示结果
            const changeStr = totalChange >= 0 
                ? `+${formatTime(totalChange)}`
                : `-${formatTime(Math.abs(totalChange))}`;
            showToast(`✅ 已补结算 ${settledCount} 天，余额变化: ${changeStr}`);
        }
        
        // 更新上次结算时间显示
        function updateLastSettleTimeDisplay() {
            const el = document.getElementById('lastSettleTime');
            if (!el) return;
            
            const today = getLocalDateString(new Date());
            
            // 检查今日是否已提前结算
            if (screenTimeSettings.settledDates && screenTimeSettings.settledDates.includes(today)) {
                const time = screenTimeSettings.lastSettleTime ? new Date(screenTimeSettings.lastSettleTime) : new Date();
                el.textContent = `今日已提前结算 (${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')})`;
            } else {
                el.textContent = '可选：提前锁定今日结果';
            }
        }
        
        // 屏幕时间详情弹窗
        function showScreenTimeDetails() {
            if (typeof Android !== 'undefined' && Android.getTodayScreenTime) {
                const usedMs = Android.getTodayScreenTime(JSON.stringify(screenTimeSettings.whitelistApps));
                if (usedMs < 0) {
                    showToast('获取屏幕时间失败');
                    return;
                }
                
                const usedMinutes = Math.floor(usedMs / 60000);
                const limitMinutes = screenTimeSettings.dailyLimitMinutes;
                const diff = limitMinutes - usedMinutes;
                
                // [v5.5.0] 获取应用使用时长列表
                let appUsageHtml = '';
                if (Android.getAppUsageList) {
                    try {
                        const appListJson = Android.getAppUsageList(JSON.stringify(screenTimeSettings.whitelistApps));
                        const appList = JSON.parse(appListJson);
                        
                        if (appList.length > 0) {
                            const top5 = appList.slice(0, 5);
                            const others = appList.slice(5);
                            const othersTime = others.reduce((sum, app) => sum + app.timeMs, 0);
                            const othersCount = others.length;
                            
                            // 颜色调色板
                            const colors = ['#4CAF50', '#FF9800', '#2196F3', '#9C27B0', '#795548', '#607D8B'];
                            
                            appUsageHtml = `
                            <div style="margin-top: 16px; border-top: 1px solid var(--border-color); padding-top: 12px;">
                                <div style="font-weight: 600; margin-bottom: 10px; font-size: 0.95rem;">📊 今日使用分布</div>
                                <div style="display: flex; flex-direction: column; gap: 8px;">`;
                            
                            top5.forEach((app, index) => {
                                const timeMinutes = Math.floor(app.timeMs / 60000);
                                const percent = usedMs > 0 ? Math.round(app.timeMs / usedMs * 100) : 0;
                                const color = colors[index];
                                appUsageHtml += `
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="width: 10px; height: 10px; border-radius: 50%; background: ${color}; flex-shrink: 0;"></div>
                                    <div style="flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.9rem;">${app.appName}</div>
                                    <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-color-light); white-space: nowrap;">${formatScreenTimeCompact(timeMinutes)}</div>
                                    <div style="width: 40px; text-align: right; font-size: 0.8rem; color: var(--text-color-light);">${percent}%</div>
                                </div>`;
                            });
                            
                            // 显示"其他"类别
                            if (othersCount > 0) {
                                const othersMinutes = Math.floor(othersTime / 60000);
                                const othersPercent = usedMs > 0 ? Math.round(othersTime / usedMs * 100) : 0;
                                appUsageHtml += `
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="width: 10px; height: 10px; border-radius: 50%; background: ${colors[5]}; flex-shrink: 0;"></div>
                                    <div style="flex: 1; min-width: 0; font-size: 0.9rem; color: var(--text-color-light);">其他 (${othersCount}个)</div>
                                    <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-color-light); white-space: nowrap;">${formatScreenTimeCompact(othersMinutes)}</div>
                                    <div style="width: 40px; text-align: right; font-size: 0.8rem; color: var(--text-color-light);">${othersPercent}%</div>
                                </div>`;
                            }
                            
                            appUsageHtml += '</div></div>';
                        }
                    } catch (e) {
                        console.error('获取应用使用列表失败:', e);
                    }
                }
                
                const history = JSON.parse(localStorage.getItem('screenTimeHistory') || '[]');
                const recentHistory = history.slice(-6).reverse();
                
                let historyHtml = '';
                if (recentHistory.length > 0) {
                    historyHtml = `
                    <div style="margin-top: 16px; border-top: 1px solid var(--border-color); padding-top: 12px;">
                        <div style="font-weight: 600; margin-bottom: 10px; font-size: 0.95rem;">最近结算记录</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">`;
                    recentHistory.forEach(record => {
                        // 兼容新旧格式：新格式 'YYYY-MM-DD'，旧格式 ISO 字符串
                        let dateStr;
                        if (record.date.includes('T')) {
                            // 旧格式：ISO 字符串
                            const date = new Date(record.date);
                            dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
                        } else {
                            // 新格式：'YYYY-MM-DD'
                            const parts = record.date.split('-');
                            dateStr = `${parseInt(parts[1])}/${parseInt(parts[2])}`;
                        }
                        const isReward = record.type === 'reward';
                        const diffValue = isReward ? record.diffMinutes : -record.diffMinutes;
                        const diffColor = isReward ? 'var(--color-primary)' : '#e74c3c';
                        const diffSign = isReward ? '+' : '-';
                        // [v6.1.0] 使用CSS变量获取动态主题色
                        const primaryRgb = getComputedStyle(document.documentElement).getPropertyValue('--color-primary-rgb').trim() || '33, 150, 243';
                        const bgColor = isReward ? `rgba(${primaryRgb}, 0.12)` : 'rgba(231, 76, 60, 0.1)';
                        
                        historyHtml += `
                        <div style="flex: 0 0 calc(50% - 4px); background: ${bgColor}; border-radius: 8px; padding: 8px 10px; box-sizing: border-box;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-weight: 600; font-size: 0.85rem;">${dateStr}</span>
                                <span style="font-weight: 600; font-size: 0.9rem; color: ${diffColor};">${diffSign}${formatScreenTimeCompact(Math.abs(diffValue))}</span>
                            </div>
                            <div style="font-size: 0.75rem; color: var(--text-color-light);">
                                ${formatScreenTimeCompact(record.usedMinutes)} / ${formatScreenTimeCompact(record.limitMinutes)}
                            </div>
                        </div>`;
                    });
                    historyHtml += '</div></div>';
                }
                
                const content = `
                    <div style="text-align: center; padding: 20px 0;">
                        <div style="font-size: 2.5rem; margin-bottom: 8px;">📱</div>
                        <div style="font-size: 1.5rem; font-weight: bold; color: var(--color-primary);">${formatScreenTimeMinutes(usedMinutes)}</div>
                        <div style="color: var(--text-color-light); margin-top: 4px;">今日已使用 / 限额 ${formatScreenTimeMinutes(limitMinutes)}</div>
                        <div style="margin-top: 0px; margin-bottom: -18px; padding: 12px; background: ${diff >= 0 ? 'var(--color-primary-light)' : 'rgba(231, 76, 60, 0.1)'}; border-radius: 8px;">
                            <span style="font-weight: 600; color: ${diff >= 0 ? 'var(--color-primary)' : '#e74c3c'};">
                                ${diff >= 0 ? '预计奖励: +' + formatScreenTimeMinutes(diff) : '预计消耗: ' + formatScreenTimeMinutes(-diff)}
                            </span>
                        </div>
                    </div>
                    ${appUsageHtml}
                    ${historyHtml}
                `;
                
                showInfoModal('屏幕时间详情', content);
            }
        }
        
        // 白名单应用列表
        let installedAppsCache = null;
        
        function openScreenTimeWhitelist() {
            if (typeof Android === 'undefined' || !Android.getInstalledApps) {
                showToast('此功能仅在 Android 应用中可用');
                return;
            }
            
            // 获取已安装应用列表
            if (!installedAppsCache) {
                const appsJson = Android.getInstalledApps();
                installedAppsCache = JSON.parse(appsJson);
                // 按应用名排序
                installedAppsCache.sort((a, b) => a.appName.localeCompare(b.appName, 'zh'));
            }
            
            showWhitelistModal(installedAppsCache);
        }
        
        function showWhitelistModal(apps) {
            const modal = document.getElementById('whitelistModal');
            if (!modal) {
                // 动态创建弹窗
                const modalHtml = `
                    <div id="whitelistModal" class="modal" onclick="if(event.target===this)closeWhitelistModal()">
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header">
                                <h2 class="modal-title">白名单应用</h2>
                                <button class="close-btn" onclick="closeWhitelistModal()">&times;</button>
                            </div>
                            <div class="modal-body">
                                <p style="font-size: 0.85rem; color: var(--text-color-light); margin-bottom: 8px;">勾选的应用不计入屏幕使用时间</p>
                                <p id="whitelistSelectedCount" style="font-size: 0.85rem; color: var(--color-earn); margin-bottom: 12px; font-weight: 500;"></p>
                                <input type="text" id="whitelistSearch" class="whitelist-search" placeholder="搜索应用名称或包名..." oninput="filterWhitelistApps()">
                                <div id="whitelistAppList" class="whitelist-modal-content"></div>
                            </div>
                            <div class="modal-footer" style="justify-content: flex-end;">
                                <button class="btn btn-secondary" onclick="closeWhitelistModal()">取消</button>
                                <button class="btn btn-primary" onclick="saveWhitelist()">保存</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
            }
            
            renderWhitelistApps(apps);
            updateWhitelistSelectedCount();
            document.getElementById('whitelistModal').classList.add('show');
        }
        
        function updateWhitelistSelectedCount() {
            const pkgs = screenTimeSettings.whitelistApps;
            const el = document.getElementById('whitelistSelectedCount');
            if (el) {
                if (pkgs.length === 0) {
                    el.textContent = '';
                } else {
                    // 通过包名查找应用名称
                    const names = pkgs.map(pkg => {
                        const app = (installedAppsCache || []).find(a => a.packageName === pkg);
                        return app ? app.appName : pkg.split('.').pop(); // 没找到则显示包名最后一段
                    });
                    el.textContent = `已选择: ${names.join('、')}`;
                }
            }
        }
        
        function renderWhitelistApps(apps, filter = '') {
            const container = document.getElementById('whitelistAppList');
            const filterLower = filter.toLowerCase();
            
            const html = apps
                .filter(app => !filter || app.appName.toLowerCase().includes(filterLower) || app.packageName.toLowerCase().includes(filterLower))
                .map(app => `
                    <label class="whitelist-item">
                        <input type="checkbox" value="${app.packageName}" 
                               ${screenTimeSettings.whitelistApps.includes(app.packageName) ? 'checked' : ''}
                               onchange="onWhitelistCheckChange(this)">
                        <div>
                            <div class="whitelist-item-name">${app.appName}</div>
                            <div class="whitelist-item-pkg">${app.packageName}</div>
                        </div>
                    </label>
                `).join('');
            
            container.innerHTML = html || '<div style="text-align: center; padding: 20px; color: var(--text-color-light);">没有找到匹配的应用</div>';
        }
        
        function onWhitelistCheckChange(checkbox) {
            const pkg = checkbox.value;
            if (checkbox.checked) {
                if (!screenTimeSettings.whitelistApps.includes(pkg)) {
                    screenTimeSettings.whitelistApps.push(pkg);
                }
            } else {
                screenTimeSettings.whitelistApps = screenTimeSettings.whitelistApps.filter(p => p !== pkg);
            }
            updateWhitelistSelectedCount();
        }
        
        function filterWhitelistApps() {
            const filter = document.getElementById('whitelistSearch').value;
            renderWhitelistApps(installedAppsCache || [], filter);
        }
        
        function saveWhitelist() {
            // 获取当前显示的已勾选项
            const checkboxes = document.querySelectorAll('#whitelistAppList input[type="checkbox"]:checked');
            const currentChecked = Array.from(checkboxes).map(cb => cb.value);
            
            // 获取当前显示的所有项（包括未勾选的）
            const allDisplayedCheckboxes = document.querySelectorAll('#whitelistAppList input[type="checkbox"]');
            const displayedPackages = Array.from(allDisplayedCheckboxes).map(cb => cb.value);
            
            // 保留不在当前显示列表中的已有选项（因为可能被搜索过滤掉了）
            const hiddenSelected = screenTimeSettings.whitelistApps.filter(pkg => !displayedPackages.includes(pkg));
            
            // 合并：当前显示的已勾选 + 隐藏的已选项
            screenTimeSettings.whitelistApps = [...new Set([...currentChecked, ...hiddenSelected])];
            
            saveScreenTimeSettings();
            document.getElementById('whitelistCount').textContent = `${screenTimeSettings.whitelistApps.length} 个应用不计入使用时间`;
            closeWhitelistModal();
            updateScreenTimeCard();
            showToast(`已保存 ${screenTimeSettings.whitelistApps.length} 个白名单应用`);
        }
        
        function closeWhitelistModal() {
            const modal = document.getElementById('whitelistModal');
            if (modal) modal.classList.remove('show');
        }
        
        // ========== 屏幕时间管理结束 ==========
        
        // [v6.2.0] 主题色渐变方案 - 含画作主题
        const accentThemes = {
            'blue-purple': {
                primary: '#2196F3',
                start: '#2196F3',
                mid: '#5c6bc0',
                end: '#7c4dff',
                gradient: 'linear-gradient(135deg, #2196F3 0%, #5c6bc0 50%, #7c4dff 100%)',
                bgLight: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                bgDark: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',
                bgImage: null // 纯渐变，无图片
            },
            'pink-white': {
                primary: '#e91e63',
                start: '#f48fb1',
                mid: '#f8bbd9',
                end: '#fce4ec',
                gradient: 'linear-gradient(135deg, #f48fb1 0%, #f8bbd9 50%, #fce4ec 100%)',
                bgLight: 'linear-gradient(135deg, #fce4ec 0%, #f8bbd9 50%, #f3e5f5 100%)',
                bgDark: 'linear-gradient(135deg, #1a1a2e 0%, #2d1f2f 50%, #3d2a3a 100%)',
                bgImage: null
            },

            // [v6.2.0] 梵高《星月夜》主题 - 普鲁士蓝/钴蓝/铬黄
            'the-starry-night': {
                primary: '#1565c0',
                start: '#0d1b2a',
                mid: '#1b3a5f',
                end: '#f4d35e',
                gradient: 'linear-gradient(135deg, #0d1b2a 0%, #1b3a5f 50%, #f4d35e 100%)',
                bgImage: 'themes/the-starry-night.png',
                label: '星月夜'
            },
            // [v6.2.0] 莫奈《撑阳伞的女人》主题 - 天蓝/草绿/暖黄
            'woman-with-a-parasol': {
                primary: '#4db6ac',
                start: '#64b5f6',
                mid: '#81c784',
                end: '#fff8e1',
                gradient: 'linear-gradient(135deg, #64b5f6 0%, #81c784 50%, #fff8e1 100%)',
                bgImage: 'themes/woman-with-a-parasol.png',
                label: '撑阳伞的女人'
            },
            // [v6.4.6] 梵高《杏花盛开》主题 - 青蓝天空/白色花朵
            'almond-blossoms': {
                primary: '#468499',
                start: '#3a6f7f',
                mid: '#5a9fb0',
                end: '#a8d5e2',
                gradient: 'linear-gradient(135deg, #3a6f7f 0%, #5a9fb0 50%, #a8d5e2 100%)',
                bgImage: 'themes/almond-blossoms.png',
                label: '杏花盛开'
            }
        };
        
        // [v6.0.0] 更新主题背景色
        function updateAccentBackground(isDark) {
            const accentName = localStorage.getItem('accentTheme') || 'blue-purple';
            const accent = accentThemes[accentName];
            if (accent) {
                const bgGradient = isDark ? accent.bgDark : accent.bgLight;
                document.documentElement.style.setProperty('--bg-gradient-themed', bgGradient);
            }
        }
        
        // [v6.2.0] 主题系统 - 使用开关控制夜间模式和跟随系统
        let systemThemeListener = null;
        function applyTheme(theme) {
            if (systemThemeListener) {
                window.matchMedia('(prefers-color-scheme: dark)').removeEventListener('change', systemThemeListener);
                systemThemeListener = null;
            }
            if (theme === 'system') {
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const themeValue = isDark ? 'dark' : 'light';
                document.documentElement.setAttribute('data-theme', themeValue);
                document.body.setAttribute('data-theme', themeValue);
                updateAccentBackground(isDark);
                systemThemeListener = e => {
                    const v = e.matches ? 'dark' : 'light';
                    document.documentElement.setAttribute('data-theme', v);
                    document.body.setAttribute('data-theme', v);
                    updateAccentBackground(e.matches);
                };
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', systemThemeListener);
            } else {
                document.documentElement.setAttribute('data-theme', theme);
                document.body.setAttribute('data-theme', theme);
                updateAccentBackground(theme === 'dark');
            }
            // [v6.2.0] 更新开关状态
            const darkModeSwitch = document.getElementById('darkModeSwitch');
            const systemModeSwitch = document.getElementById('systemModeSwitch');
            const darkModeSettingItem = document.getElementById('darkModeSettingItem');
            if (darkModeSwitch) {
                darkModeSwitch.checked = theme === 'dark';
                // [v6.3.1] 逻辑变更：跟随系统时隐藏夜间模式开关，不再只是禁用
                // darkModeSwitch.disabled = theme === 'system';
            }
            if (darkModeSettingItem) {
                if (theme === 'system') {
                    darkModeSettingItem.style.display = 'none';
                } else {
                    darkModeSettingItem.style.display = 'flex'; // setting-item 是 flex 布局
                }
            }
            if (systemModeSwitch) {
                systemModeSwitch.checked = theme === 'system';
            }
        }
        function setTheme(theme) { applyTheme(theme); localStorage.setItem('themePreference', theme); }
        
        // [v6.2.0] 新增开关控制函数
        function toggleDarkMode(enabled) {
            const systemModeSwitch = document.getElementById('systemModeSwitch');
            if (systemModeSwitch && systemModeSwitch.checked) {
                // 如果跟随系统开启，关闭它
                systemModeSwitch.checked = false;
                toggleSystemMode(false);
            }
            setTheme(enabled ? 'dark' : 'light');
        }
        
        function toggleSystemMode(enabled) {
            if (enabled) {
                setTheme('system');
            } else {
                // 关闭跟随系统时，根据当前系统主题设置为 light 或 dark
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                setTheme(isDark ? 'dark' : 'light');
            }
        }
        
        function setAccentTheme(accentName) {
            const accent = accentThemes[accentName];
            if (!accent) return;
            
            // [v6.2.0] 设置 body 的 data-accent 属性用于特殊主题样式
            document.body.setAttribute('data-accent', accentName);
            
            // 更新 CSS 变量
            const root = document.documentElement;
            root.style.setProperty('--color-primary', accent.primary);
            // [v6.1.0] 解析RGB值用于透明度调节
            const rgb = accent.primary.match(/^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            if (rgb) {
                const r = parseInt(rgb[1], 16);
                const g = parseInt(rgb[2], 16);
                const b = parseInt(rgb[3], 16);
                root.style.setProperty('--color-primary-rgb', `${r}, ${g}, ${b}`);
            }
            root.style.setProperty('--accent-gradient', accent.gradient);
            root.style.setProperty('--accent-start', accent.start);
            root.style.setProperty('--accent-mid', accent.mid);
            root.style.setProperty('--accent-end', accent.end);
            
            // [v6.2.0] 画作主题移除 bgLight/bgDark，仅更新纯渐变主题的背景
            if (accent.bgLight && accent.bgDark) {
                const isDark = document.body.getAttribute('data-theme') === 'dark';
                const bgGradient = isDark ? accent.bgDark : accent.bgLight;
                root.style.setProperty('--bg-gradient-themed', bgGradient);
            }
            
            // [v6.2.0] 如果是画作主题且没有自定义背景，自动应用画作背景
            const customBg = localStorage.getItem('customBackground');
            const currentBgMode = localStorage.getItem('bgStyle') || 'theme';
            if (accent.bgImage && currentBgMode === 'theme') {
                document.body.classList.add('bg-image');
                document.body.style.setProperty('--bg-image', `url("${accent.bgImage}")`);
            } else if (!accent.bgImage && currentBgMode === 'theme') {
                // 纯渐变主题，移除图片背景
                document.body.classList.remove('bg-image');
                document.body.style.removeProperty('--bg-image');
            }
            // 如果是自定义背景模式，保持自定义背景不变
            
            // 更新选择器按钮状态
            document.querySelectorAll('.accent-option').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.accent === accentName);
            });
            
            // 保存设置
            localStorage.setItem('accentTheme', accentName);
            
            // 刷新界面
            if (typeof updateBalanceCard === 'function') updateBalanceCard();
            if (typeof updateScreenTimeCard === 'function') updateScreenTimeCard();
        }
        
        function initAccentTheme() {
            const saved = localStorage.getItem('accentTheme') || 'blue-purple';
            setAccentTheme(saved);
        }
        
        // [v6.2.0] 背景设置 - 跟随主题或自定义
        function setBackground(bgMode) {
            const accentName = localStorage.getItem('accentTheme') || 'blue-purple';
            const accent = accentThemes[accentName];
            
            if (bgMode === 'theme') {
                // 跟随主题 - 使用主题色定义的背景（渐变或画作）
                const customBg = localStorage.getItem('customBackground');
                if (customBg) {
                    // 清除之前的自定义背景
                    localStorage.removeItem('customBackground');
                }
                
                if (accent && accent.bgImage) {
                    // 画作主题：使用画作背景
                    document.body.classList.add('bg-image');
                    document.body.style.setProperty('--bg-image', `url("${accent.bgImage}")`);
                } else {
                    // 渐变主题：使用渐变背景
                    document.body.classList.remove('bg-image');
                    document.body.style.removeProperty('--bg-image');
                }
                
                // 隐藏清除按钮
                const clearBtn = document.getElementById('bgClearBtn');
                if (clearBtn) clearBtn.classList.add('hidden');
            }
            // custom模式由handleCustomBgUpload处理
            
            // 更新选择器按钮状态
            document.querySelectorAll('.bg-option').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.bg === bgMode);
            });
            
            // 保存设置
            localStorage.setItem('bgStyle', bgMode);
        }
        
        // [v6.2.0] 自定义背景上传
        function handleCustomBgUpload(event) {
            const inputEl = event.target;
            const file = inputEl.files[0];
            if (!file) return;
            
            // 限制文件大小 (2MB)
            if (file.size > 2 * 1024 * 1024) {
                showNotification('❌ 图片过大', '请选择小于2MB的图片', 'error');
                inputEl.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const dataUrl = e.target.result;
                
                // 保存到 localStorage
                try {
                    localStorage.setItem('customBackground', dataUrl);
                    localStorage.setItem('bgStyle', 'custom');
                    
                    // 应用自定义背景
                    document.body.classList.add('bg-image');
                    document.body.style.setProperty('--bg-image', `url("${dataUrl}")`);
                    
                    // 更新UI
                    document.querySelectorAll('.bg-option').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.bg === 'custom');
                    });
                    
                    // 显示清除按钮
                    const clearBtn = document.getElementById('bgClearBtn');
                    if (clearBtn) clearBtn.classList.remove('hidden');
                    
                    showNotification('✅ 背景已设置', '自定义背景已应用', 'success');
                } catch (err) {
                    // localStorage 可能已满
                    console.error('[BG] 保存自定义背景失败:', err);
                    showNotification('❌ 保存失败', '存储空间不足，请选择更小的图片', 'error');
                }
                // 允许重复选择同一文件
                inputEl.value = '';
            };
            reader.readAsDataURL(file);
        }
        
        // [v6.2.0] 清除自定义背景
        function clearCustomBackground() {
            localStorage.removeItem('customBackground');
            setBackground('theme');
            showNotification('✅ 已清除', '已恢复主题默认背景', 'success');
        }
        
        function initBackground() {
            const savedMode = localStorage.getItem('bgStyle') || 'theme';
            const customBg = localStorage.getItem('customBackground');
            
            if (savedMode === 'custom' && customBg) {
                // 恢复自定义背景
                document.body.classList.add('bg-image');
                document.body.style.setProperty('--bg-image', `url("${customBg}")`);
                
                // 更新UI
                document.querySelectorAll('.bg-option').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.bg === 'custom');
                });
                
                // 显示清除按钮
                const clearBtn = document.getElementById('bgClearBtn');
                if (clearBtn) clearBtn.classList.remove('hidden');
            } else {
                setBackground('theme');
            }
        }
        
        function checkReminders() {
            const now = Date.now();
            let changed = false;
            tasks.forEach(task => {
                if (task.reminderDetails && task.reminderDetails.status === 'pending') {
                    const { mode, time, creationTimestamp, isRecurring } = task.reminderDetails;
                    let targetTime;
                    if (mode === 'absolute') {
                        const [datePart, timePart] = time.split('T');
                        const [year, month, day] = datePart.split('-').map(Number);
                        const [hours, minutes] = timePart.split(':').map(Number);
                        targetTime = new Date(year, month - 1, day, hours, minutes, 0, 0).getTime();
                    } else { // relative
                        targetTime = creationTimestamp + (time * 1000);
                    }

                    if (now >= targetTime) {
                        let shouldNotify = true;
                        
                        if (task.isHabit) {
                            const todayStr = getLocalDateString(new Date());
                            // [v3.18.0] Check if target is achieved this period, not just if completed today
                            // [v4.2.0] Use referenceDate (today)
                            const { currentCount, targetCount } = getHabitPeriodInfo(task, transactions, new Date());
                            if (currentCount >= targetCount) {
                                shouldNotify = false; // Don't notify, already achieved target this period
                            }
                        }
                        
                        if (shouldNotify) {
                            showNotification('🔔 任务提醒', `是时候开始/完成任务: "${task.name}" 了！`, 'reminder');
                        }
                        
                        if (isRecurring && task.isHabit && mode === 'absolute') {
                            const [datePart, timePart] = time.split('T');
                            const [year, month, day] = datePart.split('-').map(Number);
                            const [hours, minutes] = timePart.split(':').map(Number);
                            
                            let nextTime = new Date(year, month - 1, day, hours, minutes, 0, 0);
                            
                            const period = task.habitDetails.period;
                            const nowDateTime = new Date();
                            
                            do {
                                if (period === 'daily') {
                                    nextTime.setDate(nextTime.getDate() + 1);
                                } else if (period === 'weekly') {
                                    nextTime.setDate(nextTime.getDate() + 7);
                                } else if (period === 'monthly') {
                                    // [v3.17.3] Ensure month wrap-around logic is correct
                                    nextTime.setMonth(nextTime.getMonth() + 1);
                                    // Handle day overflow (e.g., trying to set Feb 30)
                                    if (nextTime.getDate() !== day) {
                                        nextTime.setDate(0); // Set to last day of previous month
                                    }
                                } else {
                                    nextTime.setDate(nextTime.getDate() + 1);
                                }
                            } while (nextTime <= nowDateTime); 
                            
                            const pad = (num) => String(num).padStart(2, '0');
                            const y = nextTime.getFullYear();
                            const m = pad(nextTime.getMonth() + 1);
                            const d = pad(nextTime.getDate());
                            const h = pad(hours); 
                            const min = pad(minutes); 
                            
                            task.reminderDetails.time = `${y}-${m}-${d}T${h}:${min}`;
                            
                        } else {
                            task.reminderDetails.status = 'triggered';
                        }
                        changed = true;
                    }
                }
            });
            if (changed) {
                saveData();
            }
        }
// --- [v4.0.0] Authentication Functions ---
        
        // [v6.6.0] CloudBase 版本: 更新 UI 状态
        function updateAuthUI(loginState) {
            const authFormContainer = document.getElementById('authFormContainer');
            const authStatusContainer = document.getElementById('authStatusContainer');
            const authStatus = document.getElementById('authStatus');
            const authError = document.getElementById('authError');
            if (authError) authError.textContent = '';

            if (loginState && loginState.user) {
                // Logged in
                const email = loginState.user.email;
                const uid = loginState.user.uid?.slice(0, 8) || 'user';
                const displayName = email || `用户 ${uid}`;
                authFormContainer.classList.add('hidden');
                authStatusContainer.classList.remove('hidden');
                authStatus.textContent = `已登录: ${displayName}`;
                authStatus.className = 'status-online';
            } else {
                // Logged out
                authFormContainer.classList.remove('hidden');
                authStatusContainer.classList.add('hidden');
                authStatus.textContent = '未连接';
                authStatus.className = 'status-offline';
            }
        }
        
        function showAuthError(message) {
            const authError = document.getElementById('authError');
            if (authError) {
                authError.textContent = message;
                authError.classList.add('show');
            }
        }
        
        function clearAuthError() {
            const authError = document.getElementById('authError');
            if (authError) {
                authError.textContent = '';
                authError.classList.remove('show');
            }
        }
        
        // [v6.6.0] 用户名密码登录 (v1 API)
        async function handleUsernameLogin() {
            const usernameInput = document.getElementById('authUsername');
            const passwordInput = document.getElementById('authPassword');
            const loginBtn = document.getElementById('usernameLoginBtn');
            
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            
            if (!username || username.length < 3) {
                showAuthError('用户名至少需要3个字符');
                return;
            }
            if (!password || password.length < 6) {
                showAuthError('密码至少需要6位');
                return;
            }
            
            // 确保 SDK 已初始化
            if (!cloudbaseInitialized || !auth) {
                if (!initCloudBase()) {
                    const errMsg = window.cloudbaseSDKError || 'SDK 未加载';
                    showAuthError(`云服务初始化失败: ${errMsg}。请检查网络后刷新页面。`);
                    console.error('[Auth] CloudBase not initialized. SDK loaded:', window.cloudbaseSDKLoaded);
                    return;
                }
            }
            
            clearAuthError();
            loginBtn.disabled = true;
            loginBtn.textContent = '登录中...';
            
            try {
                console.log('[Auth] Signing in with username:', username);
                
                // 使用 v2 API: auth.signIn({ username, password })
                const loginState = await auth.signIn({ username, password });
                
                console.log('[Auth] Login successful:', loginState);
                
                // 刷新登录状态
                await refreshLoginState();
                updateAuthUI(cachedLoginState);
                
                showNotification('✅ 登录成功', '正在同步云端数据...', 'achievement');
                
                // 加载数据
                const hasData = await DAL.init();
                if (hasData) {
                    await DAL.loadAll();
                    updateAllUI();
                } else {
                    showNotification('📦 欢迎使用', '您可以导入之前的备份数据，或开始全新体验', 'achievement');
                }
                
                // 清空密码
                passwordInput.value = '';
                
            } catch (error) {
                console.error('Username login error:', error);
                let errMsg = error.message || error.code || '登录失败';
                if (errMsg.includes('INVALID_PASSWORD') || errMsg.includes('PASSWORD')) {
                    errMsg = '密码错误';
                } else if (errMsg.includes('USER_NOT_FOUND') || errMsg.includes('NOT_FOUND') || errMsg.includes('not found')) {
                    errMsg = '用户不存在，请先注册';
                }
                showAuthError(`登录失败: ${errMsg}`);
            } finally {
                loginBtn.disabled = false;
                loginBtn.textContent = '登录';
            }
        }
        
        // [v6.6.0] 用户名密码注册 (v1 API)
        // 流程：先匿名登录，再绑定用户名和密码
        async function handleUsernameRegister() {
            const usernameInput = document.getElementById('authUsername');
            const passwordInput = document.getElementById('authPassword');
            const registerBtn = document.getElementById('usernameRegisterBtn');
            
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            
            // 验证用户名格式：字母开头，只能包含字母数字下划线
            if (!username || username.length < 3) {
                showAuthError('用户名至少需要3个字符');
                return;
            }
            if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(username)) {
                showAuthError('用户名必须字母开头，只能包含字母、数字和下划线');
                return;
            }
            if (!password || password.length < 6) {
                showAuthError('密码至少需要6位');
                return;
            }
            
            // 确保 SDK 已初始化
            if (!cloudbaseInitialized || !auth) {
                if (!initCloudBase()) {
                    const errMsg = window.cloudbaseSDKError || 'SDK 未加载';
                    showAuthError(`云服务初始化失败: ${errMsg}。请检查网络后刷新页面。`);
                    console.error('[Auth] CloudBase not initialized. SDK loaded:', window.cloudbaseSDKLoaded);
                    return;
                }
            }
            
            clearAuthError();
            registerBtn.disabled = true;
            registerBtn.textContent = '注册中...';
            
            try {
                console.log('[Auth] Registering with username:', username);
                
                // v2 API: 检查用户名是否已被占用
                const isRegistered = await auth.isUsernameRegistered(username);
                if (isRegistered) {
                    showAuthError('该用户名已被占用，请换一个');
                    return;
                }
                
                // v2 API: 使用 signUp 直接注册用户名和密码
                // signUp 成功后会自动登录
                const loginState = await auth.signUp({
                    username: username,
                    password: password,
                    name: username  // 用户昵称设为用户名
                });
                console.log('[Auth] User registered and logged in:', loginState);
                
                // 刷新登录状态
                await refreshLoginState();
                updateAuthUI(cachedLoginState);
                
                showNotification('✅ 注册成功', '您的账号已创建，数据将自动同步', 'achievement');
                
                // 检查是否有数据
                const hasData = await DAL.init();
                if (!hasData) {
                    // 创建空 Profile
                    await DAL.createEmptyProfile();
                }
                
                // 清空密码
                passwordInput.value = '';
                
            } catch (error) {
                console.error('Username register error:', error);
                console.error('Error details:', JSON.stringify(error, Object.getOwnPropertyNames(error)));
                let errMsg = error.message || error.code || '注册失败';
                if (errMsg.includes('USERNAME_EXISTS') || errMsg.includes('EXISTS') || errMsg.includes('exist') || errMsg.includes('registered')) {
                    errMsg = '该用户名已被占用，请换一个';
                } else if (errMsg.includes('INVALID_USERNAME') || errMsg.includes('username')) {
                    errMsg = '用户名格式无效';
                } else if (errMsg.includes('WEAK_PASSWORD') || errMsg.includes('password')) {
                    errMsg = '密码强度不够，请使用更复杂的密码';
                }
                showAuthError(`注册失败: ${errMsg}`);
            } finally {
                registerBtn.disabled = false;
                registerBtn.textContent = '注册';
            }
        }
        
        // [v6.6.0] 重置登录表单
        function resetLoginForm() {
            const usernameInput = document.getElementById('authUsername');
            const passwordInput = document.getElementById('authPassword');
            
            if (usernameInput) usernameInput.value = '';
            if (passwordInput) passwordInput.value = '';
            clearAuthError();
        }

        // [v6.6.0] 匿名登录 - 快速开始（免注册）
        async function handleAnonymousLogin() {
            const startBtn = document.getElementById('startSyncButton');
            
            startBtn.disabled = true;
            startBtn.textContent = '正在连接...';
            clearAuthError();
            
            // 确保 SDK 已初始化
            if (!cloudbaseInitialized || !auth) {
                // 再尝试一次初始化
                if (!initCloudBase()) {
                    const errMsg = window.cloudbaseSDKError || 'SDK 未加载';
                    showAuthError(`云服务初始化失败: ${errMsg}。请检查网络后刷新页面。`);
                    console.error('[Auth] CloudBase not initialized. SDK loaded:', window.cloudbaseSDKLoaded);
                    startBtn.disabled = false;
                    startBtn.textContent = '🚀 快速开始（免注册）';
                    return;
                }
            }
            
            try {
                console.log('[Auth] Starting anonymous login...');
                
                // 检查是否已有登录状态
                let loginState = auth.hasLoginState();
                
                if (!loginState) {
                    // v2 API: auth.signInAnonymously()
                    loginState = await auth.signInAnonymously();
                }
                
                // 刷新缓存
                cachedLoginState = loginState;
                console.log('[Auth] Login successful, UID:', loginState?.user?.uid);
                
                updateAuthUI(loginState);
                showNotification('🚀 快速开始成功', '数据将保存在当前浏览器', 'achievement');
                
                // 检查是否有数据
                const hasData = await DAL.init();
                if (hasData) {
                    await DAL.loadAll();
                    updateAllUI();
                } else {
                    showNotification('📦 欢迎使用', '您可以导入之前的备份数据，或开始全新体验', 'achievement');
                }
                
            } catch (error) {
                console.error('Anonymous Login Error:', error);
                showAuthError(`连接失败: ${error.message}`);
            } finally {
                startBtn.disabled = false;
                startBtn.textContent = '🚀 快速开始（免注册）';
            }
        }

        async function handleLogout() {
            if (!await showConfirm('退出登录将清除云端连接，切换到本地模式。您确定要退出吗？', '退出登录')) return;
            
            try {
                // 取消实时监听
                await DAL.unsubscribeAll();
                // CloudBase 登出
                await auth.signOut();
                // 清除缓存的登录状态
                cachedLoginState = null;
                
                updateAuthUI(null);
                
                // Reset app state to local defaults
                resetLocalData();
                await loadData(true); // Force reload from localStorage
                showNotification('➡️ 已退出', '已切换到本地模式。', 'achievement');
            } catch (error) {
                console.error('Logout Error:', error);
                showAlert('退出时发生错误: ' + error.message, '错误');
            }
        }
        
        // [v6.6.0] 显示导入数据提示
        function showImportPrompt() {
            showAlert(
                '请在设置页面点击「导入数据」按钮，选择您从旧版本导出的 JSON 备份文件。',
                '请导入数据'
            );
        }
        
        function setAuthLoading(isLoading) {
            document.getElementById('registerButton').disabled = isLoading;
            document.getElementById('loginButton').disabled = isLoading;
            document.getElementById('authError').textContent = isLoading ? '请稍候...' : '';
        }
        
        // --- Data Persistence (Save/Load/Import/Export) ---
        
        // [v5.8.1] 云端快照功能：自动备份数据到独立的快照表
        async function createCloudSnapshot(data, version) {
            const currentUser = AV.User.current();
            if (!currentUser) return;
            
            try {
                const Snapshot = AV.Object.extend('UserTimeBankSnapshot');
                const snapshot = new Snapshot();
                
                // 设置ACL：只有当前用户可读写
                const acl = new AV.ACL();
                acl.setReadAccess(currentUser, true);
                acl.setWriteAccess(currentUser, true);
                snapshot.setACL(acl);
                
                snapshot.set('owner', currentUser);
                snapshot.set('dataVersion', version);
                snapshot.set('data', data);
                snapshot.set('transactionCount', data.transactions?.length || 0);
                snapshot.set('taskCount', data.tasks?.length || 0);
                snapshot.set('balance', data.currentBalance || 0);
                
                await snapshot.save();
                console.log(`📸 云端快照创建成功: v${version}, ${data.transactions?.length || 0}条交易`);
                
                // 清理旧快照，只保留最近10个
                await cleanupOldSnapshots(currentUser);
            } catch (error) {
                console.warn('快照创建失败（非致命）:', error);
            }
        }
        
        // [v5.8.1] 清理旧快照，只保留最近10个
        async function cleanupOldSnapshots(user) {
            try {
                const query = new AV.Query('UserTimeBankSnapshot');
                query.equalTo('owner', user);
                query.descending('dataVersion');
                query.skip(10); // 跳过最新的10个
                
                const oldSnapshots = await query.find();
                if (oldSnapshots.length > 0) {
                    await AV.Object.destroyAll(oldSnapshots);
                    console.log(`🗑️ 清理了 ${oldSnapshots.length} 个旧快照`);
                }
            } catch (error) {
                console.warn('清理旧快照失败（非致命）:', error);
            }
        }
        
        // [v4.0.0] New Function: Migrate local data to cloud
        async function migrateLocalToCloud(localData) {
            const currentUser = AV.User.current();
            if (!currentUser) return;
            
            console.log("Attempting to migrate local data to cloud...");
            setAuthStatus('同步中...', 'status-syncing');
            
            const UserData = AV.Object.extend('UserTimeBankData');
            const dataObject = new UserData();
            
            // Set ACL for security: Only this user can read/write
            const acl = new AV.ACL();
            acl.setReadAccess(currentUser, true);
            acl.setWriteAccess(currentUser, true);
            dataObject.setACL(acl);
            
            // 填充设备元数据，确保云端有来源记录
            const deviceName = localStorage.getItem('tb_device_name') || '';
            localData.lastModifiedBy = localData.lastModifiedBy || clientId;
            localData.lastModifiedByName = localData.lastModifiedByName || deviceName;
            localData.lastModifiedAt = localData.lastModifiedAt || Date.now();

            // Set data and owner
            dataObject.set('data', localData);
            dataObject.set('owner', currentUser);
            dataObject.set('lastModifiedBy', localData.lastModifiedBy);
            if (localData.lastModifiedByName) dataObject.set('lastModifiedByName', localData.lastModifiedByName);
            dataObject.set('lastModifiedAt', new Date(localData.lastModifiedAt));

            try {
                await dataObject.save();
                console.log("Local data successfully migrated to cloud.");
                // After migration, immediately load from cloud to establish sync
                await loadData(true); 
            } catch (error) {
                console.error("Cloud migration failed:", error);
                setAuthStatus(`同步失败: ${error.message}`, 'status-error');
                showAuthError("自动上传本地数据失败，请稍后重试。");
            }
        }
        
        // [v4.0.0] New Function: Handle data conflict
        async function handleDataConflict(localData, cloudData) {
            const useLocal = await showConfirm("数据冲突！\n\n我们发现云端和本地均有数据。\n\n[确定] = 保留本地数据 (覆盖云端)\n[取消] = 保留云端数据 (覆盖本地)", '数据冲突');
            
            if (useLocal) {
                console.log("Conflict resolution: User chose LOCAL data.");
                setAuthStatus('同步中...', 'status-syncing');
                cloudDataObject.set('data', localData);
                cloudDataObject.set('lastModifiedBy', clientId);
                const deviceName = localStorage.getItem('tb_device_name') || '';
                if (deviceName) cloudDataObject.set('lastModifiedByName', deviceName);
                cloudDataObject.set('lastModifiedAt', new Date());
                
                // [v4.9.0 Fix] 强制覆盖后，必须更新本地锁基准
                try {
                    const savedObj = await cloudDataObject.save(null, { fetchWhenSave: true });
                    console.log("Cloud data overwritten with local data.");
                    
                    // 关键修复：拿到最新的云端时间戳
                    if (savedObj.updatedAt) {
                        lastCloudUpdateTime = savedObj.updatedAt.getTime();
                        console.log(`🔒 (ConflictResolved) 基准版本更新为: ${new Date(lastCloudUpdateTime).toLocaleTimeString()}`);
                    }
                    
                    setAuthStatus('已同步 ✅', 'status-online');
                    return localData;
                } catch (err) {
                    console.error("Failed to save local data to cloud:", err);
                    showAlert("保存本地数据失败，请检查网络！\n为防止丢失，系统将暂时保留本地数据。\n错误:" + err.message, '同步失败');
                    return localData;
                }
            } else {
                console.log("Conflict resolution: User chose CLOUD data.");
                // Just resolve with cloud data. Local data will be overwritten.
                return cloudData;
            }
        }
        
        // [v4.0.0] New Function: Set auth status message
        function setAuthStatus(message, className) {
            const authStatus = document.getElementById('authStatus');
            if (authStatus) {
                authStatus.textContent = message;
                authStatus.className = className;
            }
        }

        // [v6.2.1] 强制从云端同步数据（完全覆盖本地）
        // [v6.4.2] 增强：增加原子性保护锁，防止 LiveQuery/定时器干扰
        async function forceCloudSync() {
            // [v6.4.2] 设置原子性保护锁
            isSaving = true;
            
            try {
                showNotification('🔄 正在强制同步', '正在从云端加载最新数据...', 'reminder');
                
                // 重置所有同步锁，确保完全使用云端数据
                hasCompletedFirstCloudSync = false;
                lastCloudUpdateTime = 0;
                localDataVersion = 0;
                isRecoveringFromHibernate = true; // 阻止保存
                lastLocalActionTime = 0; // [v6.4.2] 重置操作时间，避免"近期活跃"逻辑干扰
                
                // 清除本地缓存
                try {
                    localStorage.removeItem('timeBankData');
                    localStorage.removeItem('timeBankData_backup');
                } catch(e) {}
                
                // [v6.4.2] 清空运行中任务，防止旧状态干扰
                runningTasks.clear();
                
                // 强制加载云端数据
                await loadData(true);
                
                showNotification('✅ 同步完成', '已成功加载云端最新数据', 'achievement');
                updateAllUI();
            } catch (error) {
                console.error('强制同步失败:', error);
                showNotification('❌ 同步失败', error.message, 'reminder');
            } finally {
                // [v6.4.2] 释放原子性保护锁
                isSaving = false;
                isRecoveringFromHibernate = false;
            }
        }
        
        // [v6.4.1] 强制将本地数据推送到云端（覆盖云端）
        async function forceLocalToCloud() {
            const currentUser = AV.User.current();
            if (!currentUser) {
                showNotification('❌ 未登录', '请先登录', 'reminder');
                return;
            }
            
            const confirmed = await showConfirm(
                '⚠️ 确定要用本地数据覆盖云端吗？\n\n这将完全覆盖云端数据，此操作不可撤销！',
                '强制推送确认'
            );
            if (!confirmed) return;
            
            try {
                showNotification('🔄 正在推送', '正在将本地数据上传到云端...', 'reminder');
                
                const appState = getAppState();
                appState.dataVersion = (localDataVersion || 0) + 1;
                appState.version = APP_VERSION;
                
                // 获取或创建云端对象
                const query = new AV.Query('UserTimeBankData');
                query.equalTo('owner', currentUser);
                const results = await query.find();
                
                let cloudObj;
                if (results.length > 0) {
                    cloudObj = results[0];
                } else {
                    cloudObj = new AV.Object('UserTimeBankData');
                    cloudObj.set('owner', currentUser);
                    const acl = new AV.ACL();
                    acl.setPublicReadAccess(false);
                    acl.setPublicWriteAccess(false);
                    acl.setReadAccess(currentUser, true);
                    acl.setWriteAccess(currentUser, true);
                    cloudObj.setACL(acl);
                }
                
                cloudObj.set('data', appState);
                cloudObj.set('lastModifiedBy', appState.lastModifiedBy);
                if (appState.lastModifiedByName) cloudObj.set('lastModifiedByName', appState.lastModifiedByName);
                cloudObj.set('lastModifiedAt', new Date(appState.lastModifiedAt));
                await cloudObj.save();
                
                // 更新本地同步状态
                cloudDataObject = cloudObj;
                localDataVersion = appState.dataVersion;
                lastCloudUpdateTime = cloudObj.updatedAt.getTime();
                
                showNotification('✅ 推送完成', '本地数据已成功覆盖云端', 'achievement');
            } catch (error) {
                console.error('推送失败:', error);
                showNotification('❌ 推送失败', error.message, 'reminder');
            }
        }

        // [v6.4.1] 多端冲突对话框 - 当检测到云端数据来自其他设备且本地有脏数据时显示
        // [v6.4.2] 增强：同时存储 cloudDataObject 引用，确保凭证同步
        // [v6.4.3] 重构：显示详细数据对比，帮助用户判断
        // [v6.4.6] 优化：设备名称显示、差异高亮、智能建议、防重复弹窗
        async function showMultiDeviceConflictDialog(cloudData, cloudModifiedBy, localClientId, cloudObj = null) {
            // [v6.4.6] 防止重复创建弹窗
            const existingOverlay = document.getElementById('conflict-dialog-overlay');
            if (existingOverlay) existingOverlay.remove();
            
            const isGlass = document.body.classList.contains('glass-mode');
            
            // [v6.4.6] 优先使用设备名称，没有时使用 clientId 缩写
            const cloudDeviceName = cloudData?.lastModifiedByName || (cloudObj ? cloudObj.get('lastModifiedByName') : null) || '';
            const localDeviceName = localStorage.getItem('tb_device_name') || '';
            const cloudDeviceDisplay = cloudDeviceName || (cloudModifiedBy ? cloudModifiedBy.substring(0, 8) + '...' : '未知设备');
            const localDeviceDisplay = localDeviceName || (localClientId ? localClientId.substring(0, 8) + '...' : '本机');
            
            const cloudModifiedAtRaw = cloudData?.lastModifiedAt || (cloudObj ? cloudObj.get('lastModifiedAt') : null) || (cloudObj ? cloudObj.updatedAt : null);
            const cloudModifiedAt = cloudModifiedAtRaw ? new Date(cloudModifiedAtRaw).toLocaleString('zh-CN') : '未知';
            
            // 本地数据统计
            const localRunningCount = runningTasks ? runningTasks.size : 0;
            const localTaskCount = tasks ? tasks.length : 0;
            const localTxCount = transactions ? transactions.length : 0;
            const localBalance = currentBalance || 0;
            const localVersion = localDataVersion || 0;
            
            // 云端数据统计
            const cloudRunningTasks = cloudData?.runningTasks || [];
            const cloudRunningCount = Array.isArray(cloudRunningTasks) ? cloudRunningTasks.length : 0;
            const cloudTaskCount = cloudData?.tasks?.length || 0;
            const cloudTxCount = cloudData?.transactions?.length || 0;
            const cloudBalance = cloudData?.currentBalance || 0;
            const cloudVersion = cloudData?.dataVersion || 0;
            
            // 获取本地运行中任务名称
            const localRunningNames = [];
            if (runningTasks) {
                runningTasks.forEach((data, taskId) => {
                    const task = tasks.find(t => t.id === taskId);
                    localRunningNames.push(task ? task.name : `ID:${taskId.substring(0,8)}`);
                });
            }
            
            // 获取云端运行中任务名称
            const cloudRunningNames = [];
            if (Array.isArray(cloudRunningTasks)) {
                cloudRunningTasks.forEach(item => {
                    const taskId = Array.isArray(item) ? item[0] : item;
                    const task = cloudData?.tasks?.find(t => t.id === taskId);
                    cloudRunningNames.push(task ? task.name : `ID:${String(taskId).substring(0,8)}`);
                });
            }
            
            // [v6.4.6] 计算差异并检测实质性差异
            const balanceDiff = localBalance - cloudBalance;
            const txDiff = localTxCount - cloudTxCount;
            const versionDiff = localVersion - cloudVersion;
            const runningDiff = localRunningCount - cloudRunningCount;
            
            // 检测各项是否有差异
            const hasBalanceDiff = Math.abs(balanceDiff) > 60; // 差异超过1分钟
            const hasTxDiff = txDiff !== 0;
            const hasRunningDiff = localRunningCount !== cloudRunningCount;
            const hasVersionDiff = versionDiff !== 0;
            
            // 无实质差异时不弹窗
            const hasRealDiff = hasBalanceDiff || hasTxDiff || hasRunningDiff;
            if (!hasRealDiff) {
                console.log('[Conflict] 数据无实质差异，跳过冲突弹窗');
                // 静默使用云端凭证更新
                if (cloudObj) {
                    cloudDataObject = cloudObj;
                    if (cloudObj.updatedAt) {
                        lastCloudUpdateTime = cloudObj.updatedAt.getTime();
                    }
                }
                if (cloudData?.dataVersion > localVersion) {
                    localDataVersion = cloudData.dataVersion;
                }
                return;
            }
            
            // [v6.4.6] 生成智能建议
            let suggestion = '';
            let suggestionIcon = '💡';
            if (localRunningCount > 0 && cloudRunningCount === 0) {
                suggestion = '本地有运行中任务，建议保留本地';
                suggestionIcon = '▶️';
            } else if (txDiff > 0) {
                suggestion = `本地有 ${txDiff} 条新交易，建议保留本地`;
                suggestionIcon = '📝';
            } else if (txDiff < 0) {
                suggestion = `云端有 ${-txDiff} 条新交易，建议使用云端`;
                suggestionIcon = '☁️';
            } else if (versionDiff < 0) {
                suggestion = '云端版本更新，建议使用云端';
                suggestionIcon = '🔄';
            } else if (versionDiff > 0) {
                suggestion = '本地版本更新，建议保留本地';
                suggestionIcon = '📱';
            } else if (hasBalanceDiff) {
                suggestion = balanceDiff > 0 ? '本地余额更多' : '云端余额更多';
                suggestionIcon = '💰';
            }
            
            // [v6.4.2] 存储云端数据和对象引用供后续使用
            window._pendingCloudData = cloudData;
            window._pendingCloudObject = cloudObj;
            
            const overlay = document.createElement('div');
            overlay.id = 'conflict-dialog-overlay';
            overlay.innerHTML = `
                <style>
                    #conflict-dialog-overlay {
                        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                        background: rgba(0,0,0,0.5);
                        backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
                        z-index: 10000;
                        display: flex; align-items: center; justify-content: center;
                        animation: conflictFadeIn 0.2s ease;
                    }
                    @keyframes conflictFadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes conflictSlideUp {
                        from { opacity: 0; transform: translateY(30px) scale(0.9); }
                        to { opacity: 1; transform: translateY(0) scale(1); }
                    }
                    .conflict-card {
                        background: ${isGlass ? 'rgba(25,25,30,0.92)' : 'var(--card-bg, #fff)'};
                        backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
                        border-radius: 20px;
                        width: 92%; max-width: 420px;
                        max-height: 85vh; overflow-y: auto;
                        box-shadow: 0 25px 80px rgba(0,0,0,0.4);
                        border: 1px solid ${isGlass ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)'};
                        animation: conflictSlideUp 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
                        color: ${isGlass ? 'rgba(255,255,255,0.95)' : 'var(--text-color, #333)'};
                        overflow: hidden;
                    }
                    .conflict-header {
                        padding: 20px 16px 12px;
                        text-align: center;
                        background: linear-gradient(135deg, rgba(255,149,0,0.15), rgba(255,100,0,0.1));
                    }
                    .conflict-header .icon { font-size: 36px; margin-bottom: 6px; }
                    .conflict-header h3 { 
                        margin: 0; font-size: 16px; font-weight: 600;
                        color: ${isGlass ? '#ffb347' : '#ff9500'};
                    }
                    .conflict-body { padding: 12px 16px; }
                    .conflict-compare {
                        display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
                        margin-bottom: 12px;
                    }
                    .conflict-side {
                        background: ${isGlass ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.03)'};
                        border-radius: 12px; padding: 10px;
                    }
                    .conflict-side-title {
                        font-size: 11px; font-weight: 600; text-transform: uppercase;
                        letter-spacing: 0.5px; margin-bottom: 6px;
                        display: flex; align-items: center; gap: 4px;
                    }
                    .conflict-side.cloud .conflict-side-title { color: #667eea; }
                    .conflict-side.local .conflict-side-title { color: #f5576c; }
                    .conflict-stat { font-size: 12px; line-height: 1.6; }
                    .conflict-stat .label { opacity: 0.6; }
                    .conflict-stat .value { font-weight: 500; }
                    .conflict-stat .diff-plus { color: #4CAF50; font-weight: 600; }
                    .conflict-stat .diff-minus { color: #f44336; font-weight: 600; }
                    .conflict-stat .highlight { background: rgba(255,149,0,0.2); padding: 1px 4px; border-radius: 4px; }
                    .conflict-running {
                        background: ${isGlass ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.04)'};
                        border-radius: 8px; padding: 8px; margin-top: 8px;
                        font-size: 11px;
                    }
                    .conflict-running-title { font-weight: 600; margin-bottom: 4px; }
                    .conflict-running-list { opacity: 0.8; word-break: break-all; }
                    .conflict-warning {
                        background: rgba(255,59,48,0.12);
                        border: 1px solid rgba(255,59,48,0.3);
                        border-radius: 10px; padding: 10px 12px;
                        color: ${isGlass ? '#ff6b6b' : '#ff3b30'};
                        font-size: 12px; font-weight: 500;
                        margin-bottom: 12px;
                    }
                    .conflict-actions { padding: 0 16px 16px; display: flex; flex-direction: column; gap: 8px; }
                    .conflict-btn {
                        width: 100%; padding: 12px 14px !important; border: none !important; border-radius: 12px !important;
                        font-size: 13px; font-weight: 500; cursor: pointer;
                        transition: transform 0.15s, opacity 0.15s;
                        display: flex; align-items: center; justify-content: center; gap: 8px;
                    }
                    .conflict-btn:active { transform: scale(0.97); opacity: 0.9; }
                    .conflict-btn-cloud {
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
                        color: white !important;
                    }
                    .conflict-btn-local {
                        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%) !important;
                        color: white !important;
                    }
                    .conflict-btn-later {
                        background: ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.06)'} !important;
                        color: ${isGlass ? 'rgba(255,255,255,0.7)' : 'var(--text-color)'} !important;
                    }
                    .conflict-suggestion {
                        background: ${isGlass ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.04)'};
                        border-radius: 10px; padding: 10px 12px;
                        margin-bottom: 12px;
                        font-size: 12px; font-weight: 500;
                        display: flex; align-items: center; gap: 8px;
                        color: ${isGlass ? '#a8e6cf' : '#4a9960'};
                    }
                    .conflict-suggestion .icon { font-size: 16px; }
                </style>
                
                <div class="conflict-card">
                    <div class="conflict-header">
                        <div class="icon">⚠️</div>
                        <h3>检测到多端数据冲突</h3>
                    </div>
                    
                    <div class="conflict-body">
                        <div class="conflict-compare">
                            <div class="conflict-side cloud">
                                <div class="conflict-side-title">☁️ 云端</div>
                                <div class="conflict-stat"><span class="label">设备:</span> <span class="value">${cloudDeviceDisplay}</span></div>
                                <div class="conflict-stat"><span class="label">版本:</span> <span class="value">v${cloudVersion}</span></div>
                                <div class="conflict-stat"><span class="label">任务:</span> <span class="value">${cloudTaskCount}个</span></div>
                                <div class="conflict-stat"><span class="label">交易:</span> <span class="value ${hasTxDiff ? 'highlight' : ''}">${cloudTxCount}条</span></div>
                                <div class="conflict-stat"><span class="label">余额:</span> <span class="value ${hasBalanceDiff ? 'highlight' : ''}">${formatTime(cloudBalance)}</span></div>
                                <div class="conflict-stat"><span class="label">运行中:</span> <span class="value ${hasRunningDiff ? 'highlight' : ''}">${cloudRunningCount}个</span></div>
                                ${cloudRunningCount > 0 ? `<div class="conflict-running"><div class="conflict-running-title">运行中任务:</div><div class="conflict-running-list">${cloudRunningNames.join('、') || '无'}</div></div>` : ''}
                            </div>
                            <div class="conflict-side local">
                                <div class="conflict-side-title">📱 本地</div>
                                <div class="conflict-stat"><span class="label">设备:</span> <span class="value">${localDeviceDisplay}</span></div>
                                <div class="conflict-stat"><span class="label">版本:</span> <span class="value">v${localVersion}</span> <span class="${versionDiff > 0 ? 'diff-plus' : versionDiff < 0 ? 'diff-minus' : ''}">${versionDiff > 0 ? '+' + versionDiff : versionDiff < 0 ? versionDiff : ''}</span></div>
                                <div class="conflict-stat"><span class="label">任务:</span> <span class="value">${localTaskCount}个</span></div>
                                <div class="conflict-stat"><span class="label">交易:</span> <span class="value ${hasTxDiff ? 'highlight' : ''}">${localTxCount}条</span> <span class="${txDiff > 0 ? 'diff-plus' : txDiff < 0 ? 'diff-minus' : ''}">${txDiff > 0 ? '+' + txDiff : txDiff < 0 ? txDiff : ''}</span></div>
                                <div class="conflict-stat"><span class="label">余额:</span> <span class="value ${hasBalanceDiff ? 'highlight' : ''}">${formatTime(localBalance)}</span></div>
                                <div class="conflict-stat"><span class="label">运行中:</span> <span class="value ${hasRunningDiff ? 'highlight' : ''}">${localRunningCount}个</span></div>
                                ${localRunningCount > 0 ? `<div class="conflict-running"><div class="conflict-running-title">运行中任务:</div><div class="conflict-running-list">${localRunningNames.join('、') || '无'}</div></div>` : ''}
                            </div>
                        </div>
                        
                        ${suggestion ? `<div class="conflict-suggestion"><span class="icon">${suggestionIcon}</span> ${suggestion}</div>` : ''}
                        
                        <div class="conflict-warning">
                            ⚠️ 云端数据来自 ${cloudDeviceDisplay} (${cloudModifiedAt})
                        </div>
                    </div>
                    
                    <div class="conflict-actions">
                        <button class="conflict-btn conflict-btn-cloud" onclick="resolveConflictUseCloud()">
                            <span>☁️</span> 使用云端数据
                        </button>
                        <button class="conflict-btn conflict-btn-local" onclick="resolveConflictUseLocal()">
                            <span>📱</span> 保留本地数据并推送
                        </button>
                        <button class="conflict-btn conflict-btn-later" onclick="resolveConflictLater()">
                            稍后处理（保持本地状态）
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        // [v6.4.1] 冲突解决：使用云端数据
        // [v6.4.2] 重构：完整同步所有凭证，防止本地旧状态回弹
        // [v6.4.6] 优化：确保弹窗一定会关闭
        async function resolveConflictUseCloud() {
            // [v6.4.6] 立即关闭弹窗，给用户即时反馈
            closeConflictDialog();
            
            const cloudData = window._pendingCloudData;
            const cloudObj = window._pendingCloudObject;
            
            // 清理待处理数据
            window._pendingCloudData = null;
            window._pendingCloudObject = null;
            
            if (cloudData) {
                // [v6.4.2] 关键：设置同步锁，阻止 LiveQuery 和定时器干扰
                isSaving = true;
                isRecoveringFromHibernate = true;
                
                try {
                    // [v6.4.2] 关键修复：在 applyDataState 之前重置标记，确保完全信任云端
                    // 这会让 applyDataState 走"首次加载"分支，完全使用云端的 runningTasks
                    hasCompletedFirstCloudSync = false;
                    
                    // [v6.4.2] 关键：清空本地运行中任务，防止被"近期活跃"逻辑恢复
                    runningTasks.clear();
                    lastLocalActionTime = 0; // 重置最后操作时间，避免触发"近期活跃"保护
                    
                    // 1. 应用云端数据到内存
                    applyDataState(cloudData);
                    
                    // 2. [v6.4.2] 关键：同步所有凭证
                    if (cloudObj) {
                        cloudDataObject = cloudObj;
                        if (cloudObj.updatedAt) {
                            lastCloudUpdateTime = cloudObj.updatedAt.getTime();
                        }
                    }
                    localDataVersion = cloudData.dataVersion || 0;
                    hasCompletedFirstCloudSync = true;
                    
                    // [v6.5.0] 同步版本号到 localStorage
                    try { localStorage.setItem('tb_local_data_version', String(localDataVersion)); } catch(e) {}
                    
                    console.log(`✅ [resolveConflictUseCloud] 凭证同步完成: v${localDataVersion}, lastUpdate=${new Date(lastCloudUpdateTime).toLocaleTimeString()}`);
                    
                    // 3. 更新 UI
                    updateAllUI();
                    showNotification('✅ 已同步', '已使用云端数据，本地任务已清除', 'achievement');
                    setAuthStatus('已同步 ✅', 'status-online');
                    
                } finally {
                    // 4. 释放锁
                    isSaving = false;
                    isRecoveringFromHibernate = false;
                }
            }
        }
        
        // [v6.4.1] 冲突解决：保留本地数据并推送
        async function resolveConflictUseLocal() {
            closeConflictDialog();
            window._pendingCloudData = null;
            window._pendingCloudObject = null;
            await forceLocalToCloud();
        }
        
        // [v6.4.1] 关闭冲突对话框
        function closeConflictDialog() {
            const overlay = document.getElementById('conflict-dialog-overlay');
            if (overlay) overlay.remove();
        }
        
        // [v6.4.3] 新增：稍后处理 - 保持本地状态不变，不进行任何同步
        function resolveConflictLater() {
            console.log('用户选择稍后处理，保持本地状态');
            
            // 关闭弹窗
            closeConflictDialog();
            
            // 清理待处理数据
            window._pendingCloudData = null;
            window._pendingCloudObject = null;
            
            // [v6.4.3] 关键：释放同步锁，允许本地操作继续
            // 但不更新凭证，这样下次同步时会再次检测到冲突
            hasCompletedFirstCloudSync = true; // 允许保存
            isSaving = false;
            isRecoveringFromHibernate = false;
            
            showNotification('ℹ️ 本地模式', '已保持本地数据，下次操作时会尝试同步', 'reminder');
        }

        // [v6.2.1] 云端同步诊断工具 [v6.4.1] 重构：直观对比视图 + 通透模式优化
        async function showCloudSyncDiagnostics() {
            const currentUser = AV.User.current();
            if (!currentUser) {
                showNotification('❌ 未登录', '请先登录以使用云端诊断功能', 'reminder');
                return;
            }

            try {
                // 1. 获取云端最新数据
                const query = new AV.Query('UserTimeBankData');
                query.equalTo('owner', currentUser);
                const results = await query.find();

                if (results.length === 0) {
                    showNotification('ℹ️ 无云端数据', '云端没有找到您的数据记录', 'reminder');
                    return;
                }

                const cloudObject = results[0];
                const cloudData = cloudObject.get('data');
                const cloudUpdatedAt = cloudObject.updatedAt;

                // 2. 构建对比数据
                const cloudRunningTasks = cloudData?.runningTasks || [];
                const cloudTasks = cloudData?.tasks || [];
                const cloudTransactions = cloudData?.transactions || [];
                const cloudBalance = cloudData?.currentBalance || 0;
                const cloudVersion = cloudData?.version || '未知';
                const cloudDataVersion = cloudData?.dataVersion || 0;
                const fallbackCloudId = cloudObject.id ? cloudObject.id.substring(0, 8) + '...' : '未知设备';
                const cloudModifiedBy = cloudData?.lastModifiedBy || cloudObject.get('lastModifiedBy') || '';
                const cloudModifiedAtRaw = cloudData?.lastModifiedAt || cloudObject.get('lastModifiedAt') || cloudUpdatedAt;
                const cloudModifiedAt = cloudModifiedAtRaw instanceof Date ? cloudModifiedAtRaw.getTime() : (cloudModifiedAtRaw || null);
                const cloudDeviceName = cloudData?.lastModifiedByName || cloudObject.get('lastModifiedByName') || ''; // [v6.4.1] 云端设备名称
                
                // 本地数据
                const localRunningCount = runningTasks ? runningTasks.size : 0;
                const localTaskCount = tasks ? tasks.length : 0;
                const localTransactionCount = transactions ? transactions.length : 0;
                const localClientId = localStorage.getItem('tb_client_id');
                const localDeviceName = localStorage.getItem('tb_device_name') || ''; // [v6.4.1] 本地设备名称
                
                // 检测差异
                const balanceDiff = cloudBalance !== currentBalance;
                const taskCountDiff = cloudTasks.length !== localTaskCount;
                const transactionCountDiff = cloudTransactions.length !== localTransactionCount;
                const runningTaskDiff = cloudRunningTasks.length !== localRunningCount;
                const versionDiff = cloudDataVersion !== localDataVersion;
                const hasDifference = balanceDiff || taskCountDiff || transactionCountDiff || runningTaskDiff || versionDiff;
                
                // 设备信息 [v6.4.1] 改进显示逻辑
                const cloudDeviceDisplay = cloudDeviceName || (cloudModifiedBy ? cloudModifiedBy.substring(0, 8) + '...' : fallbackCloudId);
                const localDeviceDisplay = localDeviceName || (localClientId ? localClientId.substring(0, 8) + '...' : '未知');
                // 只有当云端有记录且ID不同时才算不同设备
                const isSameDevice = cloudModifiedBy ? (cloudModifiedBy === localClientId) : false;
                const hasCloudDeviceInfo = !!(cloudModifiedBy || cloudDeviceName || fallbackCloudId);

                // 3. 构建直观对比HTML
                const isGlass = document.body.classList.contains('glass-mode');
                
                // 对比表格行生成器
                const compareRow = (label, cloudVal, localVal, isDiff, icon = '') => {
                    const diffClass = isDiff ? 'sync-diff' : '';
                    return `
                        <div class="sync-compare-row ${diffClass}">
                            <div class="sync-label">${icon} ${label}</div>
                            <div class="sync-cloud-val">${cloudVal}</div>
                            <div class="sync-local-val">${localVal}</div>
                        </div>
                    `;
                };
                
                const reportHTML = `
                    <style>
                        .sync-modal-overlay {
                            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                            background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.08), rgba(0,0,0,0.35)), rgba(0,0,0,0.35);
                            backdrop-filter: blur(18px); -webkit-backdrop-filter: blur(18px);
                            z-index: 10000;
                            display: flex; align-items: center; justify-content: center;
                            animation: syncFadeIn 0.2s ease;
                        }
                        @keyframes syncFadeIn {
                            from { opacity: 0; }
                            to { opacity: 1; }
                        }
                        @keyframes syncSlideUp {
                            from { opacity: 0; transform: translateY(20px) scale(0.95); }
                            to { opacity: 1; transform: translateY(0) scale(1); }
                        }
                        .sync-modal-card {
                            background: ${isGlass
                                ? 'linear-gradient(135deg, rgba(255,255,255,0.18) 0%, rgba(255,255,255,0.10) 100%)'
                                : 'var(--card-bg, #fff)'};
                            backdrop-filter: ${isGlass ? 'blur(26px) saturate(180%) contrast(92%)' : 'none'}; 
                            -webkit-backdrop-filter: ${isGlass ? 'blur(26px) saturate(180%) contrast(92%)' : 'none'};
                            border-radius: 20px;
                            width: 92%; max-width: 400px;
                            max-height: 85vh; overflow-y: auto;
                            box-shadow: ${isGlass ? '0 24px 70px rgba(0,0,0,0.45)' : '0 15px 40px rgba(0,0,0,0.1)'};
                            border: 1px solid ${isGlass ? 'rgba(255,255,255,0.14)' : 'rgba(0,0,0,0.05)'};
                            animation: syncSlideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
                            color: ${isGlass ? 'rgba(255,255,255,0.96)' : 'var(--text-color, #333)'};
                        }
                        .sync-modal-header {
                            padding: 20px 20px 16px;
                            text-align: center;
                            border-bottom: 1px solid ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)'};
                        }
                        .sync-modal-header h3 {
                            margin: 0 0 4px; font-size: 18px; font-weight: 600;
                        }
                        .sync-modal-header .sync-time {
                            font-size: 12px; opacity: 0.6;
                        }
                        .sync-status-badge {
                            display: inline-block; padding: 4px 12px; border-radius: 20px;
                            font-size: 12px; font-weight: 500; margin-top: 8px;
                        }
                        .sync-status-badge.ok {
                            background: rgba(52,199,89,0.2); color: #34c759;
                        }
                        .sync-status-badge.warn {
                            background: rgba(255,149,0,0.2); color: #ff9500;
                        }
                        .sync-compare-header {
                            display: grid; grid-template-columns: 1fr 1fr 1fr;
                            padding: 12px 16px; gap: 8px;
                            background: ${isGlass ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.02)'};
                            font-size: 11px; font-weight: 600; text-transform: uppercase;
                            letter-spacing: 0.5px; opacity: 0.7;
                        }
                        .sync-compare-header div:nth-child(2) { text-align: center; color: #667eea; }
                        .sync-compare-header div:nth-child(3) { text-align: center; color: #f5576c; }
                        .sync-compare-row {
                            display: grid; grid-template-columns: 1fr 1fr 1fr;
                            padding: 10px 16px; gap: 8px;
                            border-bottom: 1px solid ${isGlass ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.04)'};
                            font-size: 13px;
                        }
                        .sync-compare-row.sync-diff {
                            background: ${isGlass ? 'rgba(255,149,0,0.1)' : 'rgba(255,149,0,0.08)'};
                        }
                        .sync-compare-row.sync-diff .sync-cloud-val,
                        .sync-compare-row.sync-diff .sync-local-val {
                            font-weight: 600;
                        }
                        .sync-label { opacity: 0.8; }
                        .sync-cloud-val, .sync-local-val { text-align: center; font-weight: 500; }
                        .sync-device-info {
                            padding: 12px 16px; margin: 0;
                            background: ${isGlass ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.02)'};
                            font-size: 12px; 
                            line-height: 1.6;
                            border-top: 1px solid ${isGlass ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)'};
                        }
                        .sync-device-info a { color: ${isGlass ? 'rgba(255,255,255,0.7)' : 'var(--color-primary)'}; }
                        .sync-device-info .same-device { color: #34c759; font-weight: 500; }
                        .sync-device-info .diff-device { color: #ff9500; font-weight: 500; }
                        .sync-actions {
                            padding: 16px;
                            display: flex; flex-direction: column; gap: 8px;
                            background: ${isGlass ? 'rgba(255,255,255,0.04)' : 'transparent'};
                            border-top: 1px solid ${isGlass ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.04)'};
                        }
                        .sync-actions .btn-row { display: flex; gap: 8px; }
                        .sync-btn {
                            flex: 1; padding: 14px 16px !important; border: none !important; border-radius: 12px !important;
                            font-size: 14px; font-weight: 500; cursor: pointer;
                            transition: transform 0.15s, opacity 0.15s;
                        }
                        .sync-btn:active { transform: scale(0.97); opacity: 0.9; }
                        .sync-btn-cloud {
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
                            color: white !important;
                        }
                        .sync-btn-local {
                            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%) !important;
                            color: white !important;
                        }
                        .sync-btn-close {
                            background: ${isGlass ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.06)'} !important;
                            color: ${isGlass ? 'rgba(255,255,255,0.8)' : 'var(--text-color)'} !important;
                        }
                    </style>
                    
                    <div class="sync-modal-header">
                        <h3>🔍 云端同步诊断</h3>
                        <div class="sync-time">云端更新: ${cloudUpdatedAt.toLocaleString('zh-CN')}</div>
                        <div class="sync-status-badge ${hasDifference ? 'warn' : 'ok'}">
                            ${hasDifference ? '⚠️ 检测到差异' : '✅ 数据一致'}
                        </div>
                    </div>
                    
                    <div class="sync-compare-header">
                        <div>对比项</div>
                        <div>☁️ 云端</div>
                        <div>📱 本地</div>
                    </div>
                    
                    ${compareRow('时间余额', formatTime(cloudBalance), formatTime(currentBalance), balanceDiff, '💰')}
                    ${compareRow('任务数量', cloudTasks.length, localTaskCount, taskCountDiff, '📋')}
                    ${compareRow('交易记录', cloudTransactions.length, localTransactionCount, transactionCountDiff, '📊')}
                    ${compareRow('运行中任务', cloudRunningTasks.length, localRunningCount, runningTaskDiff, '⏱️')}
                    ${compareRow('数据版本', 'v' + cloudDataVersion, 'v' + localDataVersion, versionDiff, '🔢')}
                    ${compareRow('APP版本', cloudVersion, APP_VERSION, cloudVersion !== APP_VERSION, '📱')}
                    
                    <div class="sync-device-info">
                        📡 <b>云端:</b> ${hasCloudDeviceInfo 
                            ? `<span class="${isSameDevice ? 'same-device' : 'diff-device'}">${cloudDeviceDisplay}</span>${cloudModifiedAt ? ` · ${new Date(cloudModifiedAt).toLocaleString('zh-CN')}` : ''}${isSameDevice ? ' (本机)' : ' (其他设备)'}`
                            : '<span style="opacity:0.6">云端数据暂无设备记录</span>'
                        }<br>
                        🖥️ <b>本机:</b> ${localDeviceDisplay}
                        <a href="javascript:void(0)" onclick="promptDeviceName()" style="margin-left:8px;font-size:11px;opacity:0.7;text-decoration:underline;">${localDeviceName ? '修改名称' : '设置名称'}</a>
                    </div>
                    
                    <div class="sync-actions">
                        <div class="btn-row">
                            <button class="sync-btn sync-btn-cloud" onclick="forceCloudSync(); closeSyncDiagModal();">
                                ⬇️ 云端下载
                            </button>
                            <button class="sync-btn sync-btn-local" onclick="forceLocalToCloud(); closeSyncDiagModal();">
                                ⬆️ 本地上传
                            </button>
                        </div>
                        <button class="sync-btn sync-btn-close" onclick="closeSyncDiagModal();">
                            关闭
                        </button>
                    </div>
                `;

                // 创建弹窗
                const modal = document.createElement('div');
                modal.id = 'sync-diag-modal';
                modal.className = 'sync-modal-overlay';
                modal.innerHTML = `<div class="sync-modal-card">${reportHTML}</div>`;
                document.body.appendChild(modal);
                modal.addEventListener('click', (e) => { if (e.target === modal) closeSyncDiagModal(); });

            } catch (error) {
                console.error('诊断失败:', error);
                showNotification('❌ 诊断失败', error.message, 'reminder');
            }
        }
        
        // [v6.4.1] 关闭同步诊断弹窗
        function closeSyncDiagModal() {
            const modal = document.getElementById('sync-diag-modal');
            if (modal) modal.remove();
        }
        
        // [v6.4.1] 设备命名功能
        async function promptDeviceName() {
            const currentName = localStorage.getItem('tb_device_name') || '';
            const newName = await showPrompt('请为此设备设置一个名称，方便识别多端同步来源：', currentName, '设备名称');
            if (newName !== null && newName.trim()) {
                localStorage.setItem('tb_device_name', newName.trim());
                showNotification('✅ 已保存', `设备名称已设为: ${newName.trim()}`, 'achievement');
                // 重新打开诊断弹窗以刷新显示
                closeSyncDiagModal();
                setTimeout(() => showCloudSyncDiagnostics(), 100);
            }
        }
        function exportData() { 
            const migratedTransactions = transactions.map(t => { 
                if (t.type) return t; 
                const isEarn = t.amount > 0; 
                const task = tasks.find(tsk => tsk.id === t.taskId); 
                return { 
                    ...t, 
                    type: isEarn ? 'earn' : 'spend', 
                    amount: Math.abs(t.amount), 
                    taskName: t.taskName || (task ? task.name : '未知任务'),
                    isStreakAdvancement: t.isStreakAdvancement || false // Ensure flag exists on export
                }; 
            }); 
            
            // [v4.0.0] Use current in-memory state, not localStorage
            const d = { 
                version: APP_VERSION, 
                currentBalance, 
                tasks, 
                transactions: migratedTransactions, 
                categoryColors: [...categoryColors], 
                collapsedCategories: [...collapsedCategories], 
                dailyChanges, 
                notificationSettings, 
                reportState, 
                exportTime: new Date().toISOString() 
            }; 
            
            const jsonStr = JSON.stringify(d, null, 2);
            const fileName = `timebank_backup_${new Date().toISOString().split('T')[0]}.json`;
            
            // 检测 Android 环境，直接调用原生保存
            if (typeof Android !== 'undefined' && Android.saveFileDirectly) {
                Android.saveFileDirectly(jsonStr, fileName);
                showNotification('📁 数据已导出', '文件已保存到 Download 文件夹', 'achievement');
            } else {
                // Web 浏览器使用传统方式
                const b = new Blob([jsonStr], { type: 'application/json' }); 
                const a = document.createElement('a'); 
                a.href = URL.createObjectURL(b); 
                a.download = fileName; 
                a.click(); 
                URL.revokeObjectURL(a.href); 
                showNotification('📁 数据已导出', '所有历史数据已更新为最新格式。', 'achievement');
            }
        }
        
        function importData(event) {
            const f = event.target.files[0];
            if (!f) return;
            const r = new FileReader();
            r.onload = async function(e) {
                try {
                    let d = JSON.parse(e.target.result);
                    if (!d.version || !Array.isArray(d.tasks)) throw new Error('无效的数据格式');
                    
                    const loggedIn = isLoggedIn();
                    const confirmMsg = loggedIn 
                        ? '导入数据将覆盖当前云端和本地的所有数据，确定要继续吗？'
                        : '导入数据将覆盖当前本地所有数据，确定要继续吗？';
                        
                    if (!await showConfirm(confirmMsg, '导入数据')) return;
                    
                    d = repairAndMigrateData(d);
                    
                    // [v6.6.0] CloudBase: 如果已登录，导入到云端
                    if (loggedIn) {
                        try {
                            setAuthStatus('导入中...', 'status-syncing');
                            await DAL.importFromBackup(d);
                            await DAL.loadAll();
                            updateAllUI();
                            updateNotificationSettingsUI();
                            showNotification('📥 导入完成', '数据已成功导入到云端。', 'achievement');
                        } catch (cloudError) {
                            console.error('CloudBase import failed:', cloudError);
                            showAlert('云端导入失败: ' + cloudError.message, '错误');
                            setAuthStatus('导入失败', 'status-error');
                        }
                    } else {
                        // 未登录：保存到本地
                        applyDataState(d);
                        saveData();
                        updateAllUI();
                        updateNotificationSettingsUI();
                        showNotification('📥 导入完成', '数据已成功导入到本地。', 'achievement');
                    }
                    
                } catch (error) {
                    showAlert('导入失败：' + error.message, '错误');
                }
            };
            r.onerror = function() {
                showAlert('❌ 文件读取失败，请重试。', '错误');
            };
            r.readAsText(f);
            event.target.value = '';
        }

        // [v6.6.0] CloudBase 版本 - 清除所有数据
        async function clearAllData() {
            const loggedIn = isLoggedIn();
            let confirmMsg = loggedIn
                ? '您已登录，此操作将永久删除您的 *云端* 和 *本地* 所有数据！此操作无法撤销！'
                : '此操作将清空所有 *本地* 数据！此操作无法撤销！';

            if (!await showConfirm(confirmMsg, '清除数据')) return;

            confirmMsg = loggedIn
                ? '最后确认：这将删除您的云端账户数据，确定要继续吗？'
                : '最后确认：这将删除所有历史数据，确定要继续吗？';

            if (!await showConfirm(confirmMsg, '最后确认')) return;

            const removeTasksToo = await showConfirm('是否同时删除所有任务？选择"取消"则仅删除历史数据。', '删除任务');

            // 先取消实时监听
            await DAL.unsubscribeAll();
            
            // 清空本地内存状态
            hasCompletedFirstCloudSync = false;
            isSaving = false;
            isSyncing = false;
            transactions = [];
            dailyChanges = {};
            currentBalance = 0;
            runningTasks.clear();
            categoryColors = new Map();
            collapsedCategories = new Set();
            reportState = { 
                heatmapDate: new Date(),
                analysisPeriod: 'all',
                analysisView: 'category',
                trendPeriod: '30d',
                trendView: 'category',
                tablePeriod: 'all',
                tableView: 'category',
                tableSortKey: 'amount_abs_desc',
                tableVisibleRows: 10,
                insightView: 'chart',
                insightSubViewIndex: 0
            };
            if (removeTasksToo) {
                tasks = [];
            }
            updateAllUI();

            // Clear local storage
            localStorage.removeItem('timeBankData_backup'); 
            localStorage.removeItem('themePreference');
            localStorage.removeItem('timeBankData');
            localStorage.setItem('tb_has_visited', 'true');

            // [v6.6.0] CloudBase：清除云端数据
            if (loggedIn) {
                try {
                    setAuthStatus('清除中...', 'status-syncing');
                    await DAL.clearAllData();
                    await handleLogout();
                    showNotification('🗑️ 数据已清除', '云端和本地数据已清空。', 'achievement');
                } catch (e) {
                    console.error('Clear cloud data failed:', e);
                }
            } else {
                showNotification('🗑️ 数据已清除', '本地数据已清空。', 'achievement');
            }
            location.reload();
        }
        
        // [v4.8.8]// [v4.8.8] saveData 重构：引入乐观锁 (Optimistic Locking) 机制
        // [v6.0.0] 多表模式下不再使用此函数进行云端保存，各操作直接调用 DAL
        async function saveData() {
            // [v6.0.0] 多表模式：数据已在各操作中实时保存到对应表，这里只做配置同步
            if (USE_MULTI_TABLE && isLoggedIn() && DAL.profileObject) {
                try {
                    await DAL.saveProfile({
                        settings: notificationSettings,
                        reportState: reportState,
                        categoryColors: [...categoryColors],
                        collapsedCategories: [...collapsedCategories]
                    });
                    console.log('✅ [DAL] 配置已保存');
                } catch (e) {
                    console.error('[DAL] 配置保存失败:', e);
                }
                return;
            }
            
            // --- 旧架构：单 JSON 保存 ---
            const currentUser = AV.User.current();
            
            // 预先获取设备名称，避免重复读取
            const deviceName = localStorage.getItem('tb_device_name') || '';

            // 1. 准备当前数据快照
            const dataToSave = { 
                version: APP_VERSION,
                dataVersion: localDataVersion, // [v5.8.1] 数据版本号，用于严格同步控制
                currentBalance, 
                tasks, 
                transactions, 
                categoryColors: [...categoryColors], 
                collapsedCategories: [...collapsedCategories], 
                runningTasks: [...runningTasks], 
                dailyChanges, 
                notificationSettings, 
                reportState,
                lastModifiedBy: clientId, // [v6.4.2] 云端设备记录
                lastModifiedByName: deviceName,
                lastModifiedAt: Date.now()
            };
        // 2. 决策：云端保存 vs 本地保存
        if (currentUser && cloudDataObject) {
            // --- Cloud Save (With Optimistic Lock) ---
            
            // [安全检查 1] 启动锁
            if (!hasCompletedFirstCloudSync) {
                console.warn('🛑 拦截：初始同步未完成，阻止覆盖。');
                try { localStorage.setItem('timeBankData', JSON.stringify(dataToSave)); } catch(e){}
                return;
            }
            
            // [v5.13.0 安全检查 1.5] 休眠恢复保护
            if (isRecoveringFromHibernate) {
                console.warn('🛑 拦截：正在从休眠恢复，等待云端同步完成后再允许保存。');
                return;
            }
            
            // [v5.8.1 安全检查 2] 乐观锁基准必须存在
            if (lastCloudUpdateTime === 0) {
                console.error('🛑 拦截：乐观锁基准未初始化，可能是旧端数据，禁止保存！');
                setAuthStatus('同步异常，请刷新', 'status-error');
                showNotification('⚠️ 同步保护', '检测到同步状态异常，已阻止保存。请刷新页面重新加载数据。', 'reminder');
                return;
            }
            
            // [安全检查 3] 避免重复保存
            if (isSaving) {
                saveQueue = dataToSave; // 放入队列等待
                return;
            }
            isSaving = true;
            setAuthStatus('正在检查版本...', 'status-syncing');
            
            try {
                // === [v4.8.8 核心] 乐观锁检查 ===
                // 在真正写入之前，先去云端看一眼：数据有没有被别人（手机端）改过？
                const checkQuery = new AV.Query('UserTimeBankData');
                const remoteObject = await checkQuery.get(cloudDataObject.id);
                const remoteUpdatedAt = remoteObject.updatedAt.getTime();
                const remoteData = remoteObject.get('data');
                const remoteTransactionCount = remoteData?.transactions?.length || 0;
                const localTransactionCount = transactions.length;
                const remoteDataVersion = remoteData?.dataVersion || 0;
                
                // [v5.8.1] 严格版本号检查：本地版本必须等于云端版本
                if (localDataVersion !== remoteDataVersion) {
                    console.error(`🛑 版本号不匹配: 本地v${localDataVersion} ≠ 云端v${remoteDataVersion}`);
                    setAuthStatus('版本不同步，正在修复...', 'status-error');
                    showNotification('⚠️ 版本保护', `检测到本地数据版本(v${localDataVersion})与云端(v${remoteDataVersion})不一致，正在同步最新数据...`, 'reminder');
                    isSaving = false;
                    await loadData(true);
                    return;
                }
                
                // [v5.8.1] 空数据保护：禁止用空任务列表覆盖有数据的云端
                const remoteTaskCount = remoteData?.tasks?.length || 0;
                const localTaskCount = tasks.length;
                if (localTaskCount === 0 && remoteTaskCount > 0) {
                    console.error(`🛑 空数据保护: 本地任务为空，但云端有${remoteTaskCount}个任务`);
                    setAuthStatus('数据异常，正在修复...', 'status-error');
                    showNotification('⚠️ 空数据保护', `检测到本地任务列表为空但云端有数据，已阻止覆盖。正在加载云端最新数据...`, 'reminder');
                    isSaving = false;
                    await loadData(true);
                    return;
                }
                
                // 允许 2秒 的时间误差（防止自身刚保存完的网络延迟误判）
                if (remoteUpdatedAt > lastCloudUpdateTime + 2000) {
                    throw new Error("VERSION_CONFLICT"); // 抛出版本冲突错误
                }
                // === 检查通过，执行保存 ===
                setAuthStatus('正在保存...', 'status-syncing');
                
                // 如果有队列，优先保存队列中最新的
                const finalData = saveQueue || dataToSave;
                saveQueue = null;
                
                // [v5.8.1] 保存前版本号+1
                const newVersion = localDataVersion + 1;
                finalData.dataVersion = newVersion;
                finalData.lastModifiedBy = clientId; // [v6.4.2] 写入当前设备
                finalData.lastModifiedByName = deviceName;
                finalData.lastModifiedAt = Date.now();
                
                cloudDataObject.set('data', finalData);
                cloudDataObject.set('lastModifiedBy', clientId);
                if (deviceName) cloudDataObject.set('lastModifiedByName', deviceName);
                cloudDataObject.set('lastModifiedAt', new Date());
                const savedObject = await cloudDataObject.save();
                
                // 保存成功，更新本地版本号为最新
                localDataVersion = newVersion;
                lastCloudUpdateTime = savedObject.updatedAt.getTime();
                lastSaveTime = Date.now(); // [v6.4.3] 记录保存时间，启动差异检测静默期
                lastSuccessfulSaveTime = Date.now(); // [v6.4.3] 记录保存时间，启动 LiveQuery 静默期
                
                // [v6.5.0] 保存版本号到 localStorage，用于刷新后的冲突检测
                try { localStorage.setItem('tb_local_data_version', String(localDataVersion)); } catch(e) {}
                
                console.log(`✅ 保存成功，数据版本: v${localDataVersion}，时间: ${new Date(lastCloudUpdateTime).toLocaleTimeString()}`);
                setAuthStatus('已同步 ✅', 'status-online');
                
                // [v5.8.1] 每10个版本自动创建云端快照
                if (newVersion % 10 === 0) {
                    createCloudSnapshot(finalData, newVersion);
                }
                
            } catch (error) {
                if (error.message === "VERSION_CONFLICT") {
                    console.warn("🛑 版本冲突拦截！正在尝试智能合并...");
                    
                    // [v5.4.0] 1. 备份当前本地内存中未保存的"新"数据
                    // 必须同时备份 runningTasks，防止正在运行的任务丢失
                    const localTransactions = [...transactions];
                    const localTasks = [...tasks];
                    const localRunningTasks = new Map(runningTasks); // [v5.4.0] 备份运行状态
                    
                    showNotification('☁️ 数据同步冲突', '检测到云端更新，正在尝试合并本地新数据...', 'reminder');
                    
                    // 2. 拉取云端最新数据到内存 (此时 localTasks 被覆盖)
                    await loadData(true);
                    
                    // [v5.4.0] 3. 智能合并：只恢复"本地新增"的交易，不恢复"云端已删除"的交易
                    // 关键判断：如果交易时间晚于上次同步时间，说明是本地新增的
                    // 如果交易时间早于上次同步时间，说明是云端主动删除的（如撤回/取消）
                    const lastSyncTime = lastCloudUpdateTime || 0;
                    let recoveredCount = 0;
                    const cloudTransactionIds = new Set(transactions.map(t => t.id));
                    
                    localTransactions.forEach(localTx => {
                        if (!cloudTransactionIds.has(localTx.id)) {
                            const txTime = new Date(localTx.timestamp).getTime();
                            // 只有交易时间晚于上次同步时间，才认为是"本地新增"
                            // 否则说明这是之前就存在、但被云端删除的交易，不应恢复
                            if (txTime > lastSyncTime - 60000) { // 1分钟容差
                                console.log(`🔄 恢复本地新增交易: ${localTx.id} (${localTx.description})`);
                                transactions.unshift(localTx);
                                // [v5.4.0] 同步更新 currentBalance 和 dailyChanges
                                const amount = localTx.type === 'earn' ? localTx.amount : -localTx.amount;
                                currentBalance += amount;
                                const txDate = new Date(localTx.timestamp);
                                const dateStr = getLocalDateString(txDate);
                                if (!dailyChanges[dateStr]) dailyChanges[dateStr] = { earned: 0, spent: 0 };
                                if (localTx.type === 'earn') {
                                    dailyChanges[dateStr].earned = (dailyChanges[dateStr].earned || 0) + localTx.amount;
                                } else {
                                    dailyChanges[dateStr].spent = (dailyChanges[dateStr].spent || 0) + localTx.amount;
                                }
                                recoveredCount++;
                            } else {
                                console.log(`⏭️ 跳过已被云端删除的交易: ${localTx.id} (时间早于上次同步)`);
                            }
                        }
                    });
                    
                    // [v5.4.0] 4. 对任务也做类似处理：只恢复本地新建的任务
                    const cloudTaskIds = new Set(tasks.map(t => t.id));
                    localTasks.forEach(localTask => {
                        if (!cloudTaskIds.has(localTask.id)) {
                            // 任务没有明确的创建时间，使用 lastUsed 作为参考
                            // 如果 lastUsed 存在且晚于上次同步，认为是本地新建的
                            const taskTime = localTask.lastUsed || localTask.createdAt || 0;
                            if (taskTime > lastSyncTime - 60000) {
                                console.log(`🔄 恢复本地新增任务: ${localTask.name}`);
                                tasks.push(localTask);
                                recoveredCount++;
                            } else {
                                console.log(`⏭️ 跳过已被云端删除的任务: ${localTask.name}`);
                            }
                        }
                    });
                    
                    // [v6.0.0] 5. 智能合并 runningTasks：仅恢复冲突期间本地新开始的任务
                    // 关键修复：区分"本地新开始"和"被其他端结束"的任务
                    // 如果任务启动时间早于上次同步时间，说明其他端已知晓此任务
                    // 若云端已无此任务，则是其他端主动结束的，不应恢复
                    localRunningTasks.forEach((val, key) => {
                        if (!runningTasks.has(key)) {
                            // 检查对应的任务是否存在
                            if (tasks.some(t => t.id === key)) {
                                // 核心判断：任务启动时间是否晚于上次同步时间
                                const taskStartTime = val.startTime || 0;
                                const isNewlyStarted = taskStartTime > lastSyncTime - 5000; // 5秒容差
                                
                                if (isNewlyStarted) {
                                    console.log(`🔄 恢复本地新开始的任务: ${key} (启动于 ${new Date(taskStartTime).toLocaleTimeString()})`);
                                    runningTasks.set(key, val);
                                    recoveredCount++;
                                } else {
                                    console.log(`⏭️ 跳过被其他端结束的任务: ${key} (启动于 ${new Date(taskStartTime).toLocaleTimeString()}, 早于上次同步)`);
                                }
                            }
                        }
                    });
                    
                    // [v5.5.0 Fix] 5b. 移除本地已停止但云端还有的任务（用户刚结束/取消的任务）
                    // 这是核心修复：防止用户结束任务后，因版本冲突导致任务"复活"
                    const tasksToRemove = [];
                    runningTasks.forEach((val, key) => {
                        if (!localRunningTasks.has(key)) {
                            // 云端有这个运行任务，但本地没有 → 说明用户刚结束/取消了它
                            console.log(`🛑 移除已被用户停止的任务: ${key}`);
                            tasksToRemove.push(key);
                        }
                    });
                    tasksToRemove.forEach(key => runningTasks.delete(key));
                    
                    // [v5.5.0 Fix] 计算是否需要保存（包括移除的任务数）
                    const needsSave = recoveredCount > 0 || tasksToRemove.length > 0;
                    
                    if (needsSave) {
                        // 重新排序交易记录
                        transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        console.log(`✅ 智能合并完成: 恢复 ${recoveredCount} 条数据, 移除 ${tasksToRemove.length} 个已停止的任务`);
                        
                        // [v5.4.0] 立即更新 UI 显示恢复的数据
                        updateAllUI();
                        
                        // 6. 再次尝试保存合并后的数据 (递归调用，但这回基于最新版本，应该能过)
                        // 使用 setTimeout 防止调用栈溢出
                        setTimeout(() => saveData(), 500);
                    } else {
                        console.log("无需合并，直接使用云端数据。");
                    }
                    
                } else {
                    console.error("Cloud save error:", error);
                    setAuthStatus(`保存失败: ${error.message}`, 'status-error');
                }
            } finally {
                isSaving = false;
                // 如果队列里还有东西，稍后重试
                if (saveQueue) {
                    setTimeout(saveData, 1000);
                }
            }
        } else {
            // --- Local Save (不变) ---
            try { 
                localStorage.setItem('timeBankData_backup', localStorage.getItem('timeBankData') || ""); 
                localStorage.setItem('timeBankData', JSON.stringify(dataToSave)); 
                // [v5.10.0] 更新桌面小组件
                updateWidgets();
            } catch (error) { 
                console.error("Local save failed:", error); 
            }
        }
    }

        // [v4.12.0] 初始化示例数据 (The Demo Persona)
        // [v6.5.0] 增强版示例数据：任务翻倍、明亮颜色、多样化报告
        async function initDemoData() {
            console.log("Initializing Demo Data v6.5.0...");
            
            // 1. 定义基准时间
            const now = new Date();
            const todayStr = getLocalDateString(now);
            
            // 2. 预设任务 (20个) - 翻倍！
            const demoTasks = [
                // === 健康 (4个) ===
                { id: 'demo_1', name: '🏃 晨跑 5公里', category: '健康', type: 'reward', fixedTime: 2400, isHabit: true, habitDetails: { period: 'daily', targetCountInPeriod: 1, dailyLimit: 1, type: 'positive', streak: 0, rewards: [] } },
                { id: 'demo_2', name: '💧 喝水', category: '健康', type: 'reward', fixedTime: 120, isHabit: true, habitDetails: { period: 'daily', targetCountInPeriod: 8, dailyLimit: 8, type: 'positive', streak: 0, rewards: [] } },
                { id: 'demo_3', name: '🚴 骑行', category: '健康', type: 'continuous', multiplier: 1.0, isHabit: false },
                { id: 'demo_4', name: '😴 早睡(23点前)', category: '健康', type: 'reward', fixedTime: 1800, isHabit: true, habitDetails: { period: 'daily', targetCountInPeriod: 1, dailyLimit: 1, type: 'positive', streak: 0, rewards: [] } },
                
                // === 工作 (3个) ===
                { id: 'demo_5', name: '🍅 专注工作', category: '工作', type: 'continuous_target', multiplier: 1.0, targetTime: 1500, bonusReward: 300, isHabit: false },
                { id: 'demo_6', name: '📝 写周报', category: '工作', type: 'reward', fixedTime: 1200, isHabit: false },
                { id: 'demo_7', name: '💻 学习编程', category: '工作', type: 'continuous', multiplier: 1.2, isHabit: false },
                
                // === 自我提升 (4个) ===
                { id: 'demo_8', name: '📖 深度阅读', category: '自我提升', type: 'continuous', multiplier: 1.0, isHabit: false },
                { id: 'demo_9', name: '🧘 冥想', category: '自我提升', type: 'continuous_target', multiplier: 1.0, targetTime: 600, bonusReward: 0, isHabit: true, habitDetails: { period: 'weekly', targetCountInPeriod: 3, dailyLimit: 1, type: 'positive', streak: 0, rewards: [] } },
                { id: 'demo_10', name: '🎸 练吉他', category: '自我提升', type: 'continuous_target', multiplier: 1.0, targetTime: 1200, bonusReward: 300, isHabit: false },
                { id: 'demo_11', name: '🎨 绘画/手工', category: '自我提升', type: 'continuous', multiplier: 1.0, isHabit: false },
                
                // === 生活 (3个) ===
                { id: 'demo_12', name: '🧹 整理房间', category: '生活', type: 'continuous', multiplier: 1.2, isHabit: false },
                { id: 'demo_13', name: '🍳 做饭', category: '生活', type: 'continuous', multiplier: 1.0, isHabit: false },
                { id: 'demo_14', name: '🐕 遛狗', category: '生活', type: 'reward', fixedTime: 1200, isHabit: true, habitDetails: { period: 'daily', targetCountInPeriod: 2, dailyLimit: 2, type: 'positive', streak: 0, rewards: [] } },
                
                // === 娱乐 (4个) - 消费时间 ===
                { id: 'demo_15', name: '🎮 王者荣耀', category: '娱乐', type: 'continuous_redeem', multiplier: 1.0, isHabit: true, habitDetails: { period: 'daily', targetCountInPeriod: 60, dailyLimit: 1, type: 'abstinence', streak: 0, rewards: [{type: 'fixed', start: 3, value: 300}] } },
                { id: 'demo_16', name: '📱 刷短视频', category: '娱乐', type: 'continuous_redeem', multiplier: 1.0, isHabit: false },
                { id: 'demo_17', name: '🎬 看电影', category: '娱乐', type: 'continuous_redeem', multiplier: 0.8, isHabit: false },
                { id: 'demo_18', name: '🎵 听音乐放松', category: '娱乐', type: 'continuous_redeem', multiplier: 0.5, isHabit: false },
                
                // === 消费 (2个) - 即时消费 ===
                { id: 'demo_19', name: '🥤 喝奶茶', category: '消费', type: 'instant_redeem', consumeTime: 2400, isHabit: false },
                { id: 'demo_20', name: '🛌 赖床 10分钟', category: '消费', type: 'instant_redeem', consumeTime: 600, isHabit: false }
            ];

            // [v6.5.0] 更明亮的 Material Design 风格颜色
            categoryColors.set('健康', '#4CAF50');     // 明亮绿
            categoryColors.set('工作', '#2196F3');     // 明亮蓝
            categoryColors.set('自我提升', '#9C27B0'); // 明亮紫
            categoryColors.set('生活', '#FF9800');     // 明亮橙
            categoryColors.set('娱乐', '#E91E63');     // 明亮粉
            categoryColors.set('消费', '#F44336');     // 明亮红

            tasks = demoTasks.map(t => ({ ...t, completionCount: 0, lastUsed: 0 }));

            // 3. 生成历史记录 ("时间旅行")
            transactions = [];
            currentBalance = 0;
            dailyChanges = {};

            const addDemoTx = (task, amount, date, type, descSuffix = '') => {
                const isEarn = type === 'earn';
                const finalAmount = Math.floor(amount);
                
                if (isEarn) {
                    currentBalance += finalAmount;
                    updateDailyChanges('earned', finalAmount, date);
                } else {
                    currentBalance -= finalAmount;
                    updateDailyChanges('spent', finalAmount, date);
                }
                
                task.completionCount = (task.completionCount || 0) + 1;
                task.lastUsed = date.getTime();

                transactions.push({
                    id: 'tx_' + Date.now() + Math.random(),
                    taskId: task.id,
                    taskName: task.name,
                    type: type,
                    amount: finalAmount,
                    description: (isEarn ? '完成任务: ' : '兑换项目: ') + task.name + descSuffix,
                    timestamp: date.toISOString(),
                    isStreakAdvancement: false
                });
            };

            // 获取任务引用
            const runTask = tasks.find(t => t.id === 'demo_1');
            const waterTask = tasks.find(t => t.id === 'demo_2');
            const bikeTask = tasks.find(t => t.id === 'demo_3');
            const sleepTask = tasks.find(t => t.id === 'demo_4');
            const workTask = tasks.find(t => t.id === 'demo_5');
            const reportTask = tasks.find(t => t.id === 'demo_6');
            const codeTask = tasks.find(t => t.id === 'demo_7');
            const readTask = tasks.find(t => t.id === 'demo_8');
            const meditateTask = tasks.find(t => t.id === 'demo_9');
            const guitarTask = tasks.find(t => t.id === 'demo_10');
            const artTask = tasks.find(t => t.id === 'demo_11');
            const cleanTask = tasks.find(t => t.id === 'demo_12');
            const cookTask = tasks.find(t => t.id === 'demo_13');
            const dogTask = tasks.find(t => t.id === 'demo_14');
            const gameTask = tasks.find(t => t.id === 'demo_15');
            const videoTask = tasks.find(t => t.id === 'demo_16');
            const movieTask = tasks.find(t => t.id === 'demo_17');
            const musicTask = tasks.find(t => t.id === 'demo_18');
            const teaTask = tasks.find(t => t.id === 'demo_19');
            const lazyTask = tasks.find(t => t.id === 'demo_20');

            // [v6.5.0] 多样化的31天历史数据生成
            // 设计原则：各分类均衡分布，避免单一任务主导
            for (let i = 31; i >= 1; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                date.setHours(7 + (i % 5), 10 * (i % 6));
                
                const isWeekend = date.getDay() === 0 || date.getDay() === 6;
                const dayOfWeek = date.getDay();

                // === 健康分类 (每天都有活动) ===
                // 晨跑：工作日
                if (!isWeekend && i % 2 === 0) {
                    addDemoTx(runTask, 2400, date, 'earn');
                }
                // 骑行：周末或隔天
                if (isWeekend || i % 3 === 0) {
                    const bikeDate = new Date(date); bikeDate.setHours(16, 30);
                    addDemoTx(bikeTask, 1800 + (i % 4) * 300, bikeDate, 'earn');
                }
                // 喝水：每天3-5杯
                const cups = 3 + (i % 3);
                for (let j = 0; j < cups; j++) {
                    const waterDate = new Date(date);
                    waterDate.setHours(8 + j * 3, 15 * j);
                    addDemoTx(waterTask, 120, waterDate, 'earn');
                }
                // 早睡：大部分天
                if (i % 4 !== 0) {
                    const sleepDate = new Date(date); sleepDate.setHours(22, 45);
                    addDemoTx(sleepTask, 1800, sleepDate, 'earn');
                }

                // === 工作分类 (工作日为主) ===
                if (!isWeekend) {
                    // 专注工作：工作日
                    if (i % 2 === 0) {
                        addDemoTx(workTask, 1500 + (i % 3) * 300, date, 'earn');
                    }
                    // 学编程：部分工作日
                    if (i % 3 === 0) {
                        const codeDate = new Date(date); codeDate.setHours(20, 0);
                        addDemoTx(codeTask, 2400 + (i % 2) * 600, codeDate, 'earn');
                    }
                }
                // 写周报：每周五
                if (dayOfWeek === 5) {
                    const reportDate = new Date(date); reportDate.setHours(17, 0);
                    addDemoTx(reportTask, 1200, reportDate, 'earn');
                }

                // === 自我提升分类 ===
                // 阅读：隔天
                if (i % 2 === 1) {
                    const readDate = new Date(date); readDate.setHours(21, 30);
                    addDemoTx(readTask, 1200 + (i % 3) * 300, readDate, 'earn');
                }
                // 冥想：每3天
                if (i % 3 === 0) {
                    const medDate = new Date(date); medDate.setHours(6, 30);
                    addDemoTx(meditateTask, 600, medDate, 'earn');
                }
                // 练吉他：周末
                if (isWeekend) {
                    const guitarDate = new Date(date); guitarDate.setHours(15, 0);
                    addDemoTx(guitarTask, 1500 + (i % 2) * 300, guitarDate, 'earn');
                }
                // 绘画：每5天
                if (i % 5 === 0) {
                    const artDate = new Date(date); artDate.setHours(14, 0);
                    addDemoTx(artTask, 2400, artDate, 'earn');
                }

                // === 生活分类 ===
                // 做饭：大部分天
                if (i % 2 === 0) {
                    const cookDate = new Date(date); cookDate.setHours(18, 30);
                    addDemoTx(cookTask, 1800 + (i % 3) * 300, cookDate, 'earn');
                }
                // 遛狗：每天1-2次
                const dogWalks = 1 + (i % 2);
                for (let w = 0; w < dogWalks; w++) {
                    const dogDate = new Date(date);
                    dogDate.setHours(w === 0 ? 7 : 19, 0);
                    addDemoTx(dogTask, 1200, dogDate, 'earn');
                }
                // 整理房间：每4天
                if (i % 4 === 0) {
                    const cleanDate = new Date(date); cleanDate.setHours(10, 0);
                    addDemoTx(cleanTask, 1800 + (i % 2) * 600, cleanDate, 'earn');
                }

                // === 娱乐消费 (自然分布) ===
                // 游戏：隔天，主要晚上
                if (i % 2 === 1) {
                    const gameDate = new Date(date); gameDate.setHours(21, 0);
                    addDemoTx(gameTask, 1800 + (i % 3) * 600, gameDate, 'spend');
                }
                // 短视频：大部分天，碎片时间
                if (i % 3 !== 0) {
                    const vidDate = new Date(date); vidDate.setHours(12, 30);
                    addDemoTx(videoTask, 900 + (i % 4) * 300, vidDate, 'spend');
                }
                // 看电影：周末
                if (isWeekend && i % 4 === 0) {
                    const movieDate = new Date(date); movieDate.setHours(20, 0);
                    addDemoTx(movieTask, 6000, movieDate, 'spend'); // 约100分钟
                }
                // 听音乐：每3天
                if (i % 3 === 0) {
                    const musicDate = new Date(date); musicDate.setHours(17, 0);
                    addDemoTx(musicTask, 1800, musicDate, 'spend');
                }

                // === 即时消费 ===
                // 奶茶：每4天
                if (i % 4 === 0) {
                    const teaDate = new Date(date); teaDate.setHours(15, 0);
                    addDemoTx(teaTask, 2400, teaDate, 'spend');
                }
                // 赖床：周末
                if (isWeekend) {
                    const lazyDate = new Date(date); lazyDate.setHours(9, 0);
                    addDemoTx(lazyTask, 600, lazyDate, 'spend');
                }
            }

            // 4. 今天的数据：留空间给用户操作
            addDemoTx(waterTask, 120, new Date(), 'earn');
            const dogNow = new Date(); dogNow.setHours(7, 30);
            addDemoTx(dogTask, 1200, dogNow, 'earn');

            // 5. 余额微调：目标约2小时(7200秒)
            const TARGET_BALANCE = 7200;
            const diff = TARGET_BALANCE - currentBalance;
            if (Math.abs(diff) > 300) {
                const adjustDate = new Date(now);
                adjustDate.setDate(adjustDate.getDate() - 1);
                adjustDate.setHours(20, 0);
                if (diff > 0) {
                    // 用多种任务补充，避免单一任务主导
                    const earnTasks = [readTask, cookTask, bikeTask, artTask];
                    const pickTask = earnTasks[Math.floor(Math.random() * earnTasks.length)];
                    addDemoTx(pickTask, Math.min(diff, 3600), adjustDate, 'earn');
                } else {
                    const spendTasks = [videoTask, musicTask, movieTask];
                    const pickTask = spendTasks[Math.floor(Math.random() * spendTasks.length)];
                    addDemoTx(pickTask, Math.min(Math.abs(diff), 3600), adjustDate, 'spend');
                }
            }

            // 6. 修正习惯连续天数
            tasks.filter(t => t.isHabit).forEach(t => rebuildHabitStreak(t));

            // 7. 排序记录
            transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            // 8. 标记已访问
            localStorage.setItem('tb_has_visited', 'true');
            
            // 9. 保存并刷新
            await saveData();
            updateAllUI();
            
            // 10. 欢迎通知
            setTimeout(() => {
                showNotification('👋 欢迎来到 Time Bank', '已为您加载示例数据，助您快速上手！', 'achievement');
            }, 1000);
        }

        // [v4.5.3] FIX: Added updateNotificationSettingsUI() after load
        async function loadData(forceReload = false) {
            const currentUser = AV.User.current();
            
            if (currentUser) {
                // --- Cloud Load ---
                setAuthStatus('连接中...', 'status-syncing');
                
                // [v5.8.1] 立即清除本地缓存，防止旧数据在网络故障时复活
                // 这是防止灾难性数据丢失的关键步骤
                try {
                    const localBackup = localStorage.getItem('timeBankData');
                    if (localBackup) {
                        console.log('🗑️ [v5.8.1] 清除本地缓存，防止旧数据复活');
                        localStorage.removeItem('timeBankData');
                        localStorage.removeItem('timeBankData_backup');
                    }
                } catch(e) { console.warn('清除缓存失败', e); }
                
                if (liveQuery && forceReload) {
                    await liveQuery.unsubscribe();
                    liveQuery = null;
                }
                
                const query = new AV.Query('UserTimeBankData');
                query.equalTo('owner', currentUser);
                
                let results;
                // [v5.8.1] 不再使用本地数据作为fallback，登录用户必须使用云端数据
                let localData = null; // 移除: getLocalData()

                // STEP 1: Try to FETCH data
                try {
                    // [v4.3.8] FIX: Removed the cache-busting line
                    // query.notEqualTo('force_refresh', Date.now()); 
                    
                    results = await query.find();
                    
                    if (results.length > 0) {
                        // 1. Cloud data EXISTS
                        cloudDataObject = results[0];
                        let cloudData = cloudDataObject.get('data');
                        
                        // [v6.4.1] 多端冲突检测：仅在有实质性冲突时提醒用户
                        const cloudModifiedBy = cloudData?.lastModifiedBy || cloudDataObject.get('lastModifiedBy') || '';
                        const localClientId = localStorage.getItem('tb_client_id');
                        const hasRunningTasks = runningTasks && runningTasks.size > 0;
                        
                        // [v6.5.0] 增强冲突检测条件：
                        // 条件1: 云端数据来自不同设备 (cloudModifiedBy 存在且与本地不同)
                        // 条件2: 本地有正在运行的任务（脏数据） OR 本地有未同步的交易/版本差异
                        const isFromDifferentDevice = cloudModifiedBy && localClientId && cloudModifiedBy !== localClientId;
                        
                        // [v6.5.0] 新增：检测本地是否有未同步数据（基于版本号和交易数量）
                        const localCachedVersion = parseInt(localStorage.getItem('tb_local_data_version') || '0');
                        const cloudVersion = cloudData?.dataVersion || 0;
                        const localCachedData = getLocalData();
                        const localTxCount = localCachedData?.transactions?.length || 0;
                        const cloudTxCount = cloudData?.transactions?.length || 0;
                        
                        // 如果本地有缓存数据且与云端有显著差异，也需要提醒
                        const hasSignificantDiff = localCachedData && (
                            (localCachedVersion > 0 && localCachedVersion !== cloudVersion) || // 版本号不一致
                            (Math.abs(localTxCount - cloudTxCount) > 0 && localTxCount > 0) // 交易数量不一致且本地有数据
                        );
                        
                        // [v6.5.0] 扩展冲突条件：有运行任务 OR 有显著数据差异
                        const shouldShowConflict = isFromDifferentDevice && (hasRunningTasks || hasSignificantDiff);
                        
                        if (shouldShowConflict) {
                            const diffReason = hasRunningTasks 
                                ? `本地有${runningTasks.size}个运行中任务` 
                                : `本地版本v${localCachedVersion}/${localTxCount}条 vs 云端v${cloudVersion}/${cloudTxCount}条`;
                            console.warn(`⚠️ 检测到多端冲突: 云端来自设备 ${cloudModifiedBy.substring(0,8)}..., 本地设备 ${localClientId.substring(0,8)}..., ${diffReason}`);
                            // [v6.4.2] 显示冲突诊断对话框，同时传递 cloudDataObject 引用
                            showMultiDeviceConflictDialog(cloudData, cloudModifiedBy, localClientId, cloudDataObject);
                            return; // 暂停加载，等待用户决策
                        }
                        
                        // [v5.8.1] 简化逻辑：登录用户始终使用云端数据，不再处理本地冲突
                        applyDataState(cloudData);
                        
                        // [v4.8.8] 更新乐观锁版本号
                        if (cloudDataObject.updatedAt) {
                            lastCloudUpdateTime = cloudDataObject.updatedAt.getTime();
                            console.log(`🔒 锁定云端版本: ${new Date(lastCloudUpdateTime).toLocaleTimeString()}`);
                        }
                        
                        // [v5.8.1] 同步数据版本号
                        localDataVersion = cloudData?.dataVersion || 0;
                        console.log(`📌 同步数据版本号: v${localDataVersion}`);
                    } else {
                        // 2. No cloud data - New user
                        // NEW USER: 仅加载默认空数据并推送到云端
                        applyDataState(null); // Load defaults
                        localDataVersion = 0; // [v5.8.1] 新用户版本从0开始
                        await migrateLocalToCloud(getAppState()); // Save defaults to cloud
                    }
                } catch (fetchError) {
                    // [v5.8.1] FATAL: 网络故障时不再使用本地缓存，保持空状态并提示用户
                    console.error("Cloud load error (Fetch Failed):", fetchError);
                    setAuthStatus(`加载失败: ${fetchError.message}`, 'status-error');
                    
                    // 不再 fallback 到本地数据！这是灾难的根源
                    // applyDataState(localData); // 移除这行
                    
                    // 清除云端引用，阻止任何保存操作
                    cloudDataObject = null;
                    lastCloudUpdateTime = 0;
                    localDataVersion = 0; // [v5.8.1] 重置版本号
                    hasCompletedFirstCloudSync = false; // 关键：不释放启动锁
                    
                    // 显示明确的错误提示
                    showNotification('❌ 网络连接失败', '无法加载云端数据，请检查网络后刷新页面。为保护数据安全，已禁止保存。', 'reminder');
                    
                    // Final step (for error state)
                    const theme = localStorage.getItem('themePreference') || 'system'; 
                    setTheme(theme);
                    updateAllUI();
                    updateNotificationSettingsUI(); // [v4.5.3] FIX
                    return; // Exit function
                }

                // STEP 2: Try to SUBSCRIBE (Data fetch was successful)
                try {
                    await subscribeToLiveQuery(query);
                    setAuthStatus('已同步 ✅', 'status-online');
                    
                    // [v5.9.0] Phase 5: 订阅事件表 LiveQuery（仅在事件驱动模式）
                    if (USE_EVENT_SOURCING) {
                        subscribeToEventLiveQuery();
                    }
                } catch (subscribeError) {
                    // NON-FATAL: Data is loaded, but sync failed.
                    console.warn("LiveQuery subscription failed:", subscribeError);
                    setAuthStatus('已加载 (同步异常)', 'status-warning');
                }
                
                // [v5.9.0] 异步检查事件日志，决定是否显示 ES 诊断工具
                checkAndShowESTools();
                
                // [v5.9.0] Phase 5: 上传离线事件队列（如果有）
                if (USE_EVENT_SOURCING) {
                    flushOfflineEventQueue();
                }

            } else {
                // --- Local Load ---
                applyDataState(getLocalData());
            }
            
            // [v4.8.7] 标记云端同步已完成，允许后续的保存操作
            hasCompletedFirstCloudSync = true;
            // [v6.0.0] 重置休眠恢复标记
            if (isRecoveringFromHibernate) {
                console.log("✅ 休眠恢复同步完成，解除保护锁定。");
                isRecoveringFromHibernate = false;
            }
            console.log("✅ 初始云端同步完成，解除写入锁定。");

            // Final step: Apply theme and update UI
            const theme = localStorage.getItem('themePreference') || 'system'; 
            setTheme(theme);
            maybeCleanupDemoDataOnFirstUse();
            updateAllUI(); // First render
            updateNotificationSettingsUI(); // [v4.5.3] FIX
        }
        
        // [v4.3.9] Modified subscribeToLiveQuery (Added 'isSaving' guard)
        async function subscribeToLiveQuery(query) {
            if (liveQuery) return; // Already subscribed
            
            try {
                liveQuery = await query.subscribe();
                console.log("LiveQuery subscribed successfully.");
                
                liveQuery.on('update', (updatedObject) => {
                    // [v4.9.0 Fix] 守卫逻辑增强
                    if (isSaving) {
                        console.warn('LiveQuery: Update ignored (local save in progress).');
                        return; 
                    }
                    
                    // [v6.4.3] 关键修复：检查推送是否来自自己刚保存的数据
                    // 这是导致单设备自我冲突的根本原因
                    const incomingData = updatedObject.get('data') || {};
                    const incomingClientId = incomingData.lastModifiedBy || '';
                    const isOwnUpdate = incomingClientId === clientId;
                    const timeSinceLastSave = Date.now() - lastSuccessfulSaveTime;
                    
                    if (isOwnUpdate && timeSinceLastSave < LIVEQUERY_GRACE_PERIOD) {
                        console.log(`🛡️ LiveQuery: 忽略自己的推送 (保存后 ${Math.floor(timeSinceLastSave/1000)}s)`);
                        // 仅更新凭证，不应用数据
                        if (updatedObject.updatedAt) {
                            lastCloudUpdateTime = updatedObject.updatedAt.getTime();
                        }
                        cloudDataObject = updatedObject;
                        return;
                    }
                    
                    // [v4.9.0 Fix] 忙碌保护与自动重试
                    // 如果用户正在操作，暂时忽略更新，但设置定时器稍后自动拉取，防止更新永久丢失
                    if (Date.now() - lastLocalActionTime < 3000) {
                        console.warn('LiveQuery: Ignored update due to recent local action. Scheduling retry...');
                        // 5秒后自动重试拉取最新数据（若此时仍在保存，则继续延迟）
                        setTimeout(() => {
                            if (isSaving) {
                                console.warn('LiveQuery retry deferred: save in progress.');
                                setTimeout(() => loadData(true), 2000);
                                return;
                            }
                            console.log('🔄 忙碌结束，正在补拉取错过的云端更新...');
                            loadData(true);
                        }, 5000);
                        return;
                    }
                    
                    // [v6.4.3] 如果是自己的推送（超过静默期），仅更新凭证即可
                    if (isOwnUpdate) {
                        console.log(`📌 LiveQuery: 收到自己的推送，仅更新凭证`);
                        if (updatedObject.updatedAt) {
                            lastCloudUpdateTime = updatedObject.updatedAt.getTime();
                        }
                        cloudDataObject = updatedObject;
                        const incomingVersion = incomingData.dataVersion || 0;
                        if (incomingVersion > localDataVersion) {
                            localDataVersion = incomingVersion;
                        }
                        setAuthStatus('已同步 ✅', 'status-online');
                        return;
                    }
                    
                    console.log('LiveQuery: Data updated from cloud (来自其他设备).');
                    isSyncing = true;
                    
                    try {
                        const newData = updatedObject.get('data');
                        if (newData) {
                            // [v5.8.1] 版本号验证：拒绝接收低版本数据
                            const incomingVersion = newData.dataVersion || 0;
                            if (incomingVersion < localDataVersion) {
                                console.warn(`🛑 LiveQuery拒绝低版本推送: 收到v${incomingVersion}, 本地v${localDataVersion}`);
                                isSyncing = false;
                                return;
                            }
                            
                            // [v5.4.0] 详细日志：显示云端 runningTasks 状态
                            const cloudRunningTasks = newData.runningTasks || [];
                            console.log(`📡 云端 runningTasks: ${cloudRunningTasks.length} 个任务`, cloudRunningTasks.map(t => t[0]));
                            console.log(`📍 本地 runningTasks: ${runningTasks.size} 个任务`, [...runningTasks.keys()]);
                            
                            cloudDataObject = updatedObject;
                            
                            // [v4.9.0 Critical Fix] 立即更新乐观锁基准
                            if (updatedObject.updatedAt) {
                                lastCloudUpdateTime = updatedObject.updatedAt.getTime();
                                console.log(`🔒 (LiveQuery) 基准版本更新为: ${new Date(lastCloudUpdateTime).toLocaleTimeString()}`);
                            }
                            
                            // [v5.8.1] 同步数据版本号
                            localDataVersion = incomingVersion;
                            console.log(`📌 (LiveQuery) 数据版本同步为: v${localDataVersion}`);
                            
                            applyDataState(newData);
                            updateAllUI();
                            updateNotificationSettingsUI();
                            
                            // [v5.4.0] 同步后显示更新后的状态
                            console.log(`✅ 同步完成，当前 runningTasks: ${runningTasks.size} 个任务`, [...runningTasks.keys()]);
                        }
                        setAuthStatus('已同步 ✅', 'status-online');
                    } catch (e) {
                        console.error("Error applying live update:", e);
                    } finally {
                        isSyncing = false;
                    }
                });
                
                liveQuery.on('close', () => {
                    console.log('LiveQuery: Connection closed.');
                    setAuthStatus('已断开 ⚡', 'status-error');
                });
                
                liveQuery.on('error', (error) => {
                    console.error('LiveQuery: Error', error);
                    setAuthStatus(`连接错误: ${error.message}`, 'status-error');
                });
                
            } catch (error) {
                console.error("LiveQuery subscription failed:", error);
                setAuthStatus(`同步失败: ${error.message}`, 'status-error');
                throw error;
            }
        }
        
        // [v5.9.0] Phase 5: 订阅事件表的 LiveQuery
        let eventLiveQuery = null;
        
        async function subscribeToEventLiveQuery() {
            if (!USE_EVENT_SOURCING) return; // 仅在事件驱动模式下启用
            if (eventLiveQuery) return; // 已订阅
            
            const currentUser = AV.User.current();
            if (!currentUser) return;
            
            try {
                const query = new AV.Query('UserTimeBankEvent');
                query.equalTo('owner', currentUser);
                query.notEqualTo('clientId', clientId); // 只监听其他客户端的事件
                
                eventLiveQuery = await query.subscribe();
                console.log('[ES] 事件表 LiveQuery 订阅成功');
                
                eventLiveQuery.on('create', async (eventObj) => {
                    console.log(`📡 [ES] 收到远端事件: ${eventObj.get('eventType')}`);
                    
                    // 检查是否在操作中
                    if (isSaving || Date.now() - lastLocalActionTime < 2000) {
                        console.warn('[ES] 收到远端事件但本地忙碌，稍后处理');
                        // 延迟处理
                        setTimeout(() => {
                            applyRemoteEvent(eventObj);
                        }, 3000);
                        return;
                    }
                    
                    await applyRemoteEvent(eventObj);
                });
                
                eventLiveQuery.on('close', () => {
                    console.log('[ES] 事件表 LiveQuery 连接关闭');
                    eventLiveQuery = null;
                });
                
                eventLiveQuery.on('error', (error) => {
                    console.error('[ES] 事件表 LiveQuery 错误:', error);
                    eventLiveQuery = null;
                });
                
            } catch (error) {
                console.error('[ES] 事件表 LiveQuery 订阅失败:', error);
            }
        }
        
        /**
         * 应用远端事件到本地状态
         */
        async function applyRemoteEvent(eventObj) {
            const eventType = eventObj.get('eventType');
            const payload = eventObj.get('payload') || {};
            const eventTime = eventObj.get('eventTime') || eventObj.get('createdAt').toISOString();
            const remoteClientId = eventObj.get('clientId');
            
            console.log(`🔄 [ES] 应用远端事件: ${eventType} (来自 ${remoteClientId})`);
            
            try {
                // 构建状态
                const localState = {
                    tasks: tasks.reduce((acc, t) => { acc[t.id] = t; return acc; }, {}),
                    transactions: transactions,
                    balance: currentBalance,
                    habitStreaks: {}
                };
                
                // 应用事件
                applyEventToState(localState, eventType, payload, eventTime);
                
                // 同步回全局
                tasks = Object.values(localState.tasks);
                transactions = localState.transactions;
                currentBalance = localState.balance;
                
                // 更新 UI
                updateAllUI();
                
                // 保存快照（静默）
                await saveData();
                
                console.log(`✅ [ES] 远端事件已应用: ${eventType}`);
                
            } catch (e) {
                console.error(`[ES] 应用远端事件失败: ${eventType}`, e);
            }
        }
        
        // [v4.0.0] New Function: Get current app state as an object
        function getAppState() {
            return {
                version: APP_VERSION,
                currentBalance,
                tasks,
                transactions,
                categoryColors: [...categoryColors],
                collapsedCategories: [...collapsedCategories],
                runningTasks: [...runningTasks],
                dailyChanges,
                notificationSettings,
                reportState,
                lastModifiedBy: clientId, // [v6.4.1] 记录最后修改的设备ID
                lastModifiedByName: localStorage.getItem('tb_device_name') || '', // [v6.4.1] 记录设备名称
                lastModifiedAt: Date.now() // [v6.4.1] 记录最后修改时间
            };
        }
        
        // [v4.0.0] New Function: Reset local state to defaults
        function resetLocalData() {
            currentBalance = 0;
            tasks = [];
            transactions = [];
            categoryColors = new Map();
            collapsedCategories = new Set();
            runningTasks = new Map();
            dailyChanges = {};
            // Keep notificationSettings and reportState as they are user prefs
        }

        // [v4.0.0] New Function: Get data from localStorage
        function getLocalData() {
            let dataString = localStorage.getItem('timeBankData');
            let loadedFromBackup = false;
            try {
                if (!dataString) return null; 
                const parsedData = JSON.parse(dataString);
                if (!parsedData.version || !Array.isArray(parsedData.tasks)) { throw new Error("Main data is malformed."); }
                return parsedData;
            } catch (error) {
                console.error('Failed to load main data:', error);
                const backupString = localStorage.getItem('timeBankData_backup');
                if (backupString) {
                    console.log("Attempting to load from backup...");
                    try {
                        const backupData = JSON.parse(backupString);
                         if (!backupData.version || !Array.isArray(backupData.tasks)) { throw new Error("Backup data is also malformed."); }
                        localStorage.setItem('timeBankData', backupString); // Restore backup
                        showAlert("本地数据加载失败，已从上一次的备份中成功恢复。", "数据恢复");
                        return backupData;
                    } catch (backupError) { 
                        console.error('Failed to load backup data:', backupError); 
                        showAlert("严重错误：本地主数据和备份数据均已损坏，无法恢复。", "严重错误");
                        return null;
                    }
                } else { 
                    showAlert("错误：本地数据加载失败且未找到备份。", "错误");
                    return null;
                }
            }
        }
        
        // [v4.0.0] Renamed from applyLoadedData
        // [v4.3.0] Updated migration logic
        // [v4.5.5] 修复: 强制重置 tableVisibleRows
        function applyDataState(data) {
            let dataWasRepaired = false;
            
            if (data) {
                const originalTransactions = JSON.stringify(data.transactions);
                data = repairAndMigrateData(data); 
                if(JSON.stringify(data.transactions) !== originalTransactions) { dataWasRepaired = true; } 
                
                const defaultReportState = { tableSortKey: 'amount_abs_desc', insightView: 'chart', insightSubViewIndex: 0, tableVisibleRows: 10 }; 
                data.reportState = { ...reportState, ...defaultReportState, ...(data.reportState || {}) };
                
                // [v4.5.5] 修复: 强制重置表格分页为 10，确保老用户也能应用新设置
                data.reportState.tableVisibleRows = 10;
                
                // Data migration for older versions
                if (Array.isArray(data.tasks)) {
                    data.tasks.forEach(task => {
                        if (task.isHabit && task.habitDetails) {
                            if (task.habitDetails.targetCountInPeriod === undefined) {
                                task.habitDetails.targetCountInPeriod = 1; dataWasRepaired = true;
                            }
                            if (task.habitDetails.dailyLimit === undefined) {
                                task.habitDetails.dailyLimit = 1; dataWasRepaired = true;
                            }
                            if (task.habitDetails.isBroken === undefined) {
                                task.habitDetails.isBroken = false; dataWasRepaired = true;
                            }
                        }
                    });
                }
                if (Array.isArray(data.transactions)) {
                    data.transactions.forEach(t => {
                        if (t.isStreakAdvancement === undefined) {
                            // [v4.3.0] Set to false by default. Rebuild isn't needed here,
                            // it will run on the first backdate/undo.
                            t.isStreakAdvancement = false; dataWasRepaired = true;
                        }
                    });
                }

                if (!data.version || data.version < APP_VERSION || dataWasRepaired) { 
                    data.version = APP_VERSION; 
                    if (dataWasRepaired) console.log("Data repaired/migrated on load.");
                    // Don't save here, let the natural save process handle it
                } 
                
                currentBalance = data.currentBalance || 0; 
                tasks = data.tasks || []; 
                transactions = data.transactions || []; 
                transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); 
                categoryColors = new Map(data.categoryColors || []); 
                collapsedCategories = new Set(data.collapsedCategories || []); 
                // [v5.4.0] 完全重写 runningTasks 同步逻辑
                // 核心原则：首次加载时完全信任云端，只有在本地有近期操作时才保活本地任务
                const cloudRunning = new Map(data.runningTasks || []);
                const localRunningSize = runningTasks.size;
                const timeSinceLastAction = Date.now() - lastLocalActionTime;
                const isRecentlyActive = timeSinceLastAction < 3000;
                
                // [v6.4.4] 新增：检查是否在保存后的保护期内
                const timeSinceLastSave = Date.now() - lastSuccessfulSaveTime;
                const isInSaveProtection = lastSuccessfulSaveTime > 0 && timeSinceLastSave < LIVEQUERY_GRACE_PERIOD;
                
                console.log(`[applyDataState] 诊断: hasCompletedFirstCloudSync=${hasCompletedFirstCloudSync}, localRunning=${localRunningSize}, cloudRunning=${cloudRunning.size}, timeSinceLastAction=${Math.floor(timeSinceLastAction/1000)}s, timeSinceLastSave=${Math.floor(timeSinceLastSave/1000)}s, isInSaveProtection=${isInSaveProtection}`);
                
                if (!hasCompletedFirstCloudSync) {
                    // 首次加载：完全使用云端数据，不做任何合并
                    console.log('🔄 首次加载，完全信任云端 runningTasks:', [...cloudRunning.keys()]);
                    runningTasks = cloudRunning;
                } else if (isInSaveProtection) {
                    // [v6.4.4] 关键修复：刚保存完成后，完全信任本地状态
                    // 这是导致"任务停止后1秒复活"的根本原因
                    console.log(`🛡️ 保存保护期内 (${Math.floor(timeSinceLastSave/1000)}s < ${LIVEQUERY_GRACE_PERIOD/1000}s)，保持本地 runningTasks: ${localRunningSize}个`);
                    // 不做任何改变，保持当前 runningTasks 状态
                } else if (isRecentlyActive) {
                    // [v6.0.0 Fix] 近期活跃：需要区分"本地新开始"和"被其他端结束"的任务
                    // 场景1: 用户结束任务 → localRunningSize=0, 但云端还有 → 应该移除云端的
                    // 场景2: 用户开始任务 → localRunningSize>0, 云端没有 → 只保活最近开始的
                    console.log(`🛡️ 近期活跃，执行智能合并 (本地=${localRunningSize}, 云端=${cloudRunning.size})`);
                    
                    // 保存本地状态引用
                    const localRunning = new Map(runningTasks);
                    
                    // 开始构建最终状态
                    runningTasks = new Map();
                    
                    // 1. 保留云端和本地都有的任务（取本地的，因为有最新的计时状态）
                    cloudRunning.forEach((val, key) => {
                        if (localRunning.has(key)) {
                            runningTasks.set(key, localRunning.get(key));
                        }
                    });
                    
                    // 2. [v6.0.0] 只保活"最近开始"的本地任务（3秒内开始的）
                    // 如果任务很久前就开始了，但云端没有，说明是被其他端结束的，不应恢复
                    const recentThreshold = Date.now() - 5000; // 5秒内开始的才算"新开始"
                    localRunning.forEach((val, key) => {
                        if (!cloudRunning.has(key)) {
                            const taskStartTime = val.startTime || 0;
                            if (taskStartTime > recentThreshold) {
                                console.log(`🛡️ 保活本地新任务: ${key} (启动于 ${new Date(taskStartTime).toLocaleTimeString()})`);
                                runningTasks.set(key, val);
                            } else {
                                console.log(`⏭️ 跳过被其他端结束的任务: ${key} (启动时间较早)`);
                            }
                        }
                    });
                    
                    // 3. 不添加云端有但本地没有的任务（用户刚结束/取消的）
                    cloudRunning.forEach((val, key) => {
                        if (!localRunning.has(key) && !runningTasks.has(key)) {
                            console.log(`🛑 跳过云端任务(本地已停止): ${key}`);
                        }
                    });
                } else {
                    // 默认：完全信任云端数据
                    console.log(`🔄 信任云端 runningTasks (本地=${localRunningSize}, 云端=${cloudRunning.size})`);
                    runningTasks = cloudRunning;
                } 
                dailyChanges = data.dailyChanges || {}; 
                notificationSettings = { ...notificationSettings, ...(data.notificationSettings || {}) }; 
                if (!notificationSettings.floatingTimerPermissionPrompted && Array.isArray(tasks) && tasks.some(t => t.enableFloatingTimer)) {
                    notificationSettings.floatingTimerPermissionPrompted = true;
                }
                
                // [v4.6.2 修复] 只有在本地 reportState 为空（首次加载）时才应用云端设置
                // 防止实时同步 (LiveQuery) 覆盖用户当前正在操作的视图状态，解决"点击标签又跳回"的 Bug
                if (!reportState || !reportState.trendPeriod) {
                    const defaultReportState = { tableSortKey: 'amount_abs_desc', insightView: 'chart', insightSubViewIndex: 0, tableVisibleRows: 10 }; 
                    reportState = { ...defaultReportState, ...(data.reportState || {}) };
                }
            } else {
                // No data provided (e.g., new user), apply defaults
                resetLocalData();
            }
        }

        function repairAndMigrateData(data) { if (!data.transactions || !Array.isArray(data.transactions) || !Array.isArray(data.tasks)) { return data; } let repairedCount = 0; const taskNameMap = new Map(data.tasks.map(task => [task.name, task.id])); data.transactions.forEach(t => { if (t.isSystem) return; let needsUpdate = false; if (!t.taskId && t.description) { const match = t.description.match(/"([^"]+)"/); if (match && match[1]) { const taskNameInDesc = match[1]; if (taskNameMap.has(taskNameInDesc)) { t.taskId = taskNameMap.get(taskNameInDesc); if (!t.taskName) { t.taskName = taskNameInDesc; } repairedCount++; needsUpdate = true; } } } if (!t.type) { const isEarn = t.amount > 0; t.type = isEarn ? 'earn' : 'spend'; t.amount = Math.abs(t.amount); needsUpdate = true; } }); if (repairedCount > 0) { console.log(`[Data Repair] Successfully repaired ${repairedCount} transactions by adding missing task IDs.`); } return data; }
        
        function renderColorSelectors(editingColor = null) { const usedColors = Array.from(categoryColors.values()); const render = (containerId, colors) => { const container = document.getElementById(containerId); container.innerHTML = colors.map(color => { const isUsed = usedColors.includes(color); const isDisabled = isUsed && color !== editingColor; const isSelected = color === currentSelectedColor; return `<div class="color-swatch ${isDisabled ? 'disabled' : ''} ${isSelected ? 'selected' : ''}" style="background-color: ${color};" data-color="${color}"><span class="checkmark">✔</span></div>`; }).join(''); }; render('earnColorSelector', earnColors); render('spendColorSelector', spendColors); }
        function handleColorSelection(event) { const swatch = event.target.closest('.color-swatch'); if (!swatch || swatch.classList.contains('disabled')) return; currentSelectedColor = swatch.dataset.color; const selector = swatch.parentElement; selector.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected')); swatch.classList.add('selected'); }
        function getRandomAvailableColor(taskType) { const isEarn = ['reward', 'continuous', 'continuous_target'].includes(taskType); const colorPalette = isEarn ? earnColors : spendColors; const usedColors = new Set(Array.from(categoryColors.values())); const availableColors = colorPalette.filter(c => !usedColors.has(c)); if (availableColors.length > 0) { return availableColors[Math.floor(Math.random() * availableColors.length)]; } return colorPalette[Math.floor(Math.random() * colorPalette.length)]; }
        
        // --- Global Event Listeners ---
        function setupTaskModalEventListeners() {
            document.getElementById('isHabitToggle').addEventListener('change', (e) => toggleHabitSettings(e.target.checked));
            document.getElementById('isReminderToggle').addEventListener('change', (e) => toggleReminderSettings(e.target.checked));
            const appToggleEl = document.getElementById('isAppLauncherToggle');
            if (appToggleEl) appToggleEl.addEventListener('change', (e) => toggleAppLauncherSettings(e.target.checked));
            document.getElementById('reminderModeSwitch').addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') switchReminderMode(e.target.dataset.mode);
            });
            document.getElementById('earnColorSelector').addEventListener('click', handleColorSelection);
            document.getElementById('spendColorSelector').addEventListener('click', handleColorSelection);
            
            // [v4.0.0] Toggle email field based on auth action
            document.getElementById('registerButton').addEventListener('click', () => {
                document.getElementById('authEmailGroup').classList.remove('hidden');
            });
            document.getElementById('loginButton').addEventListener('click', () => {
                document.getElementById('authEmailGroup').classList.add('hidden');
            });
        }
        // [v4.5.8] 全平台自动同步守卫 (Android + Desktop PWA)
        // [v5.4.0] 增强：添加定期检查机制，解决 LiveQuery 可能不触发的问题
        function setupAutoSync() {
            // 防抖动：避免频繁切换导致重复请求
            let lastSyncTime = 0;
            const SYNC_COOLDOWN = 5000; // 5秒冷却时间
            const PERIODIC_CHECK_INTERVAL = 60000; // 60秒定期检查

            const triggerSync = async (source) => {
                const now = Date.now();
                // 1. 检查冷却时间
                if (now - lastSyncTime < SYNC_COOLDOWN) return;
                // 2. 检查登录
                if (!AV.User.current()) return;
                // 3. 检查保存状态
                if (typeof isSaving !== 'undefined' && isSaving) return;
                // [v4.8.8 Fix] 移除运行态拦截，改为在 applyDataState 中进行智能合并
                // 这样即使有任务在跑，也能同步到手机上补记的新记录
                console.log(`[${source}] 检测到活跃，正在同步最新数据...`);
                lastSyncTime = now;
                // UI 提示 (静默更新)
                const authStatus = document.getElementById('authStatus');
                if(authStatus) {
                    authStatus.textContent = '🔄 正在同步云端数据...';
                    authStatus.className = 'status-syncing';
                }
                try {
                    // [v6.5.0] 修复：多表模式下使用 DAL.loadAll()，避免混用旧架构
                    if (USE_MULTI_TABLE && DAL.profileObject) {
                        await DAL.loadAll();
                    } else {
                        await loadData(true);
                    }
                    console.log('同步完成');
                } catch (e) {
                    console.error('自动同步失败:', e);
                }
            };
            
            // [v5.4.0] 定期检查云端版本（解决 LiveQuery 可能不触发的问题）
            // [v6.4.3] 增加保护：检查来源并跳过自己的更新
            const checkCloudVersion = async () => {
                if (!AV.User.current() || !cloudDataObject || isSaving) return;
                
                // [v6.4.3] 刚保存完不检查，避免触发自我冲突
                if (Date.now() - lastSuccessfulSaveTime < 10000) {
                    return;
                }
                
                try {
                    const query = new AV.Query('UserTimeBankData');
                    const remoteObject = await query.get(cloudDataObject.id);
                    const remoteUpdatedAt = remoteObject.updatedAt.getTime();
                    const remoteData = remoteObject.get('data') || {};
                    const remoteClientId = remoteData.lastModifiedBy || '';
                    
                    // [v6.4.3] 如果云端数据来自自己，跳过拉取
                    if (remoteClientId === clientId) {
                        // 仅更新凭证
                        lastCloudUpdateTime = remoteUpdatedAt;
                        cloudDataObject = remoteObject;
                        return;
                    }
                    
                    // 如果云端版本比本地版本新超过 2 秒，说明有其他设备的更新
                    if (lastCloudUpdateTime > 0 && remoteUpdatedAt > lastCloudUpdateTime + 2000) {
                        console.log('🔔 定期检查发现云端有新版本(来自其他设备)，正在拉取...');
                        await loadData(true);
                    }
                } catch (e) {
                    console.warn('定期版本检查失败:', e.message);
                }
            };
            
            // 启动定期检查（每 60 秒）
            setInterval(checkCloudVersion, PERIODIC_CHECK_INTERVAL);

            // [v6.4.3] 移除定期差异检测，避免误报导致的自我冲突
            // 差异检测仅在长时间休眠后恢复可见时触发
            // setInterval(() => detectAndPromptSyncDrift('interval'), PERIODIC_CHECK_INTERVAL);

            // 监听器 1: 页面可见性变化 (手机切后台/电脑切标签页)
            // [v6.4.3] 仅在长时间休眠后触发同步，短时间切换依赖 LiveQuery
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // [v6.0.0] 休眠恢复保护：检测休眠时长
                    const hibernateDuration = lastHibernateTime > 0 ? Date.now() - lastHibernateTime : 0;
                    const wasLongHibernate = hibernateDuration > 60000; // 超过1分钟算长休眠
                    
                    if (wasLongHibernate) {
                        console.log(`🛡️ [v6.0.0] 检测到长时间休眠 (${Math.floor(hibernateDuration/1000)}秒)，启用恢复保护`);
                        isRecoveringFromHibernate = true;
                        // 临时锁定保存，等待云端同步完成
                        hasCompletedFirstCloudSync = false;
                        triggerSync('Visibility');
                    }
                    // [v6.4.3] 短时间休眠不触发同步，避免自我冲突
                    
                    // [v6.4.3] 仅在长时间休眠后才检测差异，避免频繁误报
                    (async () => {
                        await flushOfflineEventQueue();
                        if (wasLongHibernate) {
                            // 延迟执行，给云端同步时间
                            setTimeout(() => detectAndPromptSyncDrift('page-visible'), 5000);
                        }
                    })();
                    // [v5.2.1] 页面恢复可见时刷新屏幕时间卡片
                    updateScreenTimeCard();
                    lastHibernateTime = 0; // 重置
                } else {
                    // 页面进入休眠，记录时间
                    lastHibernateTime = Date.now();
                    console.log('💤 页面进入休眠状态');
                }
            });

            // 监听器 2: 窗口获得焦点 (电脑端鼠标点击窗口/Alt+Tab切回来)
            // [v6.4.3] 仅在长时间休眠后触发同步，避免频繁触发
            window.addEventListener('focus', () => {
                // [v6.0.0] 窗口焦点恢复也可能是从长时间休眠回来
                // 如果 lastHibernateTime 有值，说明之前页面隐藏过
                if (lastHibernateTime > 0) {
                    const hibernateDuration = Date.now() - lastHibernateTime;
                    if (hibernateDuration > 60000) {
                        console.log(`🛡️ [v6.0.0] Focus: 检测到长时间休眠 (${Math.floor(hibernateDuration/1000)}秒)，启用恢复保护`);
                        isRecoveringFromHibernate = true;
                        hasCompletedFirstCloudSync = false;
                        triggerSync('Focus');
                    }
                    // [v6.4.3] 短时间休眠不触发同步，依赖 LiveQuery
                }
            });
        }

        // 在初始化时启动监听
        document.addEventListener('DOMContentLoaded', async () => {
            await checkAndBootstrap();
            await initApp();
            // 启动自动同步守卫
            setupAutoSync();
            const allTasksInfoBtn = document.getElementById('allTasksInfoButton');
            const allTasksInfoBtnSpend = document.getElementById('allTasksInfoButtonSpend');
            if (localStorage.getItem('allTasksInfoHidden') === 'true') {
                if (allTasksInfoBtn) allTasksInfoBtn.style.display = 'none';
                if (allTasksInfoBtnSpend) allTasksInfoBtnSpend.style.display = 'none';
            }
            const activityInfoBtn = document.getElementById('activityHeatmapInfoButton');
            if (activityInfoBtn && localStorage.getItem('activityHeatmapInfoHidden') === 'true') {
                activityInfoBtn.style.display = 'none';
            }
            const analysisInfoBtn = document.getElementById('analysisDashboardInfoButton');
            if (analysisInfoBtn && localStorage.getItem('analysisDashboardInfoHidden') === 'true') {
                analysisInfoBtn.style.display = 'none';
            }
            const tableInfoBtn = document.getElementById('tableInfoButton');
            if (tableInfoBtn && localStorage.getItem('tableInfoHidden') === 'true') {
                tableInfoBtn.style.display = 'none';
            }
            const trendInfoBtn = document.getElementById('trendInfoButton');
            if (trendInfoBtn && localStorage.getItem('trendInfoHidden') === 'true') {
                trendInfoBtn.style.display = 'none';
            }
            // [v5.3.0] 自动检测补录说明按钮隐藏检查
            const autoDetectInfoBtn = document.getElementById('autoDetectInfoButton');
            if (autoDetectInfoBtn && localStorage.getItem('autoDetectInfoHidden') === 'true') {
                autoDetectInfoBtn.style.display = 'none';
            }
            // [v5.10.0] 屏幕时间说明按钮隐藏检查
            const screenTimeInfoBtn = document.getElementById('screenTimeInfoButton');
            if (screenTimeInfoBtn && localStorage.getItem('screenTimeInfoHidden') === 'true') {
                screenTimeInfoBtn.style.display = 'none';
            }
        });
        window.addEventListener('beforeunload', () => {
             // [v4.0.0] Only save locally on unload if not logged in
             if (!AV.User.current()) {
                saveData();
             }
        });
        document.addEventListener('click', e => { if (e.target.classList.contains('modal')) { if (e.target.id === 'taskModal') hideTaskModal(); else if (e.target.id === 'historyModal') hideHistoryModal(); else if (e.target.id === 'dayDetailModal') hideDayDetailModal(); else if (e.target.id === 'backdateModal') hideBackdateModal(); else if (e.target.id === 'activityHeatmapInfoModal') hideActivityHeatmapInfoModal(); else if (e.target.id === 'analysisDashboardInfoModal') hideAnalysisDashboardInfoModal(); else if (e.target.id === 'tableInfoModal') hideTableInfoModal(); else if (e.target.id === 'trendInfoModal') hideTrendInfoModal(); } });
        document.addEventListener('keydown', e => { if (e.key === 'Escape') { if (document.getElementById('taskModal').classList.contains('show')) hideTaskModal(); else if (document.getElementById('historyModal').classList.contains('show')) hideHistoryModal(); else if (document.getElementById('dayDetailModal').classList.contains('show')) hideDayDetailModal(); else if (document.getElementById('backdateModal').classList.contains('show')) hideBackdateModal(); else if (document.getElementById('activityHeatmapInfoModal').classList.contains('show')) hideActivityHeatmapInfoModal(); else if (document.getElementById('analysisDashboardInfoModal').classList.contains('show')) hideAnalysisDashboardInfoModal(); else if (document.getElementById('tableInfoModal').classList.contains('show')) hideTableInfoModal(); else if (document.getElementById('trendInfoModal').classList.contains('show')) hideTrendInfoModal(); } else if ((e.ctrlKey || e.metaKey) && e.key === 'n') { e.preventDefault(); showTaskModal(); } });
        document.addEventListener('touchstart', function(event) { const target = event.target.closest('.task-name-scrollable'); if (target) { target.style.overflowX = 'auto'; target.style.textOverflow = 'clip'; } }, { passive: true });
        document.addEventListener('touchend', function(event) { const target = event.target.closest('.task-name-scrollable'); setTimeout(() => { if (target && !target.matches(':hover') && !target.matches(':focus')) { target.style.overflowX = 'hidden'; target.style.textOverflow = 'ellipsis'; } }, 500); }, { passive: true });
        document.addEventListener('focusout', function(event) { const target = event.target; if (target && target.classList && target.classList.contains('task-name-scrollable')) { if (!target.matches(':hover')) { target.style.overflowX = 'hidden'; target.style.textOverflow = 'ellipsis'; } } }, true);
        document.addEventListener('mouseleave', function(event) { const target = event.target; if (target && target.classList && target.classList.contains('task-name-scrollable')) { if (document.activeElement !== target) { target.style.overflowX = 'hidden'; target.style.textOverflow = 'ellipsis'; } } }, true);

        // 初始化滑动导航
        setupSwipeNavigation();
        
        // [v5.0.1] 防止边界过度滚动（Android WebView 兼容）
        (function() {
            const scrollContainer = document.getElementById('appScrollContainer');
            if (!scrollContainer) return;
            
            let startY = 0;
            let startScrollTop = 0;
            
            scrollContainer.addEventListener('touchstart', function(e) {
                startY = e.touches[0].pageY;
                startScrollTop = scrollContainer.scrollTop;
            }, { passive: true });
            
            scrollContainer.addEventListener('touchmove', function(e) {
                // [v5.1.0] 如果触摸事件来自嵌套的独立滚动容器，不干预其滚动
                const target = e.target;
                if (target && target.closest && target.closest('.version-history-container, .history-combined-container, .modal-content')) {
                    return; // 让嵌套容器自行处理滚动
                }
                
                // 日历长按激活时，完全阻止滚动
                if (typeof heatmapTooltipLongPressActive !== 'undefined' && heatmapTooltipLongPressActive) {
                    e.preventDefault();
                    return;
                }
                
                // 趋势图长按激活时，完全阻止滚动
                if (typeof trendTooltipLongPressActive !== 'undefined' && trendTooltipLongPressActive) {
                    e.preventDefault();
                    return;
                }
                
                const scrollTop = scrollContainer.scrollTop;
                const scrollHeight = scrollContainer.scrollHeight;
                const clientHeight = scrollContainer.clientHeight;
                const deltaY = e.touches[0].pageY - startY;
                
                // 到达顶部且继续下拉
                if (scrollTop <= 0 && deltaY > 0) {
                    e.preventDefault();
                    return;
                }
                
                // 到达底部且继续上拉
                if (scrollTop + clientHeight >= scrollHeight && deltaY < 0) {
                    e.preventDefault();
                    return;
                }
            }, { passive: false });
        })();
    </script>
<script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js') // [v4.5.4] 修复: 移除绝对路径并使用相对路径
          .then(reg => console.log('✅ PWA 已启用'))
          .catch(err => console.log('❌ 错误:', err));
      });
    }
    </script>
</html>


